{"id": "2510.27113", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.27113", "abs": "https://arxiv.org/abs/2510.27113", "authors": ["Man Zhang", "Yuechen Li", "Tao Yue", "Kai-Yuan Cai"], "title": "Empirical Studies on Quantum Optimization for Software Engineering: A Systematic Analysis", "comment": null, "summary": "In recent years, quantum, quantum-inspired, and hybrid algorithms are\nincreasingly showing promise for solving software engineering optimization\nproblems. However, best-intended practices for conducting empirical studies\nhave not yet well established. In this paper, based on the primary studies\nidentified from the latest systematic literature review on quantum optimization\nfor software engineering problems, we conducted a systematic analysis on these\nstudies from various aspects including experimental designs, hyperparameter\nsettings, case studies, baselines, tooling, and metrics. We identify key gaps\nin the current practices such as limited reporting of the number of\nrepetitions, number of shots, and inadequate consideration of noise handling,\nas well as a lack of standardized evaluation protocols such as the adoption of\nquality metrics, especially quantum-specific metrics. Based on our analysis, we\nprovide insights for designing empirical studies and highlight the need for\nmore real-world and open case studies to assess cost-effectiveness and\npractical utility of the three types of approaches: quantum-inspired, quantum,\nand hybrid. This study is intended to offer an overview of current practices\nand serve as an initial reference for designing and conducting empirical\nstudies on evaluating and comparing quantum, quantum-inspired, and hybrid\nalgorithms in solving optimization problems in software engineering."}
{"id": "2510.27163", "categories": ["cs.SE", "cs.AI", "cs.HC", "D.2.8; D.2.9.m; I.2"], "pdf": "https://arxiv.org/pdf/2510.27163", "abs": "https://arxiv.org/abs/2510.27163", "authors": ["Jieshan Chen", "Suyu Ma", "Qinghua Lu", "Sung Une Lee", "Liming Zhu"], "title": "MARIA: A Framework for Marginal Risk Assessment without Ground Truth in AI Systems", "comment": "9 pages, 1 figure", "summary": "Before deploying an AI system to replace an existing process, it must be\ncompared with the incumbent to ensure improvement without added risk.\nTraditional evaluation relies on ground truth for both systems, but this is\noften unavailable due to delayed or unknowable outcomes, high costs, or\nincomplete data, especially for long-standing systems deemed safe by\nconvention. The more practical solution is not to compute absolute risk but the\ndifference between systems. We therefore propose a marginal risk assessment\nframework, that avoids dependence on ground truth or absolute risk. It\nemphasizes three kinds of relative evaluation methodology, including\npredictability, capability and interaction dominance. By shifting focus from\nabsolute to relative evaluation, our approach equips software teams with\nactionable guidance: identifying where AI enhances outcomes, where it\nintroduces new risks, and how to adopt such systems responsibly."}
{"id": "2510.27229", "categories": ["cs.SE", "cs.FL"], "pdf": "https://arxiv.org/pdf/2510.27229", "abs": "https://arxiv.org/abs/2510.27229", "authors": ["Ali Nour Eldin", "Benjamin Dalmas", "Walid Gaaloul"], "title": "On the Marriage of Theory and Practice in Data-Aware Business Processes via Low-Code", "comment": null, "summary": "In recent years, there has been a growing interest in the verification of\nbusiness process models. Despite their lack of formal characterization, these\nmodels are widely adopted in both industry and academia. To address this issue,\nformalizing the execution semantics of business process modeling languages is\nessential. Since data and process are two facets of the same coin, and data are\ncritical elements in the execution of process models, this work introduces\nProving an eXecutable BPMN injected with data, BPMN-ProX. BPMN-ProX is a\nlow-code testing framework that significantly enhances the verification of\ndata-aware BPMN. This low-code platform helps bridge the gap between\nnon-technical experts and professionals by proposing a tool that integrates\nadvanced data handling and employs a robust verification mechanism through\nstate-of-the-art model checkers. This innovative approach combines theoretical\nverification with practical modeling, fostering more agile, reliable, and\nuser-centric business process management."}
{"id": "2510.27244", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.27244", "abs": "https://arxiv.org/abs/2510.27244", "authors": ["Ora Nova Fandina", "Gal Amram", "Eitan Farchi", "Shmulik Froimovich", "Raviv Gal", "Wesam Ibraheem", "Rami Katan", "Alice Podolsky", "Orna Raz"], "title": "Vintage Code, Modern Judges: Meta-Validation in Low Data Regimes", "comment": null, "summary": "Application modernization in legacy languages such as COBOL, PL/I, and REXX\nfaces an acute shortage of resources, both in expert availability and in\nhigh-quality human evaluation data. While Large Language Models as a Judge\n(LaaJ) offer a scalable alternative to expert review, their reliability must be\nvalidated before being trusted in high-stakes workflows. Without principled\nvalidation, organizations risk a circular evaluation loop, where unverified\nLaaJs are used to assess model outputs, potentially reinforcing unreliable\njudgments and compromising downstream deployment decisions. Although various\nautomated approaches to validating LaaJs have been proposed, alignment with\nhuman judgment remains a widely used and conceptually grounded validation\nstrategy. In many real-world domains, the availability of human-labeled\nevaluation data is severely limited, making it difficult to assess how well a\nLaaJ aligns with human judgment. We introduce SparseAlign, a formal framework\nfor assessing LaaJ alignment with sparse human-labeled data. SparseAlign\ncombines a novel pairwise-confidence concept with a score-sensitive alignment\nmetric that jointly capture ranking consistency and score proximity, enabling\nreliable evaluator selection even when traditional statistical methods are\nineffective due to limited annotated examples. SparseAlign was applied\ninternally to select LaaJs for COBOL code explanation. The top-aligned\nevaluators were integrated into assessment workflows, guiding model release\ndecisions. We present a case study of four LaaJs to demonstrate SparseAlign's\nutility in real-world evaluation scenarios."}
{"id": "2510.27067", "categories": ["cs.PL", "cs.PF", "B.8.2; D.3.4"], "pdf": "https://arxiv.org/pdf/2510.27067", "abs": "https://arxiv.org/abs/2510.27067", "authors": ["Marouane Benbetka", "Merwan Bekkar", "Riyadh Baghdadi", "Martin Kong"], "title": "Dependence-Driven, Scalable Quantum Circuit Mapping with Affine Abstractions", "comment": "To appear in the Proceedings of the 2026 International Symposium on\n  Code Generation and Optimization (CGO 2026)", "summary": "Qubit Mapping is a critical task in Quantum Compilation, as modern Quantum\nProcessing Units (QPUs) are constrained to nearest-neighbor interactions\ndefined by a qubit coupling graph. This compiler pass repairs the connectivity\nof two-qubit gates whose operands are not adjacent by inserting SWAP gates that\nmove the state of qubits between directly connected qubits. Deciding when to\nintroduce SWAPs while minimizing their count is critical because the error in\nquantum programs increases exponentially with the circuit latency, measured in\nnumber of gates along the critical path of the circuit. Prior work for this\nproblem relied on heuristics and exact methods that partition the circuit into\ntwo or more layers, but failed to exploit valuable dependence information in\nany form.\n  This paper introduces a novel qubit mapping algorithm based on the weight of\ntransitive dependences. The introduced mapper models quantum circuits with\naffine abstractions thereby yielding the ability to compute transitive\ndependences. In turn, the newfound information is used to partition circuits by\ndependence distances and compute, efficiently, distinct weights for each layer.\nWe evaluate the efficiency of our mapper on IBM and Rigetti QPUs, using the\nlarge datasets from the QUEKO and QASMBench benchmark suites, and against four\nbaseline tools (QMAP, Sabre, Cirq and TKET), demonstrating notable improvements\nin circuit depth and swap count while delivering competitive scalability."}
{"id": "2510.27344", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.27344", "abs": "https://arxiv.org/abs/2510.27344", "authors": ["Thomas Schulik", "Viswanatha Reddy Batchu", "Ramesh Kumar Dharmapuri", "Saran Gundlapalli", "Parthasarathy Nadarajan", "Philipp Pelcz"], "title": "Efficient Integration of cross platform functions onto service-oriented architectures", "comment": "ELIV Conference 2025, Bonn, Germany", "summary": "The automotive industry is currently undergoing a major transformation with\nrespect to the Electric/Electronic (E/E) and software architecture, driven by a\nsignificant increase in the complexity of the technological stack within a\nvehicle. This complexity acts as a driving force for Software-Defined Vehicles\n(SDVs) leading to the evolution of the automotive E/E architectures from\ndecentralized configuration comprising multiple Electronic Control Units (ECUs)\ntowards a more integrated configuration comprising a smaller number of ECUs,\ndomain controllers, gateways, and High-Performance Computers (HPCs) [2]. This\ntransition along with several other reasons have resulted in heterogeneous\nsoftware platforms such as AUTOSAR Classic, AUTOSAR Adaptive, and prototypical\nframeworks like ROS 2. It is therefore essential to develop applications that\nare both hardware- and platform/middleware-agnostic to attain development and\nintegration efficiency. This work presents an application development and\nintegration concept to facilitate developing applications as Software as a\nProduct (SaaP), while simultaneously ensuring efficient integration onto\nmultiple software architecture platforms. The concept involves designing\napplications in a hardware- and software platform-agnostic manner and\nstandardizing application interfaces [6]. It also includes describing the\nrelevant aspects of the application and corresponding middleware in a\nmachine-readable format to aid the integration of developed applications.\nAdditionally, tools are developed to facilitate semi-automation of the\ndevelopment and integration processes. An example application has been\ndeveloped and integrated onto AUTOSAR Adaptive and ROS 2, demonstrating the\napplicability of the approach. Finally, metrics are presented to show the\nefficiency of the overall concept."}
{"id": "2510.27417", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.27417", "abs": "https://arxiv.org/abs/2510.27417", "authors": ["Jarne Besjes", "Robbe Nooyens", "Tolgahan Bardakci", "Mutlu Beyazit", "Serge Demeyer"], "title": "Agentic LLMs for REST API Test Amplification: A Comparative Study Across Cloud Applications", "comment": null, "summary": "Representational State Transfer (REST) APIs are a cornerstone of modern cloud\nnative systems. Ensuring their reliability demands automated test suites that\nexercise diverse and boundary level behaviors. Nevertheless, designing such\ntest cases remains a challenging and resource intensive endeavor. This study\nextends prior work on Large Language Model (LLM) based test amplification by\nevaluating single agent and multi agent configurations across four additional\ncloud applications. The amplified test suites maintain semantic validity with\nminimal human intervention. The results demonstrate that agentic LLM systems\ncan effectively generalize across heterogeneous API architectures, increasing\nendpoint and parameter coverage while revealing defects. Moreover, a detailed\nanalysis of computational cost, runtime, and energy consumption highlights\ntrade-offs between accuracy, scalability, and efficiency. These findings\nunderscore the potential of LLM driven test amplification to advance the\nautomation and sustainability of REST API testing in complex cloud\nenvironments."}
{"id": "2510.27565", "categories": ["cs.SE", "cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2510.27565", "abs": "https://arxiv.org/abs/2510.27565", "authors": ["Forough Mehralian", "Ryan Shar", "James R. Rae", "Alireza Hashemi"], "title": "CodeAlignBench: Assessing Code Generation Models on Developer-Preferred Code Adjustments", "comment": null, "summary": "As large language models become increasingly capable of generating code,\nevaluating their performance remains a complex and evolving challenge. Existing\nbenchmarks primarily focus on functional correctness, overlooking the diversity\nof real-world coding tasks and developer expectations. To this end, we\nintroduce a multi-language benchmark that evaluates LLM instruction-following\ncapabilities and is extensible to operate on any set of standalone coding\nproblems. Our benchmark evaluates instruction following in two key settings:\nadherence to pre-defined constraints specified with the initial problem, and\nthe ability to perform refinements based on follow-up instructions. For this\npaper's analysis, we empirically evaluated our benchmarking pipeline with\nprogramming tasks from LiveBench, that are also automatically translated from\nPython into Java and JavaScript. Our automated benchmark reveals that models\nexhibit differing levels of performance across multiple dimensions of\ninstruction-following. Our benchmarking pipeline provides a more comprehensive\nevaluation of code generation models, highlighting their strengths and\nlimitations across languages and generation goals."}
{"id": "2510.27640", "categories": ["cs.SE", "cs.LG", "D.2"], "pdf": "https://arxiv.org/pdf/2510.27640", "abs": "https://arxiv.org/abs/2510.27640", "authors": ["Luz-Viviana Cobaleda", "Julián Carvajal", "Paola Vallejo", "Andrés López", "Raúl Mazo"], "title": "Enhancing software product lines with machine learning components", "comment": "pp. 73-94, 2 figures", "summary": "Modern software systems increasingly integrate machine learning (ML) due to\nits advancements and ability to enhance data-driven decision-making. However,\nthis integration introduces significant challenges for software engineering,\nespecially in software product lines (SPLs), where managing variability and\nreuse becomes more complex with the inclusion of ML components. Although\nexisting approaches have addressed variability management in SPLs and the\nintegration of ML components in isolated systems, few have explored the\nintersection of both domains. Specifically, there is limited support for\nmodeling and managing variability in SPLs that incorporate ML components. To\nbridge this gap, this article proposes a structured framework designed to\nextend Software Product Line engineering, facilitating the integration of ML\ncomponents. It facilitates the design of SPLs with ML capabilities by enabling\nsystematic modeling of variability and reuse. The proposal has been partially\nimplemented with the VariaMos tool."}
{"id": "2510.27675", "categories": ["cs.SE", "cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.27675", "abs": "https://arxiv.org/abs/2510.27675", "authors": ["Md Abdul Hannan", "Ronghao Ni", "Chi Zhang", "Limin Jia", "Ravi Mangal", "Corina S. Pasareanu"], "title": "On Selecting Few-Shot Examples for LLM-based Code Vulnerability Detection", "comment": null, "summary": "Large language models (LLMs) have demonstrated impressive capabilities for\nmany coding tasks, including summarization, translation, completion, and code\ngeneration. However, detecting code vulnerabilities remains a challenging task\nfor LLMs. An effective way to improve LLM performance is in-context learning\n(ICL) - providing few-shot examples similar to the query, along with correct\nanswers, can improve an LLM's ability to generate correct solutions. However,\nchoosing the few-shot examples appropriately is crucial to improving model\nperformance. In this paper, we explore two criteria for choosing few-shot\nexamples for ICL used in the code vulnerability detection task. The first\ncriterion considers if the LLM (consistently) makes a mistake or not on a\nsample with the intuition that LLM performance on a sample is informative about\nits usefulness as a few-shot example. The other criterion considers similarity\nof the examples with the program under query and chooses few-shot examples\nbased on the $k$-nearest neighbors to the given sample. We perform evaluations\nto determine the benefits of these criteria individually as well as under\nvarious combinations, using open-source models on multiple datasets."}
