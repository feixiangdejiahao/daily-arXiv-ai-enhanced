<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 38]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [APRIL: API Synthesis with Automatic Prompt Optimization and Reinforcement Learning](https://arxiv.org/abs/2509.25196)
*Hua Zhong,Shan Jiang,Sarfraz Khurshid*

Main category: cs.SE

TL;DR: APRIL combines prompt optimization and reinforcement learning to boost LLM-driven API synthesis, greatly improving code correctness and scalability for big Python libraries over traditional methods.


<details>
  <summary>Details</summary>
Motivation: Composing new APIs from large libraries is challenging due to the exponential search space and the limitations of existing synthesis methods, which involve costly exploration and manual specifications. LLMs offer potential for code generation but struggle with hallucinations and lack contextual relevance.

Method: APRIL is introduced as a synthesis approach that synergizes LLM-based code generation with two techniques: Automatic Prompt Optimization (APO), which iteratively improves prompts for a fixed (frozen) LLM model, and Reinforcement Learning from Verifiable Rewards (RLVR), which fine-tunes the policy to favor functionally correct outputs.

Result: APRIL is evaluated on 81 real-world APIs from popular scientific Python libraries. Against instruction-tuned but unfine-tuned LLMs with expert guidance, APRIL demonstrates significant improvements in synthesis quality and correctness.

Conclusion: Incorporating APO and RLVR yields a robust and scalable solution for component-based API synthesis across large software libraries, outperforming standard LLM prompting approaches.

Abstract: APIs are central to modern software development, yet composing new APIs from
large libraries is difficult due to the exponential search space; traditional
component-based synthesis relies on costly exploration and hand-crafted
specifications. While large language models (LLMs) can generate implementations
from natural language, hallucinations and limited access to up-to-date
contextual information often yield incorrect code. In this paper, we present
APRIL, an approach that combines LLM-based synthesis with Automatic Prompt
Optimization (APO) and Reinforcement Learning from Verifiable Rewards (RLVR):
APO iteratively refines prompts for a frozen model, while RLVR fine-tunes the
policy toward functional correctness, producing an efficient synthesis
pipeline. Evaluated on 81 real-world APIs from widely used scientific Python
libraries and benchmarked against instruction-tuned but unfine-tuned LLMs
guided by expert prompts, APRIL achieves substantial improvements. These
results indicate that integrating APO and RLVR provides a robust, scalable path
for component-based API synthesis in large libraries.

</details>


### [2] [Towards Repository-Level Program Verification with Large Language Models](https://arxiv.org/abs/2509.25197)
*Si Cheng Zhong,Xujie Si*

Main category: cs.SE

TL;DR: The paper presents RVBench, the first repository-level verification benchmark, and RagVerus, a novel framework combining retrieval and context-aware prompting, which significantly improves the scalability and effectiveness of automated formal verification on large, real-world codebases.


<details>
  <summary>Details</summary>
Motivation: Scaling automated formal verification to real-world software projects is challenging due to cross-module dependencies and global contexts. Existing LLM-based approaches focus mostly on isolated, function-level tasks, leaving repository-level verification unexplored.

Method: The authors introduce two main contributions: (1) RVBench, a new benchmark specifically created to evaluate repository-level formal verification using four complex Verus projects; and (2) RagVerus, a context-aware retrieval-augmented generation framework to automate proof synthesis across multiple modules in software repositories.

Result: RagVerus significantly outperforms baseline models, tripling proof pass rates on current benchmarks within a constrained inference budget. It achieves a 27% relative improvement on the newly proposed RVBench benchmark, establishing itself as both scalable and sample-efficient.

Conclusion: The study demonstrates that integrating retrieval-augmented generation and context-aware prompting via RagVerus effectively addresses previously overlooked repository-level verification challenges, marking a step forward in scalable automated formal verification.

Abstract: Recent advancements in large language models (LLMs) suggest great promises in
code and proof generations. However, scaling automated formal verification to
real-world projects requires resolving cross-module dependencies and global
contexts, which are crucial challenges overlooked by existing LLM-based methods
with a special focus on targeting isolated, function-level verification tasks.
To systematically explore and address the significant challenges of verifying
entire software repositories, we introduce RVBench, the first verification
benchmark explicitly designed for repository-level evaluation, constructed from
four diverse and complex open-source Verus projects.
  We further introduce RagVerus, an extensible framework that synergizes
retrieval-augmented generation with context-aware prompting to automate proof
synthesis for multi-module repositories. RagVerus triples proof pass rates on
existing benchmarks under constrained model inference budgets, and achieves a
27% relative improvement on the more challenging RVBench benchmark,
demonstrating a scalable and sample-efficient verification solution.

</details>


### [3] [BuildBench: Benchmarking LLM Agents on Compiling Real-World Open-Source Software](https://arxiv.org/abs/2509.25248)
*Zehua Zhang,Ati Priya Bajaj,Divij Handa,Siyu Liu,Arvind S Raj,Hongkai Chen,Hulin Wang,Yibo Liu,Zion Leonahenahe Basque,Souradip Nath,Vishal Juneja,Nikhil Chapre,Yan Shoshitaishvili,Adam Doupé,Chitta Baral,Ruoyu Wang*

Main category: cs.SE

TL;DR: The authors present BUILD-BENCH, a more realistic OSS compilation benchmark, and OSS-BUILD-AGENT, a powerful LLM agent that excels at compiling diverse OSS projects. The research pushes the field forward by enhancing evaluation rigor and providing actionable analysis for future developments.


<details>
  <summary>Details</summary>
Motivation: Automatically compiling OSS is labor-intensive and complex, with existing methods unable to adapt to projects requiring custom setups or configurations. Recent LLM-driven approaches do not fully capture real-world challenges due to selective benchmarking.

Method: Introduce BUILD-BENCH, a new benchmark with more diverse and realistic OSS projects. Propose OSS-BUILD-AGENT, a baseline LLM-based agent with improved build instruction retrieval, and offer analytical insights regarding compilation method choices.

Result: OSS-BUILD-AGENT achieves state-of-the-art performance on BUILD-BENCH, demonstrating adaptability to heterogeneous OSS characteristics. Detailed design analysis clarifies what impacts compilation success.

Conclusion: BUILD-BENCH provides a more challenging and accurate benchmark for OSS compilation, and the proposed agent sets a strong baseline. This work will drive advances in software development and security applications.

Abstract: Automatically compiling open-source software (OSS) projects is a vital,
labor-intensive, and complex task, which makes it a good challenge for LLM
Agents. Existing methods rely on manually curated rules and workflows, which
cannot adapt to OSS that requires customized configuration or environment
setup. Recent attempts using Large Language Models (LLMs) used selective
evaluation on a subset of highly rated OSS, a practice that underestimates the
realistic challenges of OSS compilation. In practice, compilation instructions
are often absent, dependencies are undocumented, and successful builds may even
require patching source files or modifying build scripts. We propose a more
challenging and realistic benchmark, BUILD-BENCH, comprising OSS that are more
diverse in quality, scale, and characteristics. Furthermore, we propose a
strong baseline LLM-based agent, OSS-BUILD-AGENT, an effective system with
enhanced build instruction retrieval module that achieves state-of-the-art
performance on BUILD-BENCH and is adaptable to heterogeneous OSS
characteristics. We also provide detailed analysis regarding different
compilation method design choices and their influence to the whole task,
offering insights to guide future advances. We believe performance on
BUILD-BENCH can faithfully reflect an agent's ability to tackle compilation as
a complex software engineering tasks, and, as such, our benchmark will spur
innovation with a significant impact on downstream applications in the fields
of software development and software security.

</details>


### [4] [Black-box Context-free Grammar Inference for Readable & Natural Grammars](https://arxiv.org/abs/2509.26616)
*Mohammad Rifat Arefin,Shanto Rahman,Christoph Csallner*

Main category: cs.SE

TL;DR: NatGI is a new grammar inference framework that uses large language models and syntactic structure cues to generate accurate, readable, and compact grammars, outperforming existing approaches on both accuracy (F1 score) and interpretability for a wide range of programming languages.


<details>
  <summary>Details</summary>
Motivation: Existing context-free grammar inference tools (like Arvada, TreeVada, Kedavra) cannot scale to large, complex languages and produce grammars that are hard to read and less accurate. There's a need for a framework that is both scalable and yields interpretable, accurate grammars for critical tasks in program analysis, reverse engineering, and security.

Method: NatGI, a new framework, extends TreeVada's parse tree recovery via three innovations: bracket-guided bubble exploration (using syntactic cues), LLM-driven bubble generation and non-terminal labeling (using large language models for meaningful names and merges), and hierarchical delta debugging (HDD) for systematic grammar simplification and removal of unnecessary rules.

Result: NatGI is tested on benchmarks covering both small and large languages (including lua, c, mysql). It achieves a higher average F1 score (0.57, 25 percentage points better than the best baseline), and results in more interpretable grammars with meaningful structure and names. The grammars are more compact and align better with human intuition than existing methods.

Conclusion: NatGI provides a scalable, accurate, and interpretable solution to grammar inference. Its integration of LLM guidance and syntactic cues enables researchers and developers to generate high-quality grammars that are easier to inspect and reason about, outperforming existing tools.

Abstract: Black-box context-free grammar inference is crucial for program analysis,
reverse engineering, and security, yet existing tools such as Arvada, TreeVada,
and Kedavra struggle with scalability, readability, and accuracy on large,
complex languages. We present NatGI, a novel LLM-guided grammar inference
framework that extends TreeVada's parse tree recovery with three key
innovations: bracket-guided bubble exploration, LLM-driven bubble generation
and non-terminal labeling, and hierarchical delta debugging (HDD) for
systematic tree simplification. Bracket-guided exploration leverages syntactic
cues such as parentheses to propose well-structured grammar fragments, while
LLM guidance produces meaningful non-terminal names and selects more promising
merges. Finally, HDD incrementally reduces unnecessary rules, which makes the
grammars both compact and interpretable. In our experiments, we evaluate NatGI
on a comprehensive benchmark suite ranging from small languages to larger ones
such as lua, c, and mysql. Our results show that NatGI consistently outperforms
strong baselines in terms of F1 score. On average, NatGI achieves an F1 score
of 0.57, which is 25pp (percentage points) higher than the best-performing
baseline, TreeVada. In the case of interpretability, our generated grammars
perform significantly better than those produced by existing approaches.
Leveraging LLM-based node renaming and bubble exploration, NatGI produces rules
with meaningful non-terminal names and compact structures that align more
closely with human intuition. As a result, developers and researchers can
achieve higher accuracy while still being able to easily inspect, verify, and
reason about the structure and semantics of the induced grammars.

</details>


### [5] [WARP -- Web-Augmented Real-time Program Repairer: A Real-Time Compilation Error Resolution using LLMs and Web-Augmented Synthesis](https://arxiv.org/abs/2509.25192)
*Anderson de Lima Luiz*

Main category: cs.SE

TL;DR: WARP, a system combining Code-LLMs and real-time web data, surpasses traditional and LLM-only methods in fixing compilation errors, substantially improving developer productivity.


<details>
  <summary>Details</summary>
Motivation: Compilation errors are a major productivity bottleneck for developers, slowing down software development and necessitating smarter tools for faster error resolution.

Method: The authors propose WARP, a system that uses Large Language Models (LLMs) fine-tuned on code and supplements them with dynamic, web-augmented synthesis. WARP monitors developer terminals, detects compilation errors, and provides solutions by combining LLM understanding with real-time retrieval of relevant web resources (forums, documentation, etc.).

Result: Experiments on the CGP benchmark (with C/C++, Python, and Go errors) show WARP achieves a 72.5% correct compilation rate and higher semantic accuracy compared to LLM-only and traditional IDE fixes.

Conclusion: WARP outperforms existing approaches by effectively synthesizing high-accuracy fixes via LLM and web data, demonstrating that integrating up-to-date web information notably improves compilation error resolution. The approach addresses challenges in extracting reliable code remedies from noisy web sources.

Abstract: Compilation errors represent a significant bottleneck in software development
productivity. This paper introduces WARP (Web-Augmented Real-time Program
Repairer), a novel system that leverages Large Language Models (LLMs) and
dynamic web-augmented synthesis for real-time resolution of these errors. WARP
actively monitors developer terminals, intelligently detects compilation
errors, and synergistically combines the understanding of a fine-tuned Code-LLM
with relevant solutions, explanations, and code snippets retrieved from
up-to-date web sources like developer forums and official documentation.
Experimental results on our curated benchmark, CGP (featuring C/C++, Python,
and Go errors), demonstrate WARP achieves a superior fix rate (72.5 % Compiles
correctly) and higher semantic correctness compared to baseline LLM-only
approaches and traditional IDE quick-fixes. Key technical challenges in
achieving high-accuracy synthesis from noisy web data.

</details>


### [6] [Devstral: Fine-tuning Language Models for Coding Agent Applications](https://arxiv.org/abs/2509.25193)
*Abhinav Rastogi,Adam Yang,Albert Q. Jiang,Alexander H. Liu,Alexandre Sablayrolles,Amélie Héliou,Amélie Martin,Anmol Agarwal,Andy Ehrenberg,Andy Lo,Antoine Roux,Arthur Darcet,Arthur Mensch,Baptiste Bout,Baptiste Rozière,Baudouin De Monicault,Chris Bamford,Christian Wallenwein,Christophe Renaudin,Clémence Lanfranchi,Clément Denoix,Corentin Barreau,Darius Dabert Devon Mizelle,Diego de las Casas,Elliot Chane-Sane,Emilien Fugier,Emma Bou Hanna,Gabrielle Berrada,Gauthier Delerce,Gauthier Guinet,Georgii Novikov,Graham Neubig,Guillaume Lample,Guillaume Martin,Himanshu Jaju,Jan Ludziejewski,Jason Rute,Jean-Malo Delignon,JeanHadrien Chabran,Joachim Studnia,Joep Barmentlo,Jonas Amar,Josselin Somerville Roberts,Julien Denize,Karan Saxena,Karmesh Yadav,Kartik Khandelwal,Khyathi Raghavi Chandu,Kush Jain,Lélio Renard Lavaud,Léonard Blier,Lingxiao Zhao,Louis Martin,Lucile Saulnier,Luyu Gao,Marie Pellat,Mathilde Guillaumin,Mathis Felardos,Matthieu Dinot,Maxime Darrin,Maximilian Augustin,Mickaël Seznec,Neha Gupta,Nikhil Raghuraman,Olivier Duchenne,Patricia Wang,Patrick von Platen,Patryk Saffer,Paul Jacob,Paul Wambergue,Paula Kurylowicz,Philomène Chagniot,Pierre Stock,Pravesh Agrawal,Rémi Delacourt,Roman Soletskyi,Romain Sauvestre,Sagar Vaze,Sanchit Gandhi,Sandeep Subramanian,Shashwat Dalal,Siddharth Gandhi,Soham Ghosh,Srijan Mishra,Sumukh Aithal,Szymon Antoniak,Teven Le Scao,Thibaut Lavril,Thibault Schueller,Thomas Foubert,Thomas Robert,Thomas Wang,Timothée Lacroix,Tom Bewley,Valeriia Nemychnikova,Victor Paltz,Virgile Richard,Wen-Ding Li,William Marshall,Xingyao Wang,Xuanyu Zhang,Yihan Wan,Yunhao Tang*

Main category: cs.SE

TL;DR: Devstral-Small is a highly efficient and competitive open-source code agent model, offering fast deployment and strong performance despite being much smaller than leading alternatives.


<details>
  <summary>Details</summary>
Motivation: There is a need for small, efficient models for code agents that deliver strong performance and are easy to deploy, especially in scenarios where large models are impractical.

Method: The authors designed and specialized a 24B parameter open-source model specifically for agentic software development tasks. Performance was benchmarked against larger models.

Result: Devstral-Small, a 24B parameter model, matches or surpasses the performance of models larger than 100B parameters in relevant tasks.

Conclusion: Devstral-Small achieves competitive performance compared to much larger models while being lightweight and easy to deploy.

Abstract: We introduce Devstral-Small, a lightweight open source model for code agents
with the best performance among models below 100B size. In this technical
report, we give an overview of how we design and develop a model and craft
specializations in agentic software development. The resulting model,
Devstral-Small is a small 24B model, fast and easy to serve. Despite its size,
Devstral-Small still attains competitive performance compared to models more
than an order of magnitude larger.

</details>


### [7] [Automated Code Development for PDE Solvers Using Large Language Models](https://arxiv.org/abs/2509.25194)
*Haoyang Wu,Xinxin Zhang,Lailai Zhu*

Main category: cs.SE

TL;DR: LLM-PDEveloper leverages large language models to automate the development of PDE library codebases, showing moderate success and offering guidance to mitigate common errors, thereby advancing LLM applications in computational science.


<details>
  <summary>Details</summary>
Motivation: Existing applications of large language models in software development for PDE libraries mainly focus on automating routine aspects for end users, while there is a growing need to automate more sophisticated code development tasks for secondary developers.

Method: The paper introduces LLM-PDEveloper, a zero-shot, multi-agent LLM-based framework that translates mathematical and algorithmic descriptions directly into source code, enabling end-to-end automation of code generation for PDE libraries.

Result: LLM-PDEveloper is demonstrated in three scenarios: building a new PDE solver, implementing new boundary conditions, and modifying existing solvers. It achieved moderate success rates. The study also analyzed failures due to syntactic and semantic errors, proposing practical solutions and identifying error mechanisms for future improvement.

Conclusion: LLM-PDEveloper can effectively expand PDE libraries by automating code development tasks, despite existing challenges related to syntactic and semantic errors. The insights and solutions provided pave the way for more robust LLM-powered tools in scientific computing.

Abstract: Foundation models -- large language models (LLMs) in particular -- have
become ubiquitous, shaping daily life and driving breakthroughs across science,
engineering, and technology. Harnessing their broad cross-domain knowledge,
text-processing, and reasoning abilities for software development, e.g.,
numerical libraries for solving partial differential equations (PDEs), is
therefore attracting growing interest. Yet existing studies mainly automate
case setup and execution for end users. We introduce LLM-PDEveloper, a
zero-shot, multi-agent LLM framework that automates code development for PDE
libraries, specifically targeting secondary developers. By translating
mathematical and algorithmic descriptions directly into source code,
LLM-PDEveloper generates new solvers/modules and adapts existing ones. This
end-to-end math-to-code approach enables a self-augmenting pipeline that
continuously expands the codebase of a library, extends its capacities, and
broadens its scope. We demonstrate LLM-PDEveloper on three tasks: 1) build a
solver for a new PDE, 2) implement new BCs for a given PDE, and 3) modify an
existing solver to incorporate additional terms, achieving moderate success
rates. Failures due to syntactic errors made by LLMs are analyzed and we
propose effective fixes. We also identify the mechanisms underlying certain
semantic errors, guiding future research.

</details>


### [8] [Understanding Practitioners Perspectives on Monitoring Machine Learning Systems](https://arxiv.org/abs/2509.25195)
*Hira Naveed,John Grundy,Chetan Arora,Hourieh Khalajzadeh,Omar Haggag*

Main category: cs.SE

TL;DR: Monitoring ML systems in production is essential but difficult. Practitioners struggle with technical challenges, complexity, and alert fatigue. They want easier, more automated monitoring tools that help address declining performance, latency, security, and fairness concerns.


<details>
  <summary>Details</summary>
Motivation: Machine learning systems in production can behave unpredictably due to their non-deterministic nature, potentially causing serious issues and damages for organizations. Effective monitoring is necessary to detect and mitigate unwanted behavior early.

Method: The authors conducted a global survey of 91 ML practitioners to gather both qualitative and quantitative insights about current monitoring practices, challenges, and improvement needs for ML systems in production.

Result: The study found that practitioners commonly encounter runtime problems such as declining model performance, excessive latency, and security breaches. Although automated monitoring is preferred, manual checks are still widespread due to integration difficulties and tool complexity. Setting up monitoring and alert systems is especially challenging, leading to extra workload and alert fatigue for practitioners. Key improvements desired include automated monitor deployment, better tools for fairness and performance monitoring, and actionable recommendations for runtime issues.

Conclusion: Practitioners face notable challenges in monitoring ML systems, including integration difficulty, high workload, and insufficient automation. There is a strong demand for user-friendly, automated, and actionable monitoring tools that address performance and fairness while reducing operational burdens.

Abstract: Given the inherent non-deterministic nature of machine learning (ML) systems,
their behavior in production environments can lead to unforeseen and
potentially dangerous outcomes. For a timely detection of unwanted behavior and
to prevent organizations from financial and reputational damage, monitoring
these systems is essential. This paper explores the strategies, challenges, and
improvement opportunities for monitoring ML systems from the practitioners
perspective. We conducted a global survey of 91 ML practitioners to collect
diverse insights into current monitoring practices for ML systems. We aim to
complement existing research through our qualitative and quantitative analyses,
focusing on prevalent runtime issues, industrial monitoring and mitigation
practices, key challenges, and desired enhancements in future monitoring tools.
Our findings reveal that practitioners frequently struggle with runtime issues
related to declining model performance, exceeding latency, and security
violations. While most prefer automated monitoring for its increased
efficiency, many still rely on manual approaches due to the complexity or lack
of appropriate automation solutions. Practitioners report that the initial
setup and configuration of monitoring tools is often complicated and
challenging, particularly when integrating with ML systems and setting alert
thresholds. Moreover, practitioners find that monitoring adds extra workload,
strains resources, and causes alert fatigue. The desired improvements from the
practitioners perspective are: automated generation and deployment of monitors,
improved support for performance and fairness monitoring, and recommendations
for resolving runtime issues. These insights offer valuable guidance for the
future development of ML monitoring tools that are better aligned with
practitioners needs.

</details>


### [9] [CircInspect: Integrating Visual Circuit Analysis, Abstraction, and Real-Time Development in Quantum Debugging](https://arxiv.org/abs/2509.25199)
*Mushahid Khan,Prashant J. Nair,Olivia Di Matteo*

Main category: cs.SE

TL;DR: CircInspect is a new Python debugging tool for quantum programs. It brings breakpoints, real-time monitoring, and visualization to PennyLane-based code, making it easier to analyze, debug, and understand quantum software, addressing challenges unique to quantum computing.


<details>
  <summary>Details</summary>
Motivation: Quantum software development poses unique debugging challenges due to the probabilistic nature and hardware-specific issues not found in classical computing. Existing software engineering tools do not directly address these quantum-specific complexities.

Method: The authors introduce CircInspect, an interactive Python-based tool for debugging quantum programs (specifically those using PennyLane). It provides breakpoints, real-time feedback, circuit visualization, output monitoring, and information abstraction.

Result: CircInspect enables users to analyze quantum circuit components in isolation, visualize changes in structure, track program outputs, and better understand complex quantum software behavior.

Conclusion: CircInspect bridges the gap in quantum program debugging, offering essential features to assist developers in comprehending and resolving issues unique to quantum computing.

Abstract: Software bugs typically result from errors in specifications or code
translation. While classical software engineering has evolved with various
tools and methodologies to tackle such bugs, the emergence of quantum computing
presents unique challenges. Quantum software development introduces
complexities due to the probabilistic nature of quantum computing, distinct
algorithmic primitives, and potential hardware noise. In this paper, we
introduce CircInspect, an interactive tool tailored for debugging quantum
programs in Python and PennyLane. By leveraging breakpoints and real-time
software development features, \toolname~empowers users to analyze isolated
quantum circuit components, monitor program output, visualize structural
changes, and abstract information to enhance comprehension.

</details>


### [10] [Generating High-Quality Datasets for Code Editing via Open-Source Language Models](https://arxiv.org/abs/2509.25203)
*Zekai Zhang,Mingwei Liu,Zhenxi Chen,Linxi Liang,Yuxuan Chen,Guangsheng Ou,Yanlin Wang,Dan Li,Xin Peng,Zibin Zheng*

Main category: cs.SE

TL;DR: CanItEdit is an open-source pipeline that creates high-quality, diverse, and realistic code-editing data using multiple LLMs. The resulting OCEDataFT dataset significantly boosts model performance and almost matches closed-source systems like GPT-4 without proprietary resources or manual annotation.


<details>
  <summary>Details</summary>
Motivation: Existing commit-based datasets for code editing are noisy, lack diversity, and do not reflect real-world edit instruction styles, limiting model effectiveness.

Method: The authors introduce CanItEdit, an open-source pipeline that uses multiple LLMs to generate realistic code-edit triplets with both concise and detailed instructions. The pipeline includes filtering techniques to ensure high data quality and diversity. This process produces OCEDataFT, a curated dataset of 20,000 samples.

Result: Fine-tuning advanced base models on OCEDataFT delivers significant performance improvements on the CanItEdit benchmark, with relative pass@1 gains between 4.50% and 20.79%. The fine-tuned models nearly match closed-source system performance, trailing GPT-4 by only 3.54%, and do so without proprietary data or manual annotation.

Conclusion: The paper demonstrates that a carefully constructed, openly available dataset combined with multi-LLM synthesis and filtering can substantially improve code-editing model performance, narrowing the gap to leading proprietary models while maintaining transparency and reproducibility.

Abstract: Code editing plays a vital role in software engineering, requiring developers
to adjust existing code according to natural language instructions while
keeping functionality intact and avoiding unnecessary modifications. However,
commit-based datasets commonly used for this task are often noisy, lack
diversity, and fail to reflect the style of real-world edit instructions. To
address this, we introduce CanItEdit, an open-source pipeline that leverages
multiple LLMs to synthesize realistic code-edit triplets. The pipeline produces
both concise "lazy" instructions and more detailed "descriptive" ones, and
applies filtering based on diffs and topics to guarantee data quality and
variety. Using this process, we construct OCEDataFT, a curated dataset of 20K
samples. Fine-tuning three advanced base models on OCEDataFT leads to
significant performance boosts on the CanItEdit benchmark, with relative pass@1
improvements ranging from 4.50% to 20.79%. Notably, the resulting models
achieve performance close to closed-source systems, narrowing the gap to GPT-4
to just 3.54%, without relying on proprietary resources or manual annotation.

</details>


### [11] [A Benchmark for Localizing Code and Non-Code Issues in Software Projects](https://arxiv.org/abs/2509.25242)
*Zejun Zhang,Jian Wang,Qingyun Yang,Yifan Pan,Yi Tang,Yi Li,Zhenchang Xing,Tian Zhang,Xuandong Li,Guoan Zhang*

Main category: cs.SE

TL;DR: MULocBench is a new dataset for issue localization that exposes weaknesses in current methods, showing they struggle to generalize to real-world scenarios. The dataset is available for research use.


<details>
  <summary>Details</summary>
Motivation: Existing issue localization benchmarks focus mainly on pull-request issues and code files, neglecting other types of evidence and non-code files, resulting in unrealistic evaluations for software maintenance tasks.

Method: The authors introduce MULocBench, a comprehensive dataset consisting of 1,100 issues from 46 popular GitHub Python projects, covering diverse issue types, root causes, location scopes, and file types. They use MULocBench to evaluate state-of-the-art localization methods and five LLM-based prompting strategies.

Result: Current techniques for project localization perform poorly on MULocBench, with performance metrics staying below 40% (Acc@5, F1), even at the file level. This highlights the difficulty in generalizing existing methods to realistic, multifaceted issue resolution scenarios.

Conclusion: MULocBench provides a more holistic benchmark for project localization, exposing significant limitations of current approaches and facilitating future research.

Abstract: Accurate project localization (e.g., files and functions) for issue
resolution is a critical first step in software maintenance. However, existing
benchmarks for issue localization, such as SWE-Bench and LocBench, are limited.
They focus predominantly on pull-request issues and code locations, ignoring
other evidence and non-code files such as commits, comments, configurations,
and documentation. To address this gap, we introduce MULocBench, a
comprehensive dataset of 1,100 issues from 46 popular GitHub Python projects.
Comparing with existing benchmarks, MULocBench offers greater diversity in
issue types, root causes, location scopes, and file types, providing a more
realistic testbed for evaluation. Using this benchmark, we assess the
performance of state-of-the-art localization methods and five LLM-based
prompting strategies. Our results reveal significant limitations in current
techniques: even at the file level, performance metrics (Acc@5, F1) remain
below 40%. This underscores the challenge of generalizing to realistic,
multi-faceted issue resolution. To enable future research on project
localization for issue resolution, we publicly release MULocBench at
https://huggingface.co/datasets/somethingone/MULocBench.

</details>


### [12] [Reinforcement Learning-Guided Chain-of-Draft for Token-Efficient Code Generation](https://arxiv.org/abs/2509.25243)
*Xunzhu Tang,Iyiola Emmanuel Olatunji,Tiezhu Sun,Jacques Klein,Tegawende F. Bissyande*

Main category: cs.SE

TL;DR: Multicod uses reinforcement learning to select the best solution from multiple LLM code generation drafts, enhancing quality, efficiency, and cost-effectiveness compared to current methods.


<details>
  <summary>Details</summary>
Motivation: Existing large language models (LLMs) show fluency in code generation but struggle with tasks that require structured reasoning and correctness. Chain-of-Thought (CoT) and Chain-of-Draft (CoD) prompting methods address this but have trade-offs in verbosity and inconsistent quality, and optimal solution selection remains challenging.

Method: This paper proposes 'multicod', a reinforcement learning framework. It learns to select the best candidate solution from those generated by CoD prompting. The approach uses strategy-guided prompting for diverse reasoning styles and models the solution selection task as a contextual bandit problem, optimizing interpretable features with a reward function that balances correctness, efficiency, and clarity.

Result: Experiments on MBPP, BigCodeBench, SWE-bench Verified, and Defects4J benchmarks show that multicod outperforms or matches the performance of standard prompting, CoT, and CoD baselines. The framework improves cost and token efficiency by charging only for the selected output, reducing user billing by over 50%, and enhancing response quality.

Conclusion: Multicod provides a scalable and sustainable solution for real-world LLM code generation. It delivers higher efficiency and quality, with substantial cost reductions compared to existing approaches.

Abstract: LLMs demonstrate surface-level fluency in code generation but struggle with
structured reasoning tasks requiring correctness and semantic alignment. While
Chain-of-Thought (CoT) prompting enhances reasoning through intermediate steps,
it suffers from verbosity and inefficiency. Chain-of-Draft (CoD) prompting
offers more concise reasoning, but the stochastic nature of LLMs produces
varying solution quality, making optimal selection challenging. We propose
\multicod, a reinforcement learning framework that learns to select the most
promising candidate from CoD-generated solutions. Our approach uses
strategy-guided prompting to encourage diverse reasoning styles and models
solution selection as a contextual bandit problem. The framework optimizes
interpretable features including code complexity, reasoning structure, and
strategic metadata through a reward function balancing correctness, efficiency,
and clarity. Experiments on MBPP, BigCodeBench, SWE-bench Verified, and
Defects4J show \multicod~outperforms and in some cases, on par with standard
prompting, CoT, and CoD baselines while achieving cost and token efficiency
from the user's perspective through a multi-candidate design that charges only
for the selected output, reducing user billing by over 50\% and improving LLM
response quality, making \multicod~more sustainable and scalable for real-world
deployment. Our code is available: https://anonymous.4open.science/r/MultiCoD.

</details>


### [13] [Protocode: Prototype-Driven Interpretability for Code Generation in LLMs](https://arxiv.org/abs/2509.25247)
*Krishna Vamshi Bodla,Haizhao Yang*

Main category: cs.SE

TL;DR: Carefully selecting high-quality in-context examples for LLM-based code generation leads to better, more interpretable outputs and improved pass@10 results, while poor selections reduce performance. AST-based analysis helps in understanding this influence.


<details>
  <summary>Details</summary>
Motivation: With growing reliance on LLMs for code generation, there is an increased risk of suboptimal and insecure code due to potentially unsuitable training examples. Improving both performance and interpretability of code generated by LLMs is an urgent need.

Method: The authors propose an automatic sampling strategy for In-Context Learning (ICL) demonstrations. They use AST-based analysis on outputs from the MBPP test set to identify code regions most influenced by the chosen demonstrations and evaluate the impact of demonstration quality on LLM performance.

Result: High-quality ICL demonstrations improve both interpretability and performance (pass@10 metric) of LLM-generated code. Poorly chosen demonstrations negatively affect model performance, underscoring the importance of careful selection.

Conclusion: Efficient sampling and selection of ICL demonstrations are critical for maximizing the performance and interpretability of LLMs in code generation tasks. The study demonstrates measurable gains from this strategy, but also highlights risks of careless demonstration choice.

Abstract: Since the introduction of Large Language Models (LLMs), they have been widely
adopted for various tasks such as text summarization, question answering,
speech-to-text translation, and more. In recent times, the use of LLMs for code
generation has gained significant attention, with tools such as Cursor and
Windsurf demonstrating the ability to analyze massive code repositories and
recommend relevant changes. Big tech companies have also acknowledged the
growing reliance on LLMs for code generation within their codebases. Although
these advances significantly improve developer productivity, increasing
reliance on automated code generation can proportionally increase the risk of
suboptimal solutions and insecure code. Our work focuses on automatically
sampling In-Context Learning (ICL) demonstrations which can improve model
performance and enhance the interpretability of the generated code. Using
AST-based analysis on outputs from the MBPP test set, we identify regions of
code most influenced by the chosen demonstrations. In our experiments, we show
that high-quality ICL demonstrations not only make outputs easier to interpret
but also yield a positive performance improvement on the pass@10 metric.
Conversely, poorly chosen ICL demonstrations affected the LLM performance on
the pass@10 metric negatively compared to the base model. Overall, our approach
highlights the importance of efficient sampling strategies for ICL, which can
affect the performance of the model on any given task.

</details>


### [14] [RANGER -- Repository-Level Agent for Graph-Enhanced Retrieval](https://arxiv.org/abs/2509.25257)
*Pratik Shah,Rajat Ghosh,Aryan Singhal,Debojyoti Dutta*

Main category: cs.SE

TL;DR: RANGER is a unified code retrieval agent that handles both entity-specific and natural language queries across a codebase, using a knowledge graph. It beats previous state-of-the-art methods on diverse automated software engineering benchmarks.


<details>
  <summary>Details</summary>
Motivation: Current automated software engineering tasks need code retrieval systems that can handle both specific code entity queries and general natural language queries. Existing methods often focus mainly on code-entity queries, leaving a gap for handling more flexible, repository-wide tasks.

Method: RANGER constructs a comprehensive knowledge graph representing an entire code repository, with hierarchical and cross-file dependencies, and augments nodes with textual descriptions and embeddings. RANGER utilizes a dual-stage retrieval pipeline: Cypher queries for entity-based searches, and MCTS-guided graph exploration for natural language queries.

Result: RANGER is evaluated on four benchmarks (CodeSearchNet, RepoQA, RepoBench, CrossCodeEval), outperforming state-of-the-art baseline models in tasks like code search, QA, dependency retrieval, and repository-level code completion. Pairing RANGER with BM25 achieves the highest exact match rate in code completion relative to other retrieval-augmented generation methods.

Conclusion: RANGER effectively bridges the gap between code entity and natural language queries for repository-level code retrieval, outperforming strong baseline approaches and establishing a more general solution for automated software engineering tasks.

Abstract: General-purpose automated software engineering (ASE) includes tasks such as
code completion, retrieval, repair, QA, and summarization. These tasks require
a code retrieval system that can handle specific queries about code entities,
or code entity queries (for example, locating a specific class or retrieving
the dependencies of a function), as well as general queries without explicit
code entities, or natural language queries (for example, describing a task and
retrieving the corresponding code). We present RANGER, a repository-level code
retrieval agent designed to address both query types, filling a gap in recent
works that have focused primarily on code-entity queries. We first present a
tool that constructs a comprehensive knowledge graph of the entire repository,
capturing hierarchical and cross-file dependencies down to the variable level,
and augments graph nodes with textual descriptions and embeddings to bridge the
gap between code and natural language. RANGER then operates on this graph
through a dual-stage retrieval pipeline. Entity-based queries are answered
through fast Cypher lookups, while natural language queries are handled by
MCTS-guided graph exploration. We evaluate RANGER across four diverse
benchmarks that represent core ASE tasks including code search, question
answering, cross-file dependency retrieval, and repository-level code
completion. On CodeSearchNet and RepoQA it outperforms retrieval baselines that
use embeddings from strong models such as Qwen3-8B. On RepoBench, it achieves
superior cross-file dependency retrieval over baselines, and on CrossCodeEval,
pairing RANGER with BM25 delivers the highest exact match rate in code
completion compared to other RAG methods.

</details>


### [15] [Automatically Generating Web Applications from Requirements Via Multi-Agent Test-Driven Development](https://arxiv.org/abs/2509.25297)
*Yuxuan Wan,Tingshuo Liang,Jiakai Xu,Jingyu Xiao,Yintong Huo,Michael R. Lyu*

Main category: cs.SE

TL;DR: TDDev is a novel AI framework that uses test-driven development and language models to automatically build and refine complete, reliable full-stack web apps from a text or image description, improving accuracy and automation over existing tools.


<details>
  <summary>Details</summary>
Motivation: Developing full-stack web applications is a complex, time-consuming process requiring expertise in multiple technologies. While MLLMs can generate front-end web pages from images or descriptions, they cannot yet create fully functional, end-to-end applications automatically.

Method: The authors propose TDDev, a novel framework that combines test-driven development (TDD) with a large language model agent. TDDev takes natural language or visual input, automatically generates test cases, creates front-end and back-end code, simulates user behaviors, and iteratively refines code until all tests pass.

Result: TDDev outperforms existing systems by 14.4% in overall accuracy on diverse application tasks. It successfully addresses challenges such as vague requirements, file interdependencies, and demands for functional and visual correctness, producing reliable full-stack applications autonomously.

Conclusion: TDDev represents the first end-to-end, TDD-enabled LLM framework for automated full-stack web development. It advances the state of the art by delivering higher quality, more reliable, fully functional web applications without human intervention.

Abstract: Developing full-stack web applications is complex and time-intensive,
demanding proficiency across diverse technologies and frameworks. Although
recent advances in multimodal large language models (MLLMs) enable automated
webpage generation from visual inputs, current solutions remain limited to
front-end tasks and fail to deliver fully functional applications. In this
work, we introduce TDDev, the first test-driven development (TDD)-enabled
LLM-agent framework for end-to-end full-stack web application generation. Given
a natural language description or design image, TDDev automatically derives
executable test cases, generates front-end and back-end code, simulates user
interactions, and iteratively refines the implementation until all requirements
are satisfied. Our framework addresses key challenges in full-stack automation,
including underspecified user requirements, complex interdependencies among
multiple files, and the need for both functional correctness and visual
fidelity. Through extensive experiments on diverse application scenarios, TDDev
achieves a 14.4% improvement on overall accuracy compared to state-of-the-art
baselines, demonstrating its effectiveness in producing reliable, high-quality
web applications without requiring manual intervention.

</details>


### [16] [Detecting and Fixing API Misuses of Data Science Libraries Using Large Language Models](https://arxiv.org/abs/2509.25378)
*Akalanka Galappaththi,Francisco Ribeiro,Sarah Nadi*

Main category: cs.SE

TL;DR: This paper presents DSCHECKER, an LLM-powered tool for detecting and fixing API misuses in data science libraries like pandas and scikit-learn. By combining API directives and data details, DSCHECKER significantly improves misuse detection and correction rates. In real-world settings, its agent variant shows practical effectiveness, highlighting the potential of LLMs in this field.


<details>
  <summary>Details</summary>
Motivation: Detecting and fixing API misuses in data science libraries is challenging due to their data-centric nature, and traditional methods may be insufficient. Libraries like scikit-learn and pandas are widely used, so misuse can have significant impact.

Method: DSCHECKER is introduced as an LLM-based approach that leverages both API directives and data information to detect and fix API misuse. The researchers tested prompts using three LLMs and conducted experiments on misuses from five data science libraries. Furthermore, they developed the Dschecker agent, which uses adaptive function calling to dynamically access information, mimicking practical scenarios.

Result: Incorporating API directives and data-specific information leads to improved detection and fixing performance. The best model achieved an F1-score of 61.18% in detection and fixed 51.28% of misuses. The Dschecker agent, simulating real-world conditions, achieved an F1-score of 48.65% and fixed 39.47% of misuses.

Conclusion: LLM-based approaches, particularly when integrating directive and data information, show strong promise for detecting and fixing API misuse in data science libraries, and can be adapted to real-world environments for practical utility.

Abstract: Data science libraries, such as scikit-learn and pandas, specialize in
processing and manipulating data. The data-centric nature of these libraries
makes the detection of API misuse in them more challenging. This paper
introduces DSCHECKER, an LLM-based approach designed for detecting and fixing
API misuses of data science libraries. We identify two key pieces of
information, API directives and data information, that may be beneficial for
API misuse detection and fixing. Using three LLMs and misuses from five data
science libraries, we experiment with various prompts. We find that
incorporating API directives and data-specific details enhances Dschecker's
ability to detect and fix API misuses, with the best-performing model achieving
a detection F1-score of 61.18 percent and fixing 51.28 percent of the misuses.
Building on these results, we implement Dschecker agent which includes an
adaptive function calling mechanism to access information on demand, simulating
a real-world setting where information about the misuse is unknown in advance.
We find that Dschecker agent achieves 48.65 percent detection F1-score and
fixes 39.47 percent of the misuses, demonstrating the promise of LLM-based API
misuse detection and fixing in real-world scenarios.

</details>


### [17] [A Cartography of Open Collaboration in Open Source AI: Mapping Practices, Motivations, and Governance in 14 Open Large Language Model Projects](https://arxiv.org/abs/2509.25397)
*Johan Linåker,Cailean Osborne,Jennifer Ding,Ben Burtenshaw*

Main category: cs.SE

TL;DR: This paper explores how developers collaborate on open LLM projects via interviews, revealing varied organizational models and motivations, and provides actionable recommendations for supporting openness in AI development.


<details>
  <summary>Details</summary>
Motivation: The motivation is to understand the methods of collaboration in developing open large language models (LLMs), which have not been comprehensively studied. This would help identify ways to foster the ecosystem of open AI research and innovation.

Method: The authors conducted an exploratory analysis using semi-structured interviews with developers from 14 open LLM projects across various regions and organizational types.

Result: They found that collaboration spans not just the models themselves but also datasets, benchmarks, frameworks, forums, and compute partnerships. Developer motivations are diverse, including democratizing AI, promoting open science, building regional ecosystems, and expanding language representation. Five distinct organizational models of open LLM projects were identified, differing in centralization and community engagement strategies.

Conclusion: The paper recommends practical strategies for stakeholders to further support and develop the global community working towards a more open AI ecosystem.

Abstract: The proliferation of open large language models (LLMs) is fostering a vibrant
ecosystem of research and innovation in artificial intelligence (AI). However,
the methods of collaboration used to develop open LLMs both before and after
their public release have not yet been comprehensively studied, limiting our
understanding of how open LLM projects are initiated, organized, and governed
as well as what opportunities there are to foster this ecosystem even further.
We address this gap through an exploratory analysis of open collaboration
throughout the development and reuse lifecycle of open LLMs, drawing on
semi-structured interviews with the developers of 14 open LLMs from grassroots
projects, research institutes, startups, and Big Tech companies in North
America, Europe, Africa, and Asia. We make three key contributions to research
and practice. First, collaboration in open LLM projects extends far beyond the
LLMs themselves, encompassing datasets, benchmarks, open source frameworks,
leaderboards, knowledge sharing and discussion forums, and compute
partnerships, among others. Second, open LLM developers have a variety of
social, economic, and technological motivations, from democratizing AI access
and promoting open science to building regional ecosystems and expanding
language representation. Third, the sampled open LLM projects exhibit five
distinct organizational models, ranging from single company projects to
non-profit-sponsored grassroots projects, which vary in their centralization of
control and community engagement strategies used throughout the open LLM
lifecycle. We conclude with practical recommendations for stakeholders seeking
to support the global community building a more open future for AI.

</details>


### [18] [PIPer: On-Device Environment Setup via Online Reinforcement Learning](https://arxiv.org/abs/2509.25455)
*Alexander Kovrigin,Aleksandra Eliseeva,Konstantin Grotov,Egor Bogomolov,Yaroslav Zharov*

Main category: cs.SE

TL;DR: The paper tackles the challenge of automated environment setup in software engineering. By combining fine-tuning for script generation and reinforcement learning, they boost a small model (Qwen3-8B) to match much larger models, making robust automation accessible and aiding both developers and researchers.


<details>
  <summary>Details</summary>
Motivation: Environment setup is a persistent bottleneck in Software Engineering, complicating the development process and research scalability. Despite advances, even cutting-edge Large Language Models (LLMs) struggle to reliably automate environment configuration.

Method: The authors fine-tune a specialized language model using supervised learning to generate correct Bash scripts for environment setup, and leverage Reinforcement Learning with Verifiable Rewards (RLVR) to further adapt the model to the task.

Result: Their approach empowers the relatively small Qwen3-8B model to match the performance of much larger models like Qwen3-32B and GPT-4o on the EnvBench-Python benchmark.

Conclusion: With their combined method, automated environment setup becomes viable on consumer hardware, thus reducing manual effort for developers and enabling SE researchers to scale benchmarks more easily. Code and models are made publicly available.

Abstract: Environment setup-the process of configuring the system to work with a
specific software project-represents a persistent challenge in Software
Engineering (SE). Automated environment setup methods could assist developers
by providing fully configured environments for arbitrary repositories without
manual effort. This also helps SE researchers to scale execution-based
benchmarks. However, recent studies reveal that even state-of-the-art Large
Language Models (LLMs) achieve limited success in automating this task. To
address this limitation, we tune a specialized model for environment setup. We
combine supervised fine-tuning for generating correct Bash scripts and
Reinforcement Learning with Verifiable Rewards (RLVR) to adapt it to the task
of environment setup. On EnvBench-Python, our method enables Qwen3-8B (a model
runnable on consumer hardware) to perform on par with larger models-Qwen3-32B
and GPT-4o. The training code and model checkpoints are available online:
https://github.com/JetBrains-Research/PIPer.

</details>


### [19] [BloomAPR: A Bloom's Taxonomy-based Framework for Assessing the Capabilities of LLM-Powered APR Solutions](https://arxiv.org/abs/2509.25465)
*Yinghang Ma,Jiho Shin,Leuson Da Silva,Zhen Ming,Jiang,Song Wang,Foutse Khomh,Shin Hwei Tan*

Main category: cs.SE

TL;DR: This paper presents BloomAPR, a dynamic framework to evaluate LLM-powered automatic program repair across different reasoning levels, revealing that while current tools excel at memorized patterns, they lag in real-world and complex repair tasks, demanding improved benchmarks.


<details>
  <summary>Details</summary>
Motivation: Existing APR solutions powered by LLMs are mainly evaluated with static benchmarks, which pose risks of data contamination and fail to represent dynamic, diverse real-world scenarios. There's a need for better frameworks to measure LLM-based APR capabilities.

Method: The paper introduces BloomAPR, a dynamic evaluation framework based on Bloom's Taxonomy to measure LLM-powered APR solution performance across various reasoning levels. Using Defects4J as a case study, it evaluates ChatRepair and CigaR on different LLM bases (GPT-3.5-Turbo, Llama-3.1, and StarCoder-2) under synthetic and real-world bug scenarios.

Result: LLM-powered APRs perform well on recognizing and fixing memorized bug patterns (up to 81.57% on the Remember layer), improve with synthetic bugs (up to 60.66% at the Understand layer), but struggle with minor syntactic changes (43.32% at the Apply layer) and analyzing/solving bugs in real projects (only 13.46% to 41.34% at the Analyze layer).

Conclusion: Current LLM-powered APR tools exhibit basic reasoning skills and memorization, but their performance diminishes in more complex and realistic bug-fixing scenarios. Better evaluation frameworks are needed to trust APR capabilities and evolve benchmarks for LLM-based software engineering.

Abstract: Recent advances in large language models (LLMs) have accelerated the
development of AI-driven automated program repair (APR) solutions. However,
these solutions are typically evaluated using static benchmarks such as
Defects4J and SWE-bench, which suffer from two key limitations: (1) the risk of
data contamination, potentially inflating evaluation results due to overlap
with LLM training data, and (2) limited ability to assess the APR capabilities
in dynamic and diverse contexts. In this paper, we introduced BloomAPR, a novel
dynamic evaluation framework grounded in Bloom's Taxonomy. Our framework offers
a structured approach to assess the cognitive capabilities of LLM-powered APR
solutions across progressively complex reasoning levels. Using Defects4J as a
case study, we evaluated two state-of-the-art LLM-powered APR solutions,
ChatRepair and CigaR, under three different LLMs: GPT-3.5-Turbo, Llama-3.1, and
StarCoder-2. Our findings show that while these solutions exhibit basic
reasoning skills and effectively memorize bug-fixing patterns (fixing up to
81.57% of bugs at the Remember layer), their performance increases with
synthetically generated bugs (up to 60.66% increase at the Understand layer).
However, they perform worse on minor syntactic changes (fixing up to 43.32% at
the Apply layer), and they struggle to repair similar bugs when injected into
real-world projects (solving only 13.46% to 41.34% bugs at the Analyze layer).
These results underscore the urgent need for evolving benchmarks and provide a
foundation for more trustworthy evaluation of LLM-powered software engineering
solutions.

</details>


### [20] [AGNOMIN -- Architecture Agnostic Multi-Label Function Name Prediction](https://arxiv.org/abs/2509.25514)
*Yonatan Gizachew Achamyeleh,Tongtao Zhang,Joshua Hyunki Kim,Gabriel Garcia,Shih-Yuan Yu,Anton Kocheturov,Mohammad Abdullah Al Faruque*

Main category: cs.SE

TL;DR: AGNOMIN is a new architecture-agnostic function name prediction system for stripped binaries, combining multiple graph features and deep learning. It achieves significant improvements over existing methods in precision and recall, generalizes to unseen architectures, and has been validated in security hackathons.


<details>
  <summary>Details</summary>
Motivation: Function name prediction in stripped binaries is essential for software reverse engineering, which facilitates vulnerability analysis and patching. Current methods struggle with architecture-specific issues, data scarcity, and inconsistent naming conventions.

Method: AGNOMIN introduces an architecture-agnostic approach using Feature-Enriched Hierarchical Graphs (FEHGs) that combine Control Flow Graphs, Function Call Graphs, and dynamically learned PCode features. A hierarchical graph neural network processes these graphs. The function name prediction leverages a Renée-inspired decoder with an attention-based head and algorithmic improvements.

Result: Experimentation on 9,000 ELF binaries across three architectures shows AGNOMIN outperforms state-of-the-art methods, achieving up to 27.17% higher precision and 55.86% higher recall. It generalizes well to unseen architectures, with a 5.89% recall improvement over the closest baseline. AGNOMIN was also effective in real-world security hackathons.

Conclusion: AGNOMIN is a robust and scalable solution for function name prediction in stripped binaries, effective across multiple architectures and directly aiding vulnerability analysis and patching.

Abstract: Function name prediction is crucial for understanding stripped binaries in
software reverse engineering, a key step for \textbf{enabling subsequent
vulnerability analysis and patching}. However, existing approaches often
struggle with architecture-specific limitations, data scarcity, and diverse
naming conventions. We present AGNOMIN, a novel architecture-agnostic approach
for multi-label function name prediction in stripped binaries. AGNOMIN builds
Feature-Enriched Hierarchical Graphs (FEHGs), combining Control Flow Graphs,
Function Call Graphs, and dynamically learned \texttt{PCode} features. A
hierarchical graph neural network processes this enriched structure to generate
consistent function representations across architectures, vital for
\textbf{scalable security assessments}. For function name prediction, AGNOMIN
employs a Ren\'ee-inspired decoder, enhanced with an attention-based head layer
and algorithmic improvements.
  We evaluate AGNOMIN on a comprehensive dataset of 9,000 ELF executable
binaries across three architectures, demonstrating its superior performance
compared to state-of-the-art approaches, with improvements of up to 27.17\% in
precision and 55.86\% in recall across the testing dataset. Moreover, AGNOMIN
generalizes well to unseen architectures, achieving 5.89\% higher recall than
the closest baseline. AGNOMIN's practical utility has been validated through
security hackathons, where it successfully aided reverse engineers in analyzing
and patching vulnerable binaries across different architectures.

</details>


### [21] [M&SCheck: Towards a Checklist to Support Software Engineering Newcomers to the Modeling and Simulation Area](https://arxiv.org/abs/2509.25625)
*Luiza Martins de Freitas Cintra,Philipp Zech,Mohamad Kassab,Eliomar Araújo Lima,Sofia Larissa da Costa Paiva,Valdemar Vicente Graciano Neto*

Main category: cs.SE

TL;DR: This paper presents a beginner-friendly checklist to help choose between DEVS, System Dynamics, and Agent-Based Simulation for modeling and simulation tasks in complex systems. Initial evaluation shows the checklist is accurate and well-received by experts.


<details>
  <summary>Details</summary>
Motivation: With the growing complexity of ecosystems like digital twins, smart cities, and Industry 4.0/5.0, there is a pressing need for integrating modeling and simulation (M&S) into software development. Developers, especially newcomers, often struggle to choose the right M&S formalism for their projects.

Method: The authors developed a preliminary checklist aimed at guiding beginners in selecting the appropriate M&S paradigm. This checklist focuses on three main formalisms: DEVS, System Dynamics, and Agent-Based Simulation. Its efficacy was assessed through a pilot study and consultation with an expert.

Result: The checklist's suggestion matched the formalism selected in original studies used for evaluation, demonstrating its usefulness. Additionally, the expert provided positive feedback regarding the checklist.

Conclusion: A checklist was established to help beginners select an M&S formalism. Preliminary results show high alignment with choices made in previous studies and favorable expert feedback, indicating the checklist's promise.

Abstract: The advent of increasingly complex and dynamic ecosystems, such as digital
twins (DT), smart cities and Industry 4.0 and 5.0, has made evident the need to
include modeling and simulation (M&S) in the software development life cycle.
Such disruptive systems include simulation models in their own architecture
(such as DT) or require the use of simulation models to represent the high
degree of movement and the multiplicity of interactions that occur between the
involved systems. However, when software engineers (particularly the newcomers)
need to use M&S in their projects, they often pose themselves an important
question: which formalism should I use? In this direction, the main
contribution of this paper is the establishment of a preliminary checklist with
questions to assist beginners in M&S in choosing the most appropriate paradigm
to solve their problems. The checklist is based on three main formalisms: DEVS,
System Dynamics and Agent-Based Simulation. A pilot study was carried out and
an expert was consulted. The preliminary results show (i) conformance between
the suggestion given by the checklist and the formalism selected in the
original studies used as input for evaluating the checklist, and (ii) a
positive feedback from the expert.

</details>


### [22] [Explainable Fault Localization for Programming Assignments via LLM-Guided Annotation](https://arxiv.org/abs/2509.25676)
*Fang Liu,Tianze Wang,Li Zhang,Zheyu Yang,Jing Jiang,Zian Sun*

Main category: cs.SE

TL;DR: FLAME is a novel LLM-powered, fine-grained fault localization system for programming assignments, delivering more localized, explanatory, and accurate results than current methods, as shown by substantial improvements across educational and general code datasets.


<details>
  <summary>Details</summary>
Motivation: The motivation comes from the need to provide fine-grained and explanatory guidance to students working on programming assignments. Existing automated fault localization techniques are either too coarse in granularity or lack actionable, explanatory feedback, making them less effective in educational contexts.

Method: The proposed method, FLAME, uses LLM-guided annotation and model ensemble to achieve fine-grained and explainable fault localization. Instead of predicting line numbers, FLAME prompts LLMs to annotate faulty code lines with detailed explanations. The method further aggregates results using a weighted multi-model voting strategy to enhance reliability.

Result: FLAME significantly improves the granularity and explanatory nature of fault localization. It outperforms state-of-the-art baselines by localizing 207 more faults at top-1 in programming assignments. It also generalizes well to general-purpose codebases, surpassing all baselines on the Defects4J benchmark.

Conclusion: FLAME provides more accurate and helpful fault localization for programming assignments and general software code, offering detailed explanations and surpassing existing approaches both in educational and broader contexts.

Abstract: Providing timely and personalized guidance for students' programming
assignments, offers significant practical value for helping students complete
assignments and enhance their learning. In recent years, various automated
Fault Localization (FL) techniques have demonstrated promising results in
identifying errors in programs. However, existing FL techniques face challenges
when applied to educational contexts. Most approaches operate at the method
level without explanatory feedback, resulting in granularity too coarse for
students who need actionable insights to identify and fix their errors. While
some approaches attempt line-level fault localization, they often depend on
predicting line numbers directly in numerical form, which is ill-suited to
LLMs. To address these challenges, we propose FLAME, a fine-grained,
explainable Fault Localization method tailored for programming assignments via
LLM-guided Annotation and Model Ensemble. FLAME leverages rich contextual
information specific to programming assignments to guide LLMs in identifying
faulty code lines. Instead of directly predicting line numbers, we prompt the
LLM to annotate faulty code lines with detailed explanations, enhancing both
localization accuracy and educational value. To further improve reliability, we
introduce a weighted multi-model voting strategy that aggregates results from
multiple LLMs to determine the suspiciousness of each code line. Extensive
experimental results demonstrate that FLAME outperforms state-of-the-art fault
localization baselines on programming assignments, successfully localizing 207
more faults at top-1 over the best-performing baseline. Beyond educational
contexts, FLAME also generalizes effectively to general-purpose software
codebases, outperforming all baselines on the Defects4J benchmark.

</details>


### [23] [DeepCodeSeek: Real-Time API Retrieval for Context-Aware Code Generation](https://arxiv.org/abs/2509.25716)
*Esakkivel Esakkiraja,Denis Akhiyarov,Aditya Shanmugham,Chitra Ganapathy*

Main category: cs.SE

TL;DR: The paper presents a new dataset and a compact reranker pipeline for high-quality API prediction and code generation, achieving strong accuracy and efficiency over larger models, addressing key issues in enterprise code applications.


<details>
  <summary>Details</summary>
Motivation: Existing search techniques for code applications, particularly standard RAG query-document approaches, struggle with high-quality code generation, API prediction, and suffer from API leaks in benchmark datasets.

Method: The authors introduce a new dataset sourced from real-world ServiceNow Script Includes, designed to reflect challenges in API usage. They build a retrieval and ranking system that includes expanding code and index for API prediction, and develop a post-training pipeline for a compact 0.6B reranker model using synthetic data generation, supervised fine-tuning, and reinforcement learning.

Result: The proposed technique achieves 87.86% top-40 retrieval accuracy for APIs, and the compact 0.6B reranker not only outperforms a much larger 8B baseline model but also reduces latency by 2.5x.

Conclusion: Their approach substantially improves code generation by enabling accurate API prediction and efficient retrieval with a small yet effective model, solving real-world problems like unclear API intent and latency in enterprise settings.

Abstract: Current search techniques are limited to standard RAG query-document
applications. In this paper, we propose a novel technique to expand the code
and index for predicting the required APIs, directly enabling high-quality,
end-to-end code generation for auto-completion and agentic AI applications. We
address the problem of API leaks in current code-to-code benchmark datasets by
introducing a new dataset built from real-world ServiceNow Script Includes that
capture the challenge of unclear API usage intent in the code. Our evaluation
metrics show that this method achieves 87.86% top-40 retrieval accuracy,
allowing the critical context with APIs needed for successful downstream code
generation. To enable real-time predictions, we develop a comprehensive
post-training pipeline that optimizes a compact 0.6B reranker through synthetic
dataset generation, supervised fine-tuning, and reinforcement learning. This
approach enables our compact reranker to outperform a much larger 8B model
while maintaining 2.5x reduced latency, effectively addressing the nuances of
enterprise-specific code without the computational overhead of larger models.

</details>


### [24] [Are Classical Clone Detectors Good Enough For the AI Era?](https://arxiv.org/abs/2509.25754)
*Ajmain Inqiad Alam,Palash Roy,Farouq Al-omari,Chanchal Roy,Banani Roy,Kevin Schneider*

Main category: cs.SE

TL;DR: As AI-generated code becomes common, traditional code clone detection tools face new challenges with distinct syntactic and semantic clone patterns. This paper evaluates nine CCD tools on both AI-generated and human-written code benchmarks, finding that normalization enhances detection accuracy and that classical tools are still generally effective, though some show varied performance depending on the clone source. The study helps guide selection and use of CCD tools for AI-era software development.


<details>
  <summary>Details</summary>
Motivation: The paper is motivated by the rise of AI-generated code in software development. This introduces new syntactic and semantic patterns in code clones that may not be adequately addressed by traditional code clone detection (CCD) tools, which were built and tested mostly for human-authored clones.

Method: The authors systematically evaluate nine widely used CCD tools on GPTCloneBench, a benchmark of GPT-3-generated clones. They further compare performance on established human-authored clone benchmarks (BigCloneBench and SemanticCloneBench) to understand the effectiveness and limitations of CCD tools in detecting both AI-generated and traditional clones. The study includes analysis of the impact of normalization techniques and examines scalability and execution-time.

Result: The results show that many classical CCD tools, especially those using effective normalization, still perform well on AI-generated clones. However, there are significant variations in performance among the tools when comparing results on AI-generated versus traditional human-written clones.

Conclusion: Classical CCD tools remain effective to a considerable degree for AI-generated code clones, but their performance isn't uniform and can vary depending on the type of clones and the normalization techniques used. The paper highlights the importance of normalization for improved accuracy and offers practical guidance for tool selection based on scalability and execution-time analysis.

Abstract: The increasing adoption of AI-generated code has reshaped modern software
development, introducing syntactic and semantic variations in cloned code.
Unlike traditional human-written clones, AI-generated clones exhibit systematic
syntactic patterns and semantic differences learned from large-scale training
data. This shift presents new challenges for classical code clone detection
(CCD) tools, which have historically been validated primarily on human-authored
codebases and optimized to detect syntactic (Type 1-3) and limited semantic
clones. Given that AI-generated code can produce both syntactic and complex
semantic clones, it is essential to evaluate the effectiveness of classical CCD
tools within this new paradigm. In this paper, we systematically evaluate nine
widely used CCD tools using GPTCloneBench, a benchmark containing
GPT-3-generated clones. To contextualize and validate our results, we further
test these detectors on established human-authored benchmarks, BigCloneBench
and SemanticCloneBench, to measure differences in performance between
traditional and AI-generated clones. Our analysis demonstrates that classical
CCD tools, particularly those enhanced by effective normalization techniques,
retain considerable effectiveness against AI-generated clones, while some
exhibit notable performance variation compared to traditional benchmarks. This
paper contributes by (1) evaluating classical CCD tools against AI-generated
clones, providing critical insights into their current strengths and
limitations; (2) highlighting the role of normalization techniques in improving
detection accuracy; and (3) delivering detailed scalability and execution-time
analyses to support practical CCD tool selection.

</details>


### [25] [LogPilot: Intent-aware and Scalable Alert Diagnosis for Large-scale Online Service Systems](https://arxiv.org/abs/2509.25874)
*Zhihan Jiang,Jinyang Liu,Yichen Li,Haiyu Huang,Xiao He,Tieying Zhang,Jianjun Chen,Yi Li,Rui Shi,Michael R. Lyu*

Main category: cs.SE

TL;DR: LogPilot is a scalable LLM-powered framework that makes alert diagnosis in large-scale services much more effective and efficient by smartly selecting and organizing logs. It significantly outperforms current solutions in accuracy, speed, and cost, and is already deployed in production.


<details>
  <summary>Details</summary>
Motivation: On-call engineers face the time-consuming challenge of manually analyzing huge volumes of logs to diagnose alerts and identify root causes in large-scale online systems. Existing automated tools are limited, struggling with generic log selection and organizing complex data efficiently for reasoning.

Method: The paper presents LogPilot, a novel framework leveraging Large Language Models (LLMs) for automated log-based alert diagnosis. LogPilot interprets alert definitions to recognize intent, accurately scopes relevant logs, reconstructs request execution into log chains, clusters similar chains to identify patterns, and presents compact, rich inputs to LLMs for diagnosis.

Result: LogPilot was evaluated on real-world data from Volcano Engine Cloud and demonstrated substantial improvements: root cause summarization usefulness increased by 50.34%, exact localization accuracy improved by 54.79% compared with previous methods. Diagnosis is performed in under one minute at a low cost per alert.

Conclusion: By making log scoping intent-aware and optimizing data organization, LogPilot enables scalable, efficient, and accurate automated diagnosis of service alerts. Its proven improvements in accuracy and speed, along with production deployment, establish it as a practical solution for modern online services.

Abstract: Effective alert diagnosis is essential for ensuring the reliability of
large-scale online service systems. However, on-call engineers are often
burdened with manually inspecting massive volumes of logs to identify root
causes. While various automated tools have been proposed, they struggle in
practice due to alert-agnostic log scoping and the inability to organize
complex data effectively for reasoning. To overcome these limitations, we
introduce LogPilot, an intent-aware and scalable framework powered by Large
Language Models (LLMs) for automated log-based alert diagnosis. LogPilot
introduces an intent-aware approach, interpreting the logic in alert
definitions (e.g., PromQL) to precisely identify causally related logs and
requests. To achieve scalability, it reconstructs each request's execution into
a spatiotemporal log chain, clusters similar chains to identify recurring
execution patterns, and provides representative samples to the LLMs for
diagnosis. This clustering-based approach ensures the input is both rich in
diagnostic detail and compact enough to fit within the LLM's context window.
Evaluated on real-world alerts from Volcano Engine Cloud, LogPilot improves the
usefulness of root cause summarization by 50.34% and exact localization
accuracy by 54.79% over state-of-the-art methods. With a diagnosis time under
one minute and a cost of only $0.074 per alert, LogPilot has been successfully
deployed in production, offering an automated and practical solution for
service alert diagnosis.

</details>


### [26] [Red Teaming Program Repair Agents: When Correct Patches can Hide Vulnerabilities](https://arxiv.org/abs/2509.25894)
*Simin Chen,Yixin He,Suman Jana,Baishakhi Ray*

Main category: cs.SE

TL;DR: Even patches generated by LLM-based program repair agents that pass all tests can still be vulnerable if adversarial users craft misleading GitHub issues. SWExploit, an adversarial issue generator, successfully causes APR agents to make functionally correct yet insecure patches, revealing critical security gaps in current agent evaluation standards.


<details>
  <summary>Details</summary>
Motivation: The paper is motivated by the increasing use of LLM-based agents in automated program repair (APR), particularly their lack of consideration for security risks when generating functionally correct patches. It questions whether adversarial users can manipulate these agents via valid GitHub issues to produce vulnerable patches.

Method: The authors propose SWExploit, a framework that generates adversarial issue statements aimed at inducing APR agents to produce patches that are functionally correct but contain vulnerabilities. SWExploit works through three steps: (1) program analysis to find vulnerability injection points, (2) crafting misleading yet semantically valid issue statements, and (3) iterative refinement based on agent outputs.

Result: Empirical evaluation on three agent pipelines and five backend LLMs demonstrates that SWExploit can reliably produce vulnerable yet functionally correct patches, achieving an attack success rate as high as 0.91 (compared to baselines below 0.20).

Conclusion: The study challenges the standard assumption that functionally correct patches passing all tests are secure, exposing major weaknesses in current APR agent evaluation practices.

Abstract: LLM-based agents are increasingly deployed for software maintenance tasks
such as automated program repair (APR). APR agents automatically fetch GitHub
issues and use backend LLMs to generate patches that fix the reported bugs.
However, existing work primarily focuses on the functional correctness of
APR-generated patches, whether they pass hidden or regression tests, while
largely ignoring potential security risks. Given the openness of platforms like
GitHub, where any user can raise issues and participate in discussions, an
important question arises: Can an adversarial user submit a valid issue on
GitHub that misleads an LLM-based agent into generating a functionally correct
but vulnerable patch? To answer this question, we propose SWExploit, which
generates adversarial issue statements designed to make APR agents produce
patches that are functionally correct yet vulnerable. SWExploit operates in
three main steps: (1) program analysis to identify potential injection points
for vulnerable payloads; (2) adversarial issue generation to provide misleading
reproduction and error information while preserving the original issue
semantics; and (3) iterative refinement of the adversarial issue statements
based on the outputs of the APR agents. Empirical evaluation on three agent
pipelines and five backend LLMs shows that SWExploit can produce patches that
are both functionally correct and vulnerable (the attack success rate on the
correct patch could reach 0.91, whereas the baseline ASRs are all below 0.20).
Based on our evaluation, we are the first to challenge the traditional
assumption that a patch passing all tests is inherently reliable and secure,
highlighting critical limitations in the current evaluation paradigm for APR
agents.

</details>


### [27] [R-Log: Incentivizing Log Analysis Capability in LLMs via Reasoning-based Reinforcement Learning](https://arxiv.org/abs/2509.25987)
*Yilun Liu,Ziang Chen,Song Xu,Minggui He,Shimin Tao,Weibin Meng,Yuming Xie,Tao Han,Chunguang Zhao,Jingzhou Du,Daimeng Wei,Shenglin Zhang,Yongqian Sun*

Main category: cs.SE

TL;DR: R-Log is a new framework for log analysis in software systems, combining step-by-step reasoning with reinforcement learning to prevent overfitting and hallucinations found in standard LLM approaches. It outperforms previous methods, especially in unfamiliar settings, and a faster version retains most of its effectiveness.


<details>
  <summary>Details</summary>
Motivation: Modern software systems produce complex log data, making automated analysis challenging. Existing LLM-based methods use supervised fine-tuning on log-label pairs but suffer from overfitting and hallucinations due to domain mismatch and imbalanced loss calculations.

Method: R-Log is proposed as a reasoning-based framework that replicates human engineers' analytical processes. It leverages structured step-by-step reasoning and incorporates reinforcement learning (RL) in a simulated operations & maintenance (O&M) environment to reward correct outcomes and reduce hallucinations. R-Log is initially trained with a curated dataset of 2k+ reasoning trajectories based on 13 O&M strategies, then refined via RL with a joint reward function. Additionally, R-Log-fast offers significant speedup with minimal efficacy loss.

Result: Empirical tests on real-world logs show that R-Log surpasses existing methods in five log analysis tasks, excelling especially in unseen scenarios (improving results by 228.05%). R-Log-fast delivers a 5x speedup while retaining 93% of the original efficacy.

Conclusion: R-Log effectively boosts generalizability and accuracy in log analysis, particularly for novel scenarios, by mimicking human reasoning and employing reinforcement learning. The fast variant maintains high efficiency and speed.

Abstract: The growing complexity of log data in modern software systems has prompted
the use of Large Language Models (LLMs) for automated log analysis. Current
approaches typically rely on direct supervised fine-tuning (SFT) on log-label
pairs. However, this exacerbates the domain discrepancy between general-purpose
LLMs and specialized log data, causing overfitting. Furthermore, SFT's
imbalanced loss computation often allows lengthy contexts to overwhelm
critical, concise details in model answers, leading to hallucinations. To
address these limitations, we propose R-Log, a novel reasoning-based paradigm
that mirrors the structured, step-by-step analytical process of human
engineers. This approach enhances generalizability by learning the underlying
rules behind conclusions. We further employ Reinforcement Learning (RL) to
optimize the model within a simulated O&M environment, thereby reducing
hallucinations by directly rewarding correct outcomes. R-Log is first
cold-started on a curated dataset of 2k+ reasoning trajectories, guided by 13
strategies from manual O&M practices, to establish an initial reasoning
capability. This ability is then refined via RL using a joint reward function.
Empirical evaluations on real-world logs show that R-Log outperforms existing
methods across five log analysis tasks, particularly in unseen scenarios (by
228.05%). We also designed R-Log-fast with 5x speedup while keeping 93% of the
efficacy.

</details>


### [28] [Using GPT to build a Project Management assistant for Jira environments](https://arxiv.org/abs/2509.26014)
*Joel Garcia-Escribano,Arkaitz Carbajo,Mikel Egaña Aranguren,Unai Lopez-Novoa*

Main category: cs.SE

TL;DR: JiraGPT Next integrates GPT with Jira, enabling project managers to retrieve project data via natural language, improving accessibility and efficiency over traditional methods.


<details>
  <summary>Details</summary>
Motivation: Project managers struggle with the complexity and volume of project data and the difficulty of using traditional tools with steep learning curves to retrieve needed information.

Method: The authors designed JiraGPT Next as a natural language add-on for Jira, leveraging GPT LLM to interpret user queries, and evaluated the accuracy of GPT responses and prompt effects.

Result: JiraGPT Next allows project managers to interact with Jira data using natural language, eases data management, and prompt variations can impact accuracy.

Conclusion: JiraGPT Next improves data retrieval for project managers using natural language, making data interactions more accessible and efficient.

Abstract: In the domain of Project Management, the sheer volume of data is a challenge
that project managers continually have to deal with. Effectively steering
projects from inception to completion requires handling of diverse information
streams, including timelines, budgetary considerations, and task dependencies.
To navigate this data-driven landscape with precision and agility, project
managers must rely on efficient and sophisticated tools. These tools have
become essential, as they enable project managers to streamline communication,
optimize resource allocation, and make informed decisions in real-time.
However, many of these tools have steep learning curves and require using
complex programming languages to retrieve the exact data that project managers
need. In this work we present JiraGPT Next, a software that uses the GPT Large
Language Model to ease the process by which project managers deal with large
amounts of data. It is conceived as an add-on for Jira, one of the most popular
Project Management tools, and provides a natural language interface to retrieve
information. This work presents the design decisions behind JiraGPT Next and an
evaluation of the accuracy of GPT in this context, including the effects of
providing different prompts to complete a particular task.

</details>


### [29] [Evaluating the impact of code smell refactoring on the energy consumption of Android applications](https://arxiv.org/abs/2509.26031)
*Hina Anwar,Dietmar Pfahl,Satish N. Srirama*

Main category: cs.SE

TL;DR: Refactoring some code smells in Android apps, especially duplicated code and type checking, can reduce energy use by up to 10.8%. However, benefits vary depending on the refactoring type and order. More research is needed on how app features influence refactoring's energy impact.


<details>
  <summary>Details</summary>
Motivation: There is growing concern about the energy consumption of mobile apps, as improving their energy efficiency could significantly benefit device battery life. Researchers are interested in how frequent code refactoring might help optimize energy usage in Android apps.

Method: The authors experimentally analyzed Android apps by applying several common code refactorings targeting code smells (e.g. duplicated code and type checking). They measured both performance and energy consumption, including assessments of refactoring order and permutations.

Result: Refactoring code smells such as duplicated code and type checking reduced energy consumption by up to 10.8%. However, changes in energy use were not directly linked to execution time changes. The effect of refactoring order was mixed—some permutations decreased energy consumption, others increased it. Generally, the overall energy impact of permutations was small.

Conclusion: Certain code smell refactorings can positively impact energy consumption in Android apps. The relationship between refactoring and energy savings is complex and not fully determined by execution time. Further study is needed to examine how app characteristics (size, age, development team experience) affect code smells and energy outcomes after refactoring.

Abstract: Energy consumption of mobile apps is a domain that is receiving a lot of
attention from researchers. Recent studies indicate that the energy consumption
of mobile devices could be improved by improving the quality of mobile apps.
Frequent refactoring is one way of achieving this goal. In this paper, we
explore the performance and energy impact of several common code refactorings
in Android apps. Experimental results indicate that some code smell
refactorings positively impact the energy consumption of Android apps.
Refactoring of the code smells "Duplicated code" and "Type checking" reduce
energy consumption by up to 10.8%. Significant reduction in energy consumption,
however, does not seem to be directly related to the increase or decrease of
execution time. In addition, the energy impact over permutations of code smell
refactorings in the selected Android apps was small. When analyzing the order
in which refactorings were made across code smell types, it turned out that
some permutations resulted in a reduction and some in an increase of energy
consumption for the analyzed apps. More research needs to be done to
investigate how factors like size and age of software apps, experience, and
number of contributors to app development correlate with (a) the number and
type of code smells found and (b) the impact of energy consumption and
performance after refactoring.

</details>


### [30] [Agent-based code generation for the Gammapy framework](https://arxiv.org/abs/2509.26110)
*Dmitriy Kostunin,Vladimir Sotnikov,Sergo Golovachev,Abhay Mehta,Tim Lukas Holch,Elisa Jones*

Main category: cs.SE

TL;DR: This paper introduces an agent that assists code generation for the Gammapy scientific library, addressing challenges from limited documentation and unstable APIs. It features a demo and benchmarking suite, demonstrating improved support for specialized libraries using LLMs.


<details>
  <summary>Details</summary>
Motivation: The motivation is to improve code generation capabilities for specialized scientific libraries, which often lack sufficient documentation, examples, and community support, making it challenging for LLMs to handle them effectively.

Method: The authors develop an agent designed to write, execute, and validate code for the Gammapy library within a controlled environment. They provide a minimal web demo and a benchmarking suite to evaluate the agent's performance.

Result: The paper presents the design of the agent, reports its current status, and offers next steps for further development. A minimal demo and benchmarking suite accompany the agent to showcase its capabilities.

Conclusion: Developing specialized agents tailored for scientific libraries can overcome limitations faced by LLMs trained on general data, making code generation and validation more feasible for niche or evolving libraries.

Abstract: Software code generation using Large Language Models (LLMs) is one of the
most successful applications of modern artificial intelligence. Foundational
models are very effective for popular frameworks that benefit from
documentation, examples, and strong community support. In contrast, specialized
scientific libraries often lack these resources and may expose unstable APIs
under active development, making it difficult for models trained on limited or
outdated data. We address these issues for the Gammapy library by developing an
agent capable of writing, executing, and validating code in a controlled
environment. We present a minimal web demo and an accompanying benchmarking
suite. This contribution summarizes the design, reports our current status, and
outlines next steps.

</details>


### [31] [A Multi-Language Object-Oriented Programming Benchmark for Large Language Models](https://arxiv.org/abs/2509.26111)
*Shuai Wang,Liang Ding,Li Shen,Yong Luo,Han Hu,Lefei Zhang,Fu Lin*

Main category: cs.SE

TL;DR: Current code generation benchmarks for LLMs lack multi-language coverage and depth. MultiOOP introduces 267 OOP tasks across six languages, showing that LLMs struggle with multilingual generalization and deep OOP concepts. The study offers new metrics and tools for fairer evaluation and will release all resources publicly.


<details>
  <summary>Details</summary>
Motivation: Existing benchmarks for evaluating code generation by large language models (LLMs) are overly narrow: most focus on a single language, simple tasks, and have few test cases. These limitations hinder robust, fair assessment of LLMs' abilities, especially for object-oriented programming (OOP) and multilingual scenarios.

Method: The authors create MultiOOP, a new benchmark with 267 object-oriented programming tasks in each of six major programming languages. They translate and extend an existing OOP benchmark, adapt the pass@o metric for multilingual use, and offer automated augmentation of test cases to improve evaluation reliability. Fourteen LLMs are evaluated under zero-shot prompting, comparing their performance across languages and task types.

Result: The LLMs show significant performance drop on MultiOOP compared to simpler benchmarks (up to 65.6 percentage points lower pass@1). Performance varies greatly between languages (e.g., GPT-4o mini gets 48.06% in Python vs. as low as 0.12% elsewhere). LLMs often generate code that runs but fails to fully capture OOP concepts, as shown by lower pass@o scores compared to pass@k.

Conclusion: MultiOOP exposes major gaps in LLMs' capabilities for multilingual, object-oriented code generation, highlighting the need for better benchmarks and evaluation metrics. The authors' contributions—benchmark, metrics, and scripts—will support more comprehensive, balanced assessments going forward.

Abstract: Establishing fair and robust benchmarks is essential for evaluating
intelligent code generation by large language models (LLMs). Our survey of 35
existing benchmarks uncovers three major imbalances: 85.7% focus on a single
programming language; 94.3% target only function-level or statement-level
tasks; and over 80% include fewer than ten test cases on average. To address
these gaps, we propose MultiOOP, a multi-language object-oriented programming
benchmark covering six popular languages (Python, PHP, C++, C#, Java,
JavaScript) with 267 tasks per language. We design a translator that extends an
existing single-language OOP benchmark and the pass@o metric to a multilingual
setting. Moreover, we propose an automated framework for augmenting test cases
to ensure the reliability of the evaluation results. We evaluate 14 mainstream
LLMs under zero-shot prompting and report three key findings: 1) Substantial
performance degradation: pass@1 scores on MultiOOP drop by up to 65.6
percentage points compared to function-level tasks (e.g., HumanEval). 2)
Cross-language variability: GPT-4o mini achieves pass@1 of 48.06% in Python but
only 0.12%-15.26% in other languages, indicating limited multilingual
generalization. 3) Conceptual gaps: pass@o scores are consistently 1.1-19.2
points lower than pass@k, demonstrating that LLMs often generate executable
code without fully capturing core OOP concepts. Our benchmark, metric
extensions, and evaluation scripts will be publicly released to foster a more
balanced and comprehensive assessment of LLMs in object-oriented code
generation. Our code and data will be released at
https://github.com/alphadl/OOP-eval and
https://huggingface.co/datasets/codeai-dteam/MultiOOP respectively.

</details>


### [32] [Understanding Collective Social Behavior in OSS Communities: A Co-editing Network Analysis of Activity Cascades](https://arxiv.org/abs/2509.26173)
*Lisi Qarkaxhija,Maximilian Carparo,Stefan Menzel,Bernhard Sendhoff,Ingo Scholtes*

Main category: cs.SE

TL;DR: The paper models OSS developer interactions and finds that bursts of collaborative activity ('activity cascades') help predict which developers may leave. This new understanding supports improved retention strategies.


<details>
  <summary>Details</summary>
Motivation: Understanding the collective social behavior of software developers is essential for modeling and predicting the long-term dynamics and sustainability of OSS communities.

Method: The paper analyzes temporal activity patterns of developers and uses a network-based modelling framework to capture developer interactions via co-editing networks. It further develops a method to identify activity cascades—propagation of developer activity within these networks.

Result: Activity cascades are found to be statistically significant in over half of the studied OSS projects. These insights enable the development of a practical churn prediction method to forecast which developers may leave a project.

Conclusion: Activity cascades are fundamental to understanding developer churn and retention, highlighting their importance for sustaining OSS communities.

Abstract: Understanding the collective social behavior of software developers is
crucial to model and predict the long-term dynamics and sustainability of Open
Source Software (OSS) communities. To this end, we analyze temporal activity
patterns of developers, revealing an inherently ``bursty'' nature of commit
contributions. To investigate the social mechanisms behind this phenomenon, we
adopt a network-based modelling framework that captures developer interactions
through co-editing networks. Our framework models social interactions, where a
developer editing the code of other developers triggers accelerated activity
among collaborators. Using a large data set on 50 major OSS communities, we
further develop a method that identifies activity cascades, i.e. the
propagation of developer activity in the underlying co-editing network. Our
results suggest that activity cascades are a statistically significant
phenomenon in more than half of the studied projects. We further show that our
insights can be used to develop a simple yet practical churn prediction method
that forecasts which developers are likely to leave a project. Our work sheds
light on the emergent collective social dynamics in OSS communities and
highlights the importance of activity cascades to understand developer churn
and retention in collaborative software projects.

</details>


### [33] [Hamster: A Large-Scale Study and Characterization of Developer-Written Tests](https://arxiv.org/abs/2509.26204)
*Rangeet Pan,Tyler Stennett,Raju Pavuluri,Nate Levin,Alessandro Orso,Saurabh Sinha*

Main category: cs.SE

TL;DR: This paper analyzes 1.7 million Java test cases to reveal how developer-written tests differ from those generated by state-of-the-art ATG tools. Many characteristics of real developer tests are still beyond the reach of automation, suggesting a need for improved tools and new research directions.


<details>
  <summary>Details</summary>
Motivation: There is a lack of understanding about the specific characteristics of developer-written tests, which hinders accurate assessment and improvement of automated test generation (ATG) tools.

Method: An extensive empirical study analyzing 1.7 million developer-written test cases from open-source Java applications, focusing on aspects often neglected such as test scope, fixtures and assertions, input types, and mocking. The study further compares these tests to those generated by two state-of-the-art ATG tools.

Result: The majority of developer-written tests possess characteristics not captured by current ATG tools, revealing significant limitations of automated approaches in matching real-world developer testing practices.

Conclusion: Current ATG tools fall short in generating realistic and representative tests akin to those written by developers. The study identifies the gap and proposes future research directions to enhance tool support and make ATG outputs more useful for developers.

Abstract: Automated test generation (ATG), which aims to reduce the cost of manual test
suite development, has been investigated for decades and has produced countless
techniques based on a variety of approaches: symbolic analysis, search-based,
random and adaptive-random, learning-based, and, most recently,
large-language-model-based approaches. However, despite this large body of
research, there is still a gap in our understanding of the characteristics of
developer-written tests and, consequently, in our assessment of how well ATG
techniques and tools can generate realistic and representative tests. To bridge
this gap, we conducted an extensive empirical study of developer-written tests
for Java applications, covering 1.7 million test cases from open-source
repositories. Our study is the first of its kind in studying aspects of
developer-written tests that are mostly neglected in the existing literature,
such as test scope, test fixtures and assertions, types of inputs, and use of
mocking. Based on the characterization, we then compare existing tests with
those generated by two state-of-the-art ATG tools. Our results highlight that a
vast majority of developer-written tests exhibit characteristics that are
beyond the capabilities of current ATG tools. Finally, based on the insights
gained from the study, we identify promising research directions that can help
bridge the gap between current tool capabilities and more effective tool
support for developer testing practices. We hope that this work can set the
stage for new advances in the field and bring ATG tools closer to generating
the types of tests developers write.

</details>


### [34] [UniSage: A Unified and Post-Analysis-Aware Sampling for Microservices](https://arxiv.org/abs/2509.26336)
*Zhouruixing Zhu,Zhihan Jiang,Tianyi Yang,Pinjia He*

Main category: cs.SE

TL;DR: UniSage is a novel framework that samples observability data after performing fast whole-stream analysis, capturing vital system traces and logs with minimal storage and high accuracy, outperforming prior methods for distributed systems monitoring and diagnosis.


<details>
  <summary>Details</summary>
Motivation: The rapid increase in the volume of traces and logs in distributed systems creates major storage constraints and complicates troubleshooting, as existing sampling methods often discard important failure-related data.

Method: UniSage is a unified framework that samples both traces and logs using a post-analysis-aware paradigm. It first performs lightweight, multi-modal anomaly detection and root cause analysis on the entire data stream, then employs a dual-pillar sampling strategy: an analysis-guided sampler for RCA-implicated data, and an edge-case-based sampler for rare events.

Result: At just a 2.5% sampling rate, UniSage captures 56.5% of critical traces and 96.25% of relevant logs. It also improves the accuracy (AC@1) of downstream root cause analysis by 42.45%. The pipeline processes 10 minutes of telemetry data in less than 5 seconds, proving practical for real-world deployment.

Conclusion: UniSage achieves efficient, effective, and comprehensive sampling for observability data. It delivers significant improvements over existing baselines in capturing critical information while reducing storage overhead and supporting accurate failure diagnosis.

Abstract: Traces and logs are essential for observability and fault diagnosis in modern
distributed systems. However, their ever-growing volume introduces substantial
storage overhead and complicates troubleshooting. Existing approaches typically
adopt a sample-before-analysis paradigm: even when guided by data heuristics,
they inevitably discard failure-related information and hinder transparency in
diagnosing system behavior. To address this, we introduce UniSage, the first
unified framework to sample both traces and logs using a post-analysis-aware
paradigm. Instead of discarding data upfront, UniSagefirst performs lightweight
and multi-modal anomaly detection and root cause analysis (RCA) on the complete
data stream. This process yields fine-grained, service-level diagnostic
insights that guide a dual-pillar sampling strategy for handling both normal
and anomalous scenarios: an analysis-guided sampler prioritizes data implicated
by RCA, while an edge-case-based sampler ensures rare but critical behaviors
are captured. Together, these pillars ensure comprehensive coverage of critical
signals without excessive redundancy. Extensive experiments demonstrate that
UniSage significantly outperforms state-of-the-art baselines. At a 2.5%
sampling rate, it captures 56.5% of critical traces and 96.25% of relevant
logs, while improving the accuracy (AC@1) of downstream root cause analysis by
42.45%. Furthermore, its efficient pipeline processes 10 minutes of telemetry
data in under 5 seconds, demonstrating its practicality for production
environments.

</details>


### [35] [Institutional Policy Pathways for Supporting Research Software: Global Trends and Local Practices](https://arxiv.org/abs/2509.26422)
*Michelle Barker,Jeremy Cohen,Pedro Hernández Serrano,Daniel S. Katz,Kim Martin,Dan Rudmann,Hugh Shanahan*

Main category: cs.SE

TL;DR: As research software becomes more essential, institutions have not kept pace with policy and support structures. The PRO4RS WG analyzed global policies, found substantial gaps, especially around personnel recognition, and stresses the need for robust, institution-wide approaches to support research software sustainability.


<details>
  <summary>Details</summary>
Motivation: Research software has become essential in modern science, but institutions lack adequate policies, training, and recognition structures to support sustainable development and maintenance.

Method: The PRO4RS Working Group (WG), a joint effort by ReSA and RDA, examined institutional research software policy development worldwide, analyzed existing policies, and highlighted gaps using their outputs.

Result: The analysis identified significant gaps in institutional policies, especially regarding the support and recognition of research software personnel in research assessment reforms.

Conclusion: Robust institutional policies focused on research software and its personnel are crucial for sustainable research environments and are currently insufficient, hampering long-term advancement.

Abstract: As research software becomes increasingly central to modern science,
research-performing organisations (RPOs) need to ensure that their investment
in people, skills and infrastructure around research software produces
sustainable and maintainable software that improves the research they perform,
which in turn improves the overall institution and its reputation and funding,
for example, by competing with peers who lack this approach. However, research
institution management and recognition of research software and its personnel
has mostly often developed in an ad hoc manner. RPO training infrastructures,
recognition and reward structures, have not developed at a sufficient rate to
support and encourage both the widespread use of research software best
practices and the long-term support for technical roles that is required. To
begin to address this fundamental problem for modern research environments,
RPOs must implement and adopt robust policies to support research software
development, use, and sustainability. Despite growing momentum from funders and
publishers around FAIR and open science principles, research
institutional-level policies specifically addressing research software remain
limited or lacking in breadth.
  This article outlines the work of the Policies in Research Organisations for
Research Software (PRO4RS) Working Group (WG), a joint initiative of the
Research Software Alliance (ReSA) and the Research Data Alliance (RDA), which
examined and advanced research software policy development across institutions
worldwide. After consideration of the rationale for institutional policies on
research software, the PRO4RS WG outputs and analysis are utilised to highlight
critical policy gaps, particularly related to consideration of research
software personnel in policy work focused on reform of research assessment.

</details>


### [36] [EQ-Robin: Generating Multiple Minimal Unique-Cause MC/DC Test Suites](https://arxiv.org/abs/2509.26458)
*Robin Lee,Youngho Nam*

Main category: cs.SE

TL;DR: Robin's Rule generates only one minimal MC/DC test suite, which can fail when system constraints make some tests illegal. EQ-Robin creates many semantically equivalent test suites using algebraic transformations, ensuring robust, minimal coverage in safety-critical contexts despite constraints.


<details>
  <summary>Details</summary>
Motivation: The motivation arises from a limitation in the Robin's Rule algorithm for generating minimal Unique-Cause MC/DC test suites for Singular Boolean Expressions (SBEs); specifically, if a required 'independence pair' contains an illegal input, the minimal suite cannot achieve full coverage and fails in safety-critical verification.

Method: The paper proposes EQ-Robin, a pipeline that generates multiple minimal MC/DC test suites by systematically creating semantically equivalent variants of SBEs using algebraic rearrangements of their AST representations. Robin's Rule is applied to each variant, producing varied minimal suites.

Result: EQ-Robin can construct diverse minimal test suites, increasing the likelihood of obtaining a valid suite that meets system constraints without sacrificing coverage or minimality. The evaluation plan involves applying the method to TCAS-II-derived SBEs.

Conclusion: EQ-Robin addresses the risk of incomplete MC/DC coverage associated with Robin's Rule by generating multiple minimal Unique-Cause MC/DC suites, allowing robust coverage even when constraints prohibit specific test cases.

Abstract: Modified Condition/Decision Coverage (MC/DC), particularly its strict
Unique-Cause form, is a cornerstone of safety-critical software verification. A
recent algorithm, "Robin's Rule," introduced a deterministic method to
construct the theoretical minimum of N+1 test cases for Singular Boolean
Expressions (SBEs). However, this approach yields only a single test suite,
introducing a critical risk: if a test case forming a required 'independence
pair' is an illegal input forbidden by system constraints, the suite fails to
achieve 100% coverage. This paper proposes EQ-Robin, a lightweight pipeline
that systematically generates a family of minimal Unique-Cause MC/DC suites to
mitigate this risk. We introduce a method for systematically generating
semantically equivalent SBEs by applying algebraic rearrangements to an
Abstract Syntax Tree (AST) representation of the expression. By applying
Robin's Rule to each structural variant, a diverse set of test suites can be
produced. This provides a resilient path to discovering a valid test suite that
preserves the N+1 minimality guarantee while navigating real-world constraints.
We outline an evaluation plan on TCAS-II-derived SBEs to demonstrate how
EQ-Robin offers a practical solution for ensuring robust MC/DC coverage.

</details>


### [37] [ErrorPrism: Reconstructing Error Propagation Paths in Cloud Service Systems](https://arxiv.org/abs/2509.26463)
*Junsong Pu,Yichen Li,Zhuangbin Chen,Jinyang Liu,Zhihan Jiang,Jianjun Chen,Rui Shi,Zibin Zheng,Tieying Zhang*

Main category: cs.SE

TL;DR: ErrorPrism is a novel tool that combines static code analysis and LLM-based reasoning to accurately trace error propagation paths in microservice systems, achieving high accuracy and outperforming existing methods in production environments.


<details>
  <summary>Details</summary>
Motivation: Cloud service systems, especially those using microservices, face reliability challenges due to failures that can cascade through complex error chains. Error wrapping, while helpful for context, makes tracing these chains back to their source difficult and existing solutions do not solve this traceability problem effectively.

Method: The paper introduces ErrorPrism, a tool that first uses static analysis of service code to construct a function call graph and map log strings to candidate functions, reducing the path search space. It then uses an LLM agent for iterative backward search on this graph to accurately reconstruct error propagation paths.

Result: ErrorPrism was evaluated on 67 production microservices at ByteDance and demonstrated 97.0% accuracy in reconstructing error paths for 102 real-world errors. It outperformed traditional static analysis and other LLM-based solutions.

Conclusion: ErrorPrism provides an accurate, automated, and practical method for reconstructing error propagation paths in microservices, significantly aiding root cause analysis and surpassing prior approaches.

Abstract: Reliability management in cloud service systems is challenging due to the
cascading effect of failures. Error wrapping, a practice prevalent in modern
microservice development, enriches errors with context at each layer of the
function call stack, constructing an error chain that describes a failure from
its technical origin to its business impact. However, this also presents a
significant traceability problem when recovering the complete error propagation
path from the final log message back to its source. Existing approaches are
ineffective at addressing this problem. To fill this gap, we present ErrorPrism
in this work for automated reconstruction of error propagation paths in
production microservice systems. ErrorPrism first performs static analysis on
service code repositories to build a function call graph and map log strings to
relevant candidate functions. This significantly reduces the path search space
for subsequent analysis. Then, ErrorPrism employs an LLM agent to perform an
iterative backward search to accurately reconstruct the complete, multi-hop
error path. Evaluated on 67 production microservices at ByteDance, ErrorPrism
achieves 97.0% accuracy in reconstructing paths for 102 real-world errors,
outperforming existing static analysis and LLM-based approaches. ErrorPrism
provides an effective and practical tool for root cause analysis in industrial
microservice systems.

</details>


### [38] [Towards Verified Code Reasoning by LLMs](https://arxiv.org/abs/2509.26546)
*Meghana Sistla,Gogul Balakrishnan,Pat Rondon,José Cambronero,Michele Tufano,Satish Chandra*

Main category: cs.SE

TL;DR: The paper introduces a method to automatically validate the responses of code reasoning agents using formal verification tools. Experiments show it can successfully confirm correct answers and catch incorrect ones, improving reliability while highlighting remaining limitations.


<details>
  <summary>Details</summary>
Motivation: LLM-based agents can answer many code reasoning questions, but their answers aren't always correct. This unreliability is problematic, especially when high precision is necessary, such as in code understanding, code reviews, or evaluating automatically generated code. The lack of trust in these agents means human engineers must verify their responses, consuming time and reducing productivity.

Method: The paper proposes an automatic method to validate answers from a code reasoning agent. This is done by extracting a formal representation of the agent's response and using formal verification and program analysis tools to check the reasoning steps for correctness.

Result: The method was evaluated with 20 uninitialized variable error cases and 20 program equivalence queries. For the uninitialized variable cases, 13 out of 20 agent responses were validated successfully. For the program equivalence queries, the system detected 6 out of 8 incorrect agent judgments.

Conclusion: Automatically validating code reasoning agent responses using formal verification can improve trustworthiness and reduce manual effort, though there are still gaps in coverage and accuracy.

Abstract: While LLM-based agents are able to tackle a wide variety of code reasoning
questions, the answers are not always correct. This prevents the agent from
being useful in situations where high precision is desired: (1) helping a
software engineer understand a new code base, (2) helping a software engineer
during code review sessions, and (3) ensuring that the code generated by an
automated code generation system meets certain requirements (e.g. fixes a bug,
improves readability, implements a feature).
  As a result of this lack of trustworthiness, the agent's answers need to be
manually verified before they can be trusted. Manually confirming responses
from a code reasoning agent requires human effort and can result in slower
developer productivity, which weakens the assistance benefits of the agent. In
this paper, we describe a method to automatically validate the answers provided
by a code reasoning agent by verifying its reasoning steps. At a very high
level, the method consists of extracting a formal representation of the agent's
response and, subsequently, using formal verification and program analysis
tools to verify the agent's reasoning steps.
  We applied this approach to a benchmark set of 20 uninitialized variable
errors detected by sanitizers and 20 program equivalence queries. For the
uninitialized variable errors, the formal verification step was able to
validate the agent's reasoning on 13/20 examples, and for the program
equivalence queries, the formal verification step successfully caught 6/8
incorrect judgments made by the agent.

</details>
