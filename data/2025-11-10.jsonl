{"id": "2511.04824", "categories": ["cs.SE", "D.2.7"], "pdf": "https://arxiv.org/pdf/2511.04824", "abs": "https://arxiv.org/abs/2511.04824", "authors": ["Kosei Horikawa", "Hao Li", "Yutaro Kashiwa", "Bram Adams", "Hajimu Iida", "Ahmed E. Hassan"], "title": "Agentic Refactoring: An Empirical Study of AI Coding Agents", "comment": "23 pages, 7 Tables, 5 Figuress, Submitted to ACM Transactions on\n  Software Engineering and Methodology(TOSEM)", "summary": "Agentic coding tools, such as OpenAI Codex, Claude Code, and Cursor, are\ntransforming the software engineering landscape. These AI-powered systems\nfunction as autonomous teammates capable of planning and executing complex\ndevelopment tasks. Agents have become active participants in refactoring, a\ncornerstone of sustainable software development aimed at improving internal\ncode quality without altering observable behavior. Despite their increasing\nadoption, there is a critical lack of empirical understanding regarding how\nagentic refactoring is utilized in practice, how it compares to human-driven\nrefactoring, and what impact it has on code quality. To address this empirical\ngap, we present a large-scale study of AI agent-generated refactorings in\nreal-world open-source Java projects, analyzing 15,451 refactoring instances\nacross 12,256 pull requests and 14,988 commits derived from the AIDev dataset.\nOur empirical analysis shows that refactoring is a common and intentional\nactivity in this development paradigm, with agents explicitly targeting\nrefactoring in 26.1% of commits. Analysis of refactoring types reveals that\nagentic efforts are dominated by low-level, consistency-oriented edits, such as\nChange Variable Type (11.8%), Rename Parameter (10.4%), and Rename Variable\n(8.5%), reflecting a preference for localized improvements over the high-level\ndesign changes common in human refactoring. Additionally, the motivations\nbehind agentic refactoring focus overwhelmingly on internal quality concerns,\nwith maintainability (52.5%) and readability (28.1%). Furthermore, quantitative\nevaluation of code quality metrics shows that agentic refactoring yields small\nbut statistically significant improvements in structural metrics, particularly\nfor medium-level changes, reducing class size and complexity (e.g., Class LOC\nmedian $\\Delta$ = -15.25)."}
{"id": "2511.04849", "categories": ["cs.SE", "cs.AI", "I.2.6; I.2.7; D.2.3"], "pdf": "https://arxiv.org/pdf/2511.04849", "abs": "https://arxiv.org/abs/2511.04849", "authors": ["Quang-Dung Nguyen", "Tri-Dung Tran", "Thanh-Hieu Chu", "Hoang-Loc Tran", "Xiangwei Cheng", "Dirk Slama"], "title": "Software Defined Vehicle Code Generation: A Few-Shot Prompting Approach", "comment": "6 pages, 3 figures", "summary": "The emergence of Software-Defined Vehicles (SDVs) marks a paradigm shift in\nthe automotive industry, where software now plays a pivotal role in defining\nvehicle functionality, enabling rapid innovation of modern vehicles. Developing\nSDV-specific applications demands advanced tools to streamline code generation\nand improve development efficiency. In recent years, general-purpose large\nlanguage models (LLMs) have demonstrated transformative potential across\ndomains. Still, restricted access to proprietary model architectures hinders\ntheir adaption to specific tasks like SDV code generation. In this study, we\npropose using prompts, a common and basic strategy to interact with LLMs and\nredirect their responses. Using only system prompts with an appropriate and\nefficient prompt structure designed using advanced prompt engineering\ntechniques, LLMs can be crafted without requiring a training session or access\nto their base design. This research investigates the extensive experiments on\ndifferent models by applying various prompting techniques, including bare\nmodels, using a benchmark specifically created to evaluate LLMs' performance in\ngenerating SDV code. The results reveal that the model with a few-shot\nprompting strategy outperforms the others in adjusting the LLM answers to match\nthe expected outcomes based on quantitative metrics."}
{"id": "2511.04986", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.04986", "abs": "https://arxiv.org/abs/2511.04986", "authors": ["Mohammadreza Saeidi", "Ethan Thoma", "Raula Gaikovina Kula", "Gema Rodríguez-Pérez"], "title": "What About Our Bug? A Study on the Responsiveness of NPM Package Maintainers", "comment": null, "summary": "Background: Widespread use of third-party libraries makes ecosystems like\nNode Package Manager (npm) critical to modern software development. However,\nthis interconnected chain of dependencies also creates challenges: bugs in one\nlibrary can propagate downstream, potentially impacting many other libraries\nthat rely on it. We hypothesize that maintainers may not always decide to fix a\nbug, especially if the maintainer decides it falls out of their responsibility\nwithin the chain of dependencies. Aims: To confirm this hypothesis, we\ninvestigate the responsiveness of 30,340 bug reports across 500 of the most\ndepended-upon npm packages. Method: We adopt a mixed-method approach to mine\nrepository issue data and perform qualitative open coding to analyze reasons\nbehind unaddressed bug reports. Results: Our findings show that maintainers are\ngenerally responsive, with a median project-level responsiveness of 70% (IQR:\n55%-89%), reflecting their commitment to support downstream developers.\nConclusions: We present a taxonomy of the reasons some bugs remain unresolved.\nThe taxonomy includes contribution practices, dependency constraints, and\nlibrary-specific standards as reasons for not being responsive. Understanding\nmaintainer behavior can inform practices that promote a more robust and\nresponsive open-source ecosystem that benefits the entire community."}
{"id": "2511.05165", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.05165", "abs": "https://arxiv.org/abs/2511.05165", "authors": ["Ahmad Hatahet", "Christoph Knieke", "Andreas Rausch"], "title": "Generating Software Architecture Description from Source Code using Reverse Engineering and Large Language Model", "comment": null, "summary": "Software Architecture Descriptions (SADs) are essential for managing the\ninherent complexity of modern software systems. They enable high-level\narchitectural reasoning, guide design decisions, and facilitate effective\ncommunication among diverse stakeholders. However, in practice, SADs are often\nmissing, outdated, or poorly aligned with the system's actual implementation.\nConsequently, developers are compelled to derive architectural insights\ndirectly from source code-a time-intensive process that increases cognitive\nload, slows new developer onboarding, and contributes to the gradual\ndegradation of clarity over the system's lifetime. To address these issues, we\npropose a semi-automated generation of SADs from source code by integrating\nreverse engineering (RE) techniques with a Large Language Model (LLM). Our\napproach recovers both static and behavioral architectural views by extracting\na comprehensive component diagram, filtering architecturally significant\nelements (core components) via prompt engineering, and generating state machine\ndiagrams to model component behavior based on underlying code logic with\nfew-shots prompting. This resulting views representation offer a scalable and\nmaintainable alternative to traditional manual architectural documentation.\nThis methodology, demonstrated using C++ examples, highlights the potent\ncapability of LLMs to: 1) abstract the component diagram, thereby reducing the\nreliance on human expert involvement, and 2) accurately represent complex\nsoftware behaviors, especially when enriched with domain-specific knowledge\nthrough few-shot prompting. These findings suggest a viable path toward\nsignificantly reducing manual effort while enhancing system understanding and\nlong-term maintainability."}
{"id": "2511.05205", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.05205", "abs": "https://arxiv.org/abs/2511.05205", "authors": ["Huimin Hu", "Michael Pradel"], "title": "CodeMapper: A Language-Agnostic Approach to Mapping Code Regions Across Commits", "comment": null, "summary": "During software evolution, developers commonly face the problem of mapping a\nspecific code region from one commit to another. For example, they may want to\ndetermine how the condition of an if-statement, a specific line in a\nconfiguration file, or the definition of a function changes. We call this the\ncode mapping problem. Existing techniques, such as git diff, address this\nproblem only insufficiently because they show all changes made to a file\ninstead of focusing on a code region of the developer's choice. Other\ntechniques focus on specific code elements and programming languages (e.g.,\nmethods in Java), limiting their applicability. This paper introduces\nCodeMapper, an approach to address the code mapping problem in a way that is\nindependent of specific program elements and programming languages. Given a\ncode region in one commit, CodeMapper finds the corresponding region in another\ncommit. The approach consists of two phases: (i) computing candidate regions by\nanalyzing diffs, detecting code movements, and searching for specific code\nfragments, and (ii) selecting the most likely target region by calculating\nsimilarities. Our evaluation applies CodeMapper to four datasets, including two\nnew hand-annotated datasets containing code region pairs in ten popular\nprogramming languages. CodeMapper correctly identifies the expected target\nregion in 71.0%--94.5% of all cases, improving over the best available\nbaselines by 1.5--58.8 absolute percent points."}
{"id": "2511.05297", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.05297", "abs": "https://arxiv.org/abs/2511.05297", "authors": ["Mohammed Hilel", "Yannis Karmim", "Jean De Bodinat", "Reda Sarehane", "Antoine Gillon"], "title": "Building Specialized Software-Assistant ChatBot with Graph-Based Retrieval-Augmented Generation", "comment": null, "summary": "Digital Adoption Platforms (DAPs) have become essential tools for helping\nemployees navigate complex enterprise software such as CRM, ERP, or HRMS\nsystems. Companies like LemonLearning have shown how digital guidance can\nreduce training costs and accelerate onboarding. However, building and\nmaintaining these interactive guides still requires extensive manual effort.\nLeveraging Large Language Models as virtual assistants is an appealing\nalternative, yet without a structured understanding of the target software,\nLLMs often hallucinate and produce unreliable answers. Moreover, most\nproduction-grade LLMs are black-box APIs, making fine-tuning impractical due to\nthe lack of access to model weights. In this work, we introduce a Graph-based\nRetrieval-Augmented Generation framework that automatically converts enterprise\nweb applications into state-action knowledge graphs, enabling LLMs to generate\ngrounded and context-aware assistance. The framework was co-developed with the\nAI enterprise RAKAM, in collaboration with Lemon Learning. We detail the\nengineering pipeline that extracts and structures software interfaces, the\ndesign of the graph-based retrieval process, and the integration of our\napproach into production DAP workflows. Finally, we discuss scalability,\nrobustness, and deployment lessons learned from industrial use cases."}
{"id": "2511.05302", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.05302", "abs": "https://arxiv.org/abs/2511.05302", "authors": ["Qianru Meng", "Xiao Zhang", "Zhaochen Ren", "Joost Visser"], "title": "Code Review Automation using Retrieval Augmented Generation", "comment": null, "summary": "Code review is essential for maintaining software quality but is\nlabor-intensive. Automated code review generation offers a promising solution\nto this challenge. Both deep learning-based generative techniques and\nretrieval-based methods have demonstrated strong performance in this task.\nHowever, despite these advancements, there are still some limitations where\ngenerated reviews can be either off-point or overly general. To address these\nissues, we introduce Retrieval-Augmented Reviewer (RARe), which leverages\nRetrieval-Augmented Generation (RAG) to combine retrieval-based and generative\nmethods, explicitly incorporating external domain knowledge into the code\nreview process. RARe uses a dense retriever to select the most relevant reviews\nfrom the codebase, which then enrich the input for a neural generator,\nutilizing the contextual learning capacity of large language models (LLMs), to\nproduce the final review. RARe outperforms state-of-the-art methods on two\nbenchmark datasets, achieving BLEU-4 scores of 12.32 and 12.96, respectively.\nIts effectiveness is further validated through a detailed human evaluation and\na case study using an interpretability tool, demonstrating its practical\nutility and reliability."}
{"id": "2511.05459", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.05459", "abs": "https://arxiv.org/abs/2511.05459", "authors": ["Jingxuan Xu", "Ken Deng", "Weihao Li", "Songwei Yu", "Huaixi Tang", "Haoyang Huang", "Zhiyi Lai", "Zizheng Zhan", "Yanan Wu", "Chenchen Zhang", "Kepeng Lei", "Yifan Yao", "Xinping Lei", "Wenqiang Zhu", "Zongxian Feng", "Han Li", "Junqi Xiong", "Dailin Li", "Zuchen Gao", "Kun Wu", "Wen Xiang", "Ziqi Zhan", "Yuanxing Zhang", "Wuxuan Gong", "Ziyuan Gao", "Guanxiang Wang", "Yirong Xue", "Xiaojiang Zhang", "Jinghui Wang", "Huiming Wang", "Wenhao Zhuang", "Zhaoxiang Zhang", "Yuqun Zhang", "Haotian Zhang", "Bin Chen", "Jiaheng Liu"], "title": "SWE-Compass: Towards Unified Evaluation of Agentic Coding Abilities for Large Language Models", "comment": null, "summary": "Evaluating large language models (LLMs) for software engineering has been\nlimited by narrow task coverage, language bias, and insufficient alignment with\nreal-world developer workflows. Existing benchmarks often focus on algorithmic\nproblems or Python-centric bug fixing, leaving critical dimensions of software\nengineering underexplored. To address these gaps, we introduce SWE-Compass1, a\ncomprehensive benchmark that unifies heterogeneous code-related evaluations\ninto a structured and production-aligned framework. SWE-Compass spans 8 task\ntypes, 8 programming scenarios, and 10 programming languages, with 2000\nhigh-quality instances curated from authentic GitHub pull requests and refined\nthrough systematic filtering and validation. We benchmark ten state-of-the-art\nLLMs under two agentic frameworks, SWE-Agent and Claude Code, revealing a clear\nhierarchy of difficulty across task types, languages, and scenarios. Moreover,\nby aligning evaluation with real-world developer practices, SWE-Compass\nprovides a rigorous and reproducible foundation for diagnosing and advancing\nagentic coding capabilities in large language models."}
{"id": "2511.05476", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.05476", "abs": "https://arxiv.org/abs/2511.05476", "authors": ["Md. Abdul Awal", "Mrigank Rochan", "Chanchal K. Roy"], "title": "A Metamorphic Testing Perspective on Knowledge Distillation for Language Models of Code: Does the Student Deeply Mimic the Teacher?", "comment": "The paper is currently under review at a peer-reviewed journal", "summary": "Transformer-based language models of code have achieved state-of-the-art\nperformance across a wide range of software analytics tasks, but their\npractical deployment remains limited due to high computational costs, slow\ninference speeds, and significant environmental impact. To address these\nchallenges, recent research has increasingly explored knowledge distillation as\na method for compressing a large language model of code (the teacher) into a\nsmaller model (the student) while maintaining performance. However, the degree\nto which a student model deeply mimics the predictive behavior and internal\nrepresentations of its teacher remains largely unexplored, as current\naccuracy-based evaluation provides only a surface-level view of model quality\nand often fails to capture more profound discrepancies in behavioral fidelity\nbetween the teacher and student models. To address this gap, we empirically\nshow that the student model often fails to deeply mimic the teacher model,\nresulting in up to 285% greater performance drop under adversarial attacks,\nwhich is not captured by traditional accuracy-based evaluation. Therefore, we\npropose MetaCompress, a metamorphic testing framework that systematically\nevaluates behavioral fidelity by comparing the outputs of teacher and student\nmodels under a set of behavior-preserving metamorphic relations. We evaluate\nMetaCompress on two widely studied tasks, using compressed versions of popular\nlanguage models of code, obtained via three different knowledge distillation\ntechniques: Compressor, AVATAR, and MORPH. The results show that MetaCompress\nidentifies up to 62% behavioral discrepancies in student models, underscoring\nthe need for behavioral fidelity evaluation within the knowledge distillation\npipeline and establishing MetaCompress as a practical framework for testing\ncompressed language models of code derived through knowledge distillation."}
