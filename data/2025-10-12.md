<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 9]
- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Modeling Developer Burnout with GenAI Adoption](https://arxiv.org/abs/2510.07435)
*Zixuan Feng,Sadia Afroz,Anita Sarma*

Main category: cs.SE

TL;DR: GenAI's adoption in software development may worsen developer burnout through increased job demands, but supportive work environments and positive outlooks on GenAI can help alleviate these risks.


<details>
  <summary>Details</summary>
Motivation: While GenAI can boost productivity, there are concerns it may negatively impact developers' well-being by increasing pressure and burnout.

Method: A concurrent embedded mixed-methods research design combining quantitative (survey of 442 developers, PLS-SEM and regression modeling) and qualitative (open-ended responses) approaches.

Result: The study finds that the adoption of GenAI intensifies burnout due to increased job demands. Nonetheless, job resources and favorable attitudes toward GenAI help to offset these negative outcomes.

Conclusion: GenAI adoption increases developer burnout by raising job demands; however, strong job resources and positive perceptions of GenAI can help mitigate this effect.

Abstract: Generative AI (GenAI) is rapidly reshaping software development workflows.
While prior studies emphasize productivity gains, the adoption of GenAI also
introduces new pressures that may harm developers' well-being. In this paper,
we investigate the relationship between the adoption of GenAI and developers'
burnout. We utilized the Job Demands--Resources (JD--R) model as the analytic
lens in our empirical study. We employed a concurrent embedded mixed-methods
research design, integrating quantitative and qualitative evidence. We first
surveyed 442 developers across diverse organizations, roles, and levels of
experience. We then employed Partial Least Squares--Structural Equation
Modeling (PLS-SEM) and regression to model the relationships among job demands,
job resources, and burnout, complemented by a qualitative analysis of
open-ended responses to contextualize the quantitative findings. Our results
show that GenAI adoption heightens burnout by increasing job demands, while job
resources and positive perceptions of GenAI mitigate these effects, reframing
adoption as an opportunity.

</details>


### [2] [HotBugs.jar: A Benchmark of Hot Fixes for Time-Critical Bugs](https://arxiv.org/abs/2510.07529)
*Carol Hanna,Federica Sarro,Mark Harman,Justyna Petke*

Main category: cs.SE

TL;DR: The paper introduces HotBugs.jar, the first benchmark dataset focused on urgent real-world hot fixes in software. It compiles 679 validated hot fixes, with 110 reproducible cases, to support research on rapid debugging and automated repair. Its adoption by a major conference confirms its impact.


<details>
  <summary>Details</summary>
Motivation: Hot fixes are urgent and critical in software maintenance, but there lacks a specialized benchmark for their evaluation, making it difficult to study and improve related tools and techniques.

Method: The authors mined 10 active Apache projects for over 190,000 commits and 150,000 issue reports. They identified software patches that met hot-fix criteria, performed manual evaluation to validate real hot fixes, and systematically processed the data using Jira issue records. They then prepared a reproducible dataset with buggy/fixed code, test suites, and metadata.

Result: They produced HotBugs.jar: 679 manually validated hot fixes (from 746 candidates), with 110 reproducible cases packaged for research use. The dataset includes comprehensive metadata and reproducibility for each case.

Conclusion: HotBugs.jar is the first dedicated real-world hot fixes benchmark. It facilitates evaluation and improvement of debugging, automated repair, and resilience tools. Its adoption by the SBSE Conference Challenge Track confirms its immediate relevance and impact.

Abstract: Hot fixes are urgent, unplanned changes deployed to production systems to
address time-critical issues. Despite their importance, no existing evaluation
benchmark focuses specifically on hot fixes. We present HotBugs$.$jar, the
first dataset dedicated to real-world hot fixes. From an initial mining of 10
active Apache projects totaling over 190K commits and 150K issue reports, we
identified 746 software patches that met our hot-fix criteria. After manual
evaluation, 679 were confirmed as genuine hot fixes, of which 110 are
reproducible using a test suite. Building upon the Bugs$.$jar framework,
HotBugs$.$jar integrates these 110 reproducible cases and makes available all
679 manually validated hot fixes, each enriched with comprehensive metadata to
support future research. Each hot fix was systematically identified using Jira
issue data, validated by independent reviewers, and packaged in a reproducible
format with buggy and fixed versions, test suites, and metadata. HotBugs$.$jar
has already been adopted as the official challenge dataset for the Search-Based
Software Engineering (SBSE) Conference Challenge Track, demonstrating its
immediate impact. This benchmark enables the study and evaluation of tools for
rapid debugging, automated repair, and production-grade resilience in modern
software systems to drive research in this essential area forward.

</details>


### [3] [RustAssure: Differential Symbolic Testing for LLM-Transpiled C-to-Rust Code](https://arxiv.org/abs/2510.07604)
*Yubo Bai,Tapti Palit*

Main category: cs.SE

TL;DR: RustAssure uses LLMs and prompt engineering to automatically transpile C code to Rust, achieving high rates of compilable and semantically equivalent results, thus supporting secure migration from C to Rust.


<details>
  <summary>Details</summary>
Motivation: There is a significant need to improve software security by transitioning codebases from memory-unsafe languages like C to safer languages like Rust. Manual rewriting or traditional transpilation is laborious and error-prone, motivating an automated approach.

Method: The paper introduces RustAssure, a system that leverages Large Language Models (LLMs) with customized prompt engineering to transpile C codebases to idiomatic and safe Rust. In addition, it applies differential symbolic testing to compare semantic equivalence between the original C and transpiled Rust code.

Result: RustAssure successfully generated compilable Rust code for 89.8% of C functions across five evaluated real-world projects. 69.9% of those Rust functions were also proven to produce equivalent symbolic return values as their original C counterparts.

Conclusion: RustAssure demonstrates that LLM-based transpilation from C to Rust is feasible and effective in producing a high rate of correct and semantically equivalent Rust code. Its prompt engineering and semantic testing components significantly enhance the reliability and security of the automated transpilation process.

Abstract: Rust is a memory-safe programming language that significantly improves
software security. Existing codebases written in unsafe memory languages, such
as C, must first be transpiled to Rust to take advantage of Rust's improved
safety guarantees. RustAssure presents a system that uses Large Language Models
(LLMs) to automatically transpile existing C codebases to Rust. RustAssure uses
prompt engineering techniques to maximize the chances of the LLM generating
idiomatic and safe Rust code. Moreover, because LLMs often generate code with
subtle bugs that can be missed under traditional unit or fuzz testing,
RustAssure performs differential symbolic testing to establish the semantic
similarity between the original C and LLM-transpiled Rust code. We evaluated
RustAssure with five real-world applications and libraries, and showed that our
system is able to generate compilable Rust functions for 89.8% of all C
functions, of which 69.9% produced equivalent symbolic return values for both
the C and Rust functions.

</details>


### [4] [AppForge: From Assistant to Independent Developer -- Are GPTs Ready for Software Development?](https://arxiv.org/abs/2510.07740)
*Dezhi Ran,Yuan Cao,Mengzhou Wu,Simin Chen,Yuzhe Guo,Jun Ren,Zihe Song,Hao Yu,Jialei Wei,Linyi Li,Wei Yang,Baishakhi Ray,Tao Xie*

Main category: cs.SE

TL;DR: APPFORGE presents a rigorous new benchmark for evaluating LLMs on real-world, whole-app development tasks, showing current models struggle badly with multi-component software engineering challenges.


<details>
  <summary>Details</summary>
Motivation: Existing benchmarks only evaluate LLMs on isolated function-level code generation, which does not reflect the complexity of real-world software engineering tasks. There is a need to assess whether LLMs can orchestrate complete software systems, not just isolated components.

Method: The authors developed APPFORGE, a benchmark of 101 real-world Android app development problems. They used a multi-agent system to extract app functionalities, synthesize test cases, and constructed an automated evaluation framework for reproducibility. Manual expert verification was employed for rigor.

Result: Out of 12 major LLMs tested (including GPT-5), even the highest-performing model achieved only 18.8% functionally correct app implementations, revealing significant gaps in current LLM technology for full-system software engineering.

Conclusion: Current large language models are fundamentally limited in their ability to generate entire, functionally correct software systems from scratch, especially for complex and real-world applications such as Android apps.

Abstract: Large language models (LLMs) have demonstrated remarkable capability in
function-level code generation tasks. Unlike isolated functions, real-world
applications demand reasoning over the entire software system: developers must
orchestrate how different components interact, maintain consistency across
states over time, and ensure the application behaves correctly within the
lifecycle and framework constraints. Yet, no existing benchmark adequately
evaluates whether LLMs can bridge this gap and construct entire software
systems from scratch. To address this gap, we propose APPFORGE, a benchmark
consisting of 101 software development problems drawn from real-world Android
apps. Given a natural language specification detailing the app functionality, a
language model is tasked with implementing the functionality into an Android
app from scratch. Developing an Android app from scratch requires understanding
and coordinating app states, lifecycle management, and asynchronous operations,
calling for LLMs to generate context-aware, robust, and maintainable code. To
construct APPFORGE, we design a multi-agent system to automatically summarize
the main functionalities from app documents and navigate the app to synthesize
test cases validating the functional correctness of app implementation.
Following rigorous manual verification by Android development experts, APPFORGE
incorporates the test cases within an automated evaluation framework that
enables reproducible assessment without human intervention, making it easily
adoptable for future research. Our evaluation on 12 flagship LLMs show that all
evaluated models achieve low effectiveness, with the best-performing model
(GPT-5) developing only 18.8% functionally correct applications, highlighting
fundamental limitations in current models' ability to handle complex,
multi-component software engineering challenges.

</details>


### [5] [Interleaved Learning and Exploration: A Self-Adaptive Fuzz Testing Framework for MLIR](https://arxiv.org/abs/2510.07815)
*Zeyu Sun,Jingjing Liang,Weiyi Wang,Chenyao Suo,Junjie Chen,Fanjiang Xu*

Main category: cs.SE

TL;DR: FLEX is a novel neural network-based fuzzing tool for MLIR that greatly improves bug detection and code coverage compared to existing fuzzers, thanks to adaptive learning and diversity-focused strategies.


<details>
  <summary>Details</summary>
Motivation: MLIR is widely used in modern compiler frameworks, but verifying its correctness is difficult due to the lack of effective, diverse, and semantically valid test case generation tools. Existing fuzzing methods do not adequately expose deep or subtle bugs.

Method: The paper introduces FLEX, a self-adaptive fuzzing framework for MLIR. FLEX uses neural networks for generating programs, employs a perturbed sampling strategy to boost diversity, and integrates a feedback-based augmentation loop that iteratively refines its model based on all test outcomes.

Result: FLEX was evaluated against four state-of-the-art fuzzers on the MLIR compiler. Over 30 days, it uncovered 80 previously unknown bugs (including new parser and root cause bugs). In 24-hour tests, FLEX found 53 bugs (over 3.5 times more than the best alternative) and achieved 28.2% code coverage, outperforming the next-best tool by 42%.

Conclusion: FLEX significantly advances MLIR fuzzing by improving bug discovery and code coverage through adaptive learning, perturbed generation, and diversity augmentation. Both the novel generation and feedback techniques are crucial to its superior performance.

Abstract: MLIR (Multi-Level Intermediate Representation) has rapidly become a
foundational technology for modern compiler frameworks, enabling extensibility
across diverse domains. However, ensuring the correctness and robustness of
MLIR itself remains challenging. Existing fuzzing approaches-based on manually
crafted templates or rule-based mutations-struggle to generate sufficiently
diverse and semantically valid test cases, making it difficult to expose subtle
or deep-seated bugs within MLIR's complex and evolving code space. In this
paper, we present FLEX, a novel self-adaptive fuzzing framework for MLIR. FLEX
leverages neural networks for program generation, a perturbed sampling strategy
to encourage diversity, and a feedback-driven augmentation loop that
iteratively improves its model using both crashing and non-crashing test cases.
Starting from a limited seed corpus, FLEX progressively learns valid syntax and
semantics and autonomously produces high-quality test inputs. We evaluate FLEX
on the upstream MLIR compiler against four state-of-the-art fuzzers. In a
30-day campaign, FLEX discovers 80 previously unknown bugs-including multiple
new root causes and parser bugs-while in 24-hour fixed-revision comparisons, it
detects 53 bugs (over 3.5x as many as the best baseline) and achieves 28.2%
code coverage, outperforming the next-best tool by 42%. Ablation studies
further confirm the critical role of both perturbed generation and diversity
augmentation in FLEX's effectiveness.

</details>


### [6] [Bug Histories as Sources of Compiler Fuzzing Mutators](https://arxiv.org/abs/2510.07834)
*Lingjun Liu,Feiran Qin,Owolabi Legunsen,Marcelo d'Amorim*

Main category: cs.SE

TL;DR: The paper presents IssueMut, a system that mines mutators from compiler bug reports to improve fuzzing. It significantly enhances compiler bug finding by uncovering bugs missed by traditional fuzzers and underscores the value of bug history exploitation.


<details>
  <summary>Details</summary>
Motivation: Compiler bugs are highly impactful, and existing mutational fuzzers may miss bugs due to limited mutator diversity. Bug reports offer insights into triggering elements of past bugs, which can help guide fuzzers to uncover similar issues.

Method: The authors developed IssueMut, an automated approach to extract mutators from compiler bug reports and integrate them into existing fuzzers. They mined 587 mutators from 1760 bug reports in GCC and LLVM compilers and assessed their impact on bug discovery.

Result: IssueMut-derived mutators enabled the discovery of new bugs that existing state-of-the-art fuzzers missed (28 in GCC and 37 in LLVM). 60 of the discovered bugs were confirmed or fixed, demonstrating the approach's effectiveness.

Conclusion: Bug histories provide valuable information for creating effective compiler fuzzing mutators, and mining these histories can significantly improve bug detection.

Abstract: Bugs in compilers, which are critical infrastructure today, can have outsized
negative impacts. Mutational fuzzers aid compiler bug detection by
systematically mutating compiler inputs, i.e., programs. Their effectiveness
depends on the quality of the mutators used. Yet, no prior work used compiler
bug histories as a source of mutators. We propose IssueMut, the first approach
for extracting compiler fuzzing mutators from bug histories. Our insight is
that bug reports contain hints about program elements that induced compiler
bugs; they can guide fuzzers towards similar bugs. IssueMut uses an automated
method to mine mutators from bug reports and retrofit such mutators into
existing mutational compiler fuzzers. Using IssueMut, we mine 587 mutators from
1760 GCC and LLVM bug reports. Then, we run IssueMut on these compilers, with
all their test inputs as seed corpora. We find that "bug history" mutators are
effective: they find new bugs that a state-of-the-art mutational compiler
fuzzer misses-28 in GCC and 37 in LLVM. Of these, 60 were confirmed or fixed,
validating our idea that bug histories have rich information that compiler
fuzzers should leverage.

</details>


### [7] [An AUTOSAR-Aligned Architectural Study of Vulnerabilities in Automotive SoC Software](https://arxiv.org/abs/2510.07941)
*Srijita Basu,Haraldsson Bengt,Miroslaw Staron,Christian Berger,Jennifer Horkoff,Magnus Almgren*

Main category: cs.SE

TL;DR: This paper systematically analyzes 180 automotive SoC vulnerabilities within AUTOSAR-aligned software architectures, uncovering main root causes, critical modules with delayed patches, and trends in vulnerability mitigation. The work offers specific recommendations to enhance security management in automotive cyber-physical systems.


<details>
  <summary>Details</summary>
Motivation: CCAM systems are increasingly relying on complex SoC architectures in safety-critical environments. Despite standardized approaches like AUTOSAR, security challenges persist, particularly regarding SoC vulnerabilities. There is a lack of systematic root cause analysis and understanding of how these vulnerabilities affect AUTOSAR-aligned architectures.

Method: The study analyzes 180 publicly reported automotive SoC vulnerabilities by mapping them to a representative SoC software architecture model that aligns with AUTOSAR layered abstraction and service orientation. The analysis involves identifying root causes, affected software modules, and measuring mitigation delays across CWE categories and architectural layers.

Result: The study identifies 16 root causes and 56 affected software modules. It reveals dominant vulnerability patterns, critical modules with prolonged patch delays, and mitigation trends across software architectural layers and CWE categories.

Conclusion: The research provides actionable security insights, including guides for improved detection, prioritization, and localization strategies specific to SoC-based vehicle platforms. These findings aim to address and reduce security risks in automotive CPS platforms, facilitating better protection and system reliability.

Abstract: Cooperative, Connected and Automated Mobility (CCAM) are complex
cyber-physical systems (CPS) that integrate computation, communication, and
control in safety-critical environments. At their core, System-on-Chip (SoC)
platforms consolidate processing units, communication interfaces, AI
accelerators, and security modules into a single chip. AUTOSAR (AUTomotive Open
System ARchitecture) standard was developed in the automotive domain to better
manage this complexity, defining layered software structures and interfaces to
facilitate reuse of HW/SW components. However, in practice, this integrated SoC
software architecture still poses security challenges, particularly in
real-time, safety-critical environments. Recent reports highlight a surge in
SoC-related vulnerabilities, yet systematic analysis of their root causes and
impact within AUTOSAR-aligned architectures is lacking. This study fills that
gap by analyzing 180 publicly reported automotive SoC vulnerabilities, mapped
to a representative SoC software architecture model that is aligned with
AUTOSAR principles for layered abstraction and service orientation. We identify
16 root causes and 56 affected software modules, and examine mitigation delays
across Common Weakness Enumeration (CWE) categories and architectural layers.
We uncover dominant vulnerability patterns and critical modules with prolonged
patch delays, and provide actionable insights for securing automotive CPS
platforms, including guides for improved detection, prioritization, and
localization strategies for SoC software architectures in SoC-based vehicle
platforms.

</details>


### [8] [Past, Present, and Future of Bug Tracking in the Generative AI Era](https://arxiv.org/abs/2510.08005)
*Utku Boran Torun,Mehmet Taha Demircan,Mahmut Furkan Gön,Eray Tüzün*

Main category: cs.SE

TL;DR: The paper introduces an AI-driven bug tracking framework that automates reporting, triaging, and fixing using LLMs, greatly reducing response times and manual effort for a faster and better bug resolution process.


<details>
  <summary>Details</summary>
Motivation: Traditional bug tracking systems are slow due to manual processes, lack of coordination between different stakeholders, and a wide communication gap between technical and non-technical teams. These issues lead to delays and user frustration.

Method: The paper proposes an AI-powered bug tracking framework using large language models (LLMs) to automate and augment the current bug tracking workflow. The framework enables natural language reporting, automated report refinement, reproduction attempts, classification, no-code fixes for invalid reports, automated bug localization, assignment to developers, and candidate patch generation, all with human oversight.

Result: The framework reduces time-to-fix and human overhead by streamlining bug reporting and resolution processes. It integrates automation into every phase, leading to faster response times, improved collaboration, and more effective software maintenance.

Conclusion: The proposed AI-powered bug tracking system addresses major pain points in traditional systems by leveraging LLMs for automation, thereby improving efficiency and making the system more user-centric.

Abstract: Traditional bug tracking systems rely heavily on manual reporting,
reproduction, triaging, and resolution, each carried out by different
stakeholders such as end users, customer support, developers, and testers. This
division of responsibilities requires significant coordination and widens the
communication gap between non-technical users and technical teams, slowing the
process from bug discovery to resolution. Moreover, current systems are highly
asynchronous; users often wait hours or days for a first response, delaying
fixes and contributing to frustration. This paper examines the evolution of bug
tracking, from early paper-based reporting to today's web-based and SaaS
platforms. Building on this trajectory, we propose an AI-powered bug tracking
framework that augments existing tools with intelligent, large language model
(LLM)-driven automation. Our framework addresses two main challenges: reducing
time-to-fix and minimizing human overhead. Users report issues in natural
language, while AI agents refine reports, attempt reproduction, and request
missing details. Reports are then classified, invalid ones resolved through
no-code fixes, and valid ones localized and assigned to developers. LLMs also
generate candidate patches, with human oversight ensuring correctness. By
integrating automation into each phase, our framework accelerates response
times, improves collaboration, and strengthens software maintenance practices
for a more efficient, user-centric future.

</details>


### [9] [Building Whitespace-Sensitive Languages Using Whitespace-Insensitive Components](https://arxiv.org/abs/2510.08200)
*Alexander Hellwig,Nico Jansen,Bernhard Rumpe*

Main category: cs.SE

TL;DR: The paper introduces a preprocessing technique to enable modular construction of whitespace-sensitive languages using reusable, whitespace-insensitive components, and validates it via a Python reconstruction case study, thereby enhancing software language engineering reusability.


<details>
  <summary>Details</summary>
Motivation: There is a trend towards building software languages from reusable, modular components. However, integrating whitespace-sensitive and whitespace-insensitive languages remains challenging, limiting reusability and forcing developers to create whitespace-sensitive languages from scratch.

Method: The paper proposes a technique to build whitespace-sensitive languages using modular, whitespace-insensitive language components by preprocessing artifacts before parsing.

Result: The method is evaluated by re-constructing a simplified version of Python, demonstrating its effectiveness and robustness for the purpose.

Conclusion: This approach allows existing language components to be reused more readily, reducing development time and improving the quality of software languages by closing the gap between whitespace-sensitive and whitespace-insensitive modular language construction.

Abstract: In Software Language Engineering, there is a trend towards reusability by
composing modular language components. However, this reusability is severely
inhibited by a gap in integrating whitespace-sensitive and
whitespace-insensitive languages. There is currently no consistent procedure
for seamlessly reusing such language components in both cases, such that
libraries often cannot be reused, and whitespacesensitive languages are
developed from scratch. This paper presents a technique for using modular,
whitespaceinsensitive language modules to construct whitespace sensitive
languages by pre-processing language artifacts before parsing. The approach is
evaluated by reconstructing a simplified version of the programming language
Python. Our solution aims to increase the reusability of existing language
components to reduce development time and increase the overall quality of
software languages.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [10] [Type, Ability, and Effect Systems: Perspectives on Purity, Semantics, and Expressiveness](https://arxiv.org/abs/2510.07582)
*Yuyan Bao,Tiark Rompf*

Main category: cs.PL

TL;DR: This paper redefines purity and expressiveness for programming languages, showing that effect and capability systems are not dominant over one another. It proposes a combined type/effect/ability approach for better expressiveness and formalizes these ideas with a logical relation to aid proofs.


<details>
  <summary>Details</summary>
Motivation: Programming languages aim to separate pure computation from effectful interactions for clarity and reliability. Existing approaches (monads, type-and-effect systems, capability systems) struggle to balance precision and usability, and their comparative strengths and weaknesses are not fully understood.

Method: The paper proposes a semantic definition of purity using contextual equivalence, independent of any specific typing system. It introduces the idea of measuring expressiveness by the completeness with which pure terms are typed as pure. The authors analyze minimal effect and capability systems and their ability to type pure terms.

Result: The study finds that minimal effect and capability systems are incomparable; neither can fully subsume the expressiveness of the other. The authors propose a synthesis approach that combines type, ability, and effect systems to overcome individual weaknesses, supported by a formal model with logical relations for purity proofs.

Conclusion: No single existing approach completely covers the requirements for precise and usable separation of pure and effectful computation. A hybrid system combining aspects of type, ability, and effect systems is more robust. The proposed semantic purity definition and completeness measure provide new benchmarks for future research.

Abstract: Programming benefits from a clear separation between pure, mathematical
computation and impure, effectful interaction with the world. Existing
approaches to enforce this separation include monads, type-and-effect systems,
and capability systems. All share a tension between precision and usability,
and each one has non-obvious strengths and weaknesses.
  This paper aims to raise the bar in assessing such systems. First, we propose
a semantic definition of purity, inspired by contextual equivalence, as a
baseline independent of any specific typing discipline. Second, we propose that
expressiveness should be measured by the degree of completeness, i.e., how many
semantically pure terms can be typed as pure. Using this measure, we focus on
minimal meaningful effect and capability systems and show that they are
incomparable, i.e., neither subsumes the other in terms of expressiveness.
  Based on this result, we propose a synthesis and show that type, ability, and
effect systems combine their respective strengths while avoiding their
weaknesses. As part of our formal model, we provide a logical relation to
facilitate proofs of purity and other properties for a variety of effect typing
disciplines.

</details>


### [11] [The Functional Machine Calculus III: Control](https://arxiv.org/abs/2510.07851)
*Willem Heijltjes*

Main category: cs.PL

TL;DR: This paper presents an extension of the Functional Machine Calculus, allowing it to naturally embed imperative programming features (like loops, conditionals, exceptions) into the lambda calculus while preserving key properties such as typed termination and confluent reduction. Thus, it unifies functional and imperative paradigms operationally and semantically.


<details>
  <summary>Details</summary>
Motivation: Traditional lambda calculus and functional programming do not model imperative constructs like conditionals, loops, and exception handling naturally. Previous work presented a method of embedding computational effects and evaluation strategies, but lacked branching and looping control flow.

Method: The paper extends the Functional Machine Calculus by modifying operational semantics: it leverages an enhanced Krivine machine with multiple operand stacks for effects and a continuation stack for managing sequential, branching, and looping control flow. It introduces simple types to ensure strong normalization and termination (except for iteration).

Result: The extended calculus can faithfully embed a minimal but complete imperative language, including conditionals, exception handling, iteration, constants, and algebraic data types, while preserving typed termination and confluent reduction properties.

Conclusion: The Functional Machine Calculus provides a unified framework for functional and imperative programming models, supporting both computation paradigms via simple types, intuitive operational semantics, and confluent reduction.

Abstract: The Functional Machine Calculus (Heijltjes 2022) is a new approach to
unifying the imperative and functional programming paradigms. It extends the
lambda-calculus, preserving the key features of confluent reduction and typed
termination, to embed computational effects, evaluation strategies, and control
flow operations. The first instalment modelled sequential higher-order
computation with global store, input/output, probabilities, and
non-determinism, and embedded both the call-by-name and call-by-value
lambda-calculus, as well as Moggi's computational metalanguage and Levy's
call-by-push-value. The present paper extends the calculus from sequential to
branching and looping control flow. This allows the faithful embedding of a
minimal but complete imperative language, including conditionals, exception
handling, and iteration, as well as constants and algebraic data types.
  The calculus is defined through a simple operational semantics, extending the
(simplified) Krivine machine for the lambda-calculus with multiple operand
stacks to model effects and a continuation stack to model sequential,
branching, and looping computation. It features a confluent reduction relation
and a system of simple types that guarantees termination of the machine and
strong normalization of reduction (in the absence of iteration). These
properties carry over to the embedded imperative language, providing a unified
functional-imperative model of computation that supports simple types, a direct
and intuitive operational semantics, and a confluent reduction semantics.

</details>
