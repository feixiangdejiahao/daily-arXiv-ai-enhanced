{"id": "2510.25882", "categories": ["cs.SE", "D.2.9"], "pdf": "https://arxiv.org/pdf/2510.25882", "abs": "https://arxiv.org/abs/2510.25882", "authors": ["Wenhao Yang", "Minghui Zhou", "Daniel Izquierdo Cort\u00e1zar", "Yehui Wang"], "title": "Internal Vulnerabilities, External Threats: A Grounded Framework for Enterprise Open Source Risk Governance", "comment": null, "summary": "Enterprise engagement with open source has evolved from tactical adoption to\nstrategic deep integration, exposing them to a complex risk landscape far\nbeyond mere code. However, traditional risk management, narrowly focused on\ntechnical tools, is structurally inadequate for systemic threats like upstream\n\"silent fixes\", community conflicts, or sudden license changes, creating a\ndangerous governance blind spot. To address this governance vacuum and enable\nthe necessary shift from tactical risk management to holistic risk governance,\nwe conducted a grounded theory study with 15 practitioners to develop a\nholistic risk governance framework. Our study formalizes an analytical\nframework built on a foundational risk principle: an uncontrollable External\nThreat (e.g., a sudden license change in a key dependency) only becomes a\ncritical risk when it exploits a controllable Internal Vulnerability (e.g., an\nundefined risk appetite for single-vendor projects), which then amplifies the\nimpact.The framework operationalizes this principle through a clear logical\nchain: \"Objectives -> Threats -> Vulnerabilities -> Mitigation\" (OTVM). This\nprovides a holistic decision model that transcends mere technical checklists.\nBased on this logic, our contributions are: (1) a \"Strategic Objectives Matrix\"\nto clarify goals; (2) a systematic dual taxonomy of External Threats (Ex-Tech,\nEx-Comm, Ex-Eco) and Internal Vulnerabilities (In-Strat, In-Ops, In-Tech); and\n(3) an actionable mitigation framework mapping capability-building to these\nvulnerabilities. The framework's analytical utility was validated by three\nindustry experts through retrospective case studies on real-world incidents.\nThis work provides a novel diagnostic lens and a systematic path for\nenterprises to shift from reactive \"firefighting\" to proactively building an\norganizational \"immune system\".", "AI": {"tldr": "Traditional technical risk management is insufficient for open source risks in enterprises. The paper proposes a validated, holistic risk governance framework that enables organizations to address both external threats and internal vulnerabilities, moving from reactive to proactive risk management.", "motivation": "Enterprises face increasingly complex and systemic risks when deeply integrating open source, which are poorly addressed by traditional technical risk management tools. There is a pressing need for a holistic approach that considers both external threats and internal vulnerabilities.", "method": "A grounded theory study was conducted with 15 practitioners to develop the holistic risk governance framework. The framework was then validated by three industry experts through retrospective case studies on real-world incidents.", "result": "The study delivers an analytical framework (OTVM chain), a Strategic Objectives Matrix, dual taxonomy of external threats and internal vulnerabilities, and an actionable mitigation framework. These collectively offer a systematic model for enterprises to shift from reactive to proactive risk governance.", "conclusion": "The paper concludes that traditional risk management approaches in enterprises are inadequate to address the complex risks of deep open source integration, and proposes a holistic risk governance framework that enables organizations to proactively build resilience against systemic threats."}}
{"id": "2510.25890", "categories": ["cs.SE", "cs.AI", "D.2.4; I.2.2"], "pdf": "https://arxiv.org/pdf/2510.25890", "abs": "https://arxiv.org/abs/2510.25890", "authors": ["Tong Ma", "Hui Lai", "Hui Wang", "Zhenhu Tian", "Jizhou Wang", "Haichao Wu", "Yongfan Gao", "Chaochao Li", "Fengjie Xu", "Ling Fang"], "title": "PRISM: Proof-Carrying Artifact Generation through LLM x MDE Synergy and Stratified Constraints", "comment": "45 pages, 9 figures", "summary": "PRISM unifies Large Language Models with Model-Driven Engineering to generate\nregulator-ready artifacts and machine-checkable evidence for safety- and\ncompliance-critical domains. PRISM integrates three pillars: a Unified\nMeta-Model (UMM) reconciles heterogeneous schemas and regulatory text into a\nsingle semantic space; an Integrated Constraint Model (ICM) compiles structural\nand semantic requirements into enforcement artifacts including generation-time\nautomata (GBNF, DFA) and post-generation validators (e.g., SHACL, SMT); and\nConstraint-Guided Verifiable Generation (CVG) applies these through two-layer\nenforcement - structural constraints drive prefix-safe decoding while\nsemantic/logical validation produces machine-checkable certificates. When\nviolations occur, PRISM performs audit-guided repair and records generation\ntraces for compliance review. We evaluate PRISM in automotive software\nengineering (AUTOSAR) and cross-border legal jurisdiction (Brussels I bis).\nPRISM produces structurally valid, auditable artifacts that integrate with\nexisting tooling and substantially reduce manual remediation effort, providing\na practical path toward automated artifact generation with built-in assurance.", "AI": {"tldr": "PRISM is a framework that merges LLMs and model-driven engineering to automate the creation of compliant, auditable artifacts, using unified semantic models and constraint enforcement. Evaluations show its effectiveness in technical and legal domains, reducing the need for manual checks while ensuring regulatory compliance.", "motivation": "Automated generation of regulator-ready and machine-checkable artifacts in safety- and compliance-critical domains is challenging. There is a need for integrating LLMs with rigorous model-driven approaches to ensure both ease of artifact creation and regulatory assurance.", "method": "PRISM integrates Large Language Models with Model-Driven Engineering using three main components: a Unified Meta-Model for semantic reconciliation, an Integrated Constraint Model for compiling requirements into enforcement mechanisms (GBNF, DFA, SHACL, SMT), and Constraint-Guided Verifiable Generation using two-layer enforcement. It repairs violations and tracks generation traces for compliance.", "result": "PRISM was evaluated in domains such as automotive software (AUTOSAR) and cross-border legal jurisdictions (Brussels I bis). It successfully generated structurally valid, auditable artifacts compatible with existing tools and reduced manual remediation.", "conclusion": "PRISM demonstrates a practical approach to automated, regulator-ready artifact generation by combining LLMs with rigorous model-driven engineering, offering built-in assurance and substantial reduction in manual effort."}}
{"id": "2510.25935", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.25935", "abs": "https://arxiv.org/abs/2510.25935", "authors": ["Ant\u00eda Dorado", "Iv\u00e1n Folgueira", "Sof\u00eda Mart\u00edn", "Gonzalo Mart\u00edn", "\u00c1lvaro Porto", "Alejandro Ramos", "John Wallace"], "title": "A Process Mining-Based System For The Analysis and Prediction of Software Development Workflows", "comment": "16 pages, 7 figures, 4 tables", "summary": "CodeSight is an end-to-end system designed to anticipate deadline compliance\nin software development workflows. It captures development and deployment data\ndirectly from GitHub, transforming it into process mining logs for detailed\nanalysis. From these logs, the system generates metrics and dashboards that\nprovide actionable insights into PR activity patterns and workflow efficiency.\nBuilding on this structured representation, CodeSight employs an LSTM model\nthat predicts remaining PR resolution times based on sequential activity traces\nand static features, enabling early identification of potential deadline\nbreaches. In tests, the system demonstrates high precision and F1 scores in\npredicting deadline compliance, illustrating the value of integrating process\nmining with machine learning for proactive software project management.", "AI": {"tldr": "CodeSight combines GitHub activity tracking, process mining, and LSTM-based prediction to accurately forecast pull-request deadlines, helping teams spot potential overdue issues early and manage workflows more effectively.", "motivation": "Anticipating deadline breaches early in software development is crucial for proactive project management and workflow optimization.", "method": "CodeSight collects development and deployment data from GitHub, transforms it into process mining logs, extracts metrics, and uses an LSTM model to predict PR resolution times.", "result": "CodeSight system achieves high precision and F1 scores in predicting deadline compliance, providing actionable insights into PR activities and workflow efficiency.", "conclusion": "Integrating process mining and machine learning yields highly accurate predictions of deadline compliance in software development workflows."}}
{"id": "2510.26130", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.26130", "abs": "https://arxiv.org/abs/2510.26130", "authors": ["Musfiqur Rahman", "SayedHassan Khatoonabadi", "Emad Shihab"], "title": "Beyond Synthetic Benchmarks: Evaluating LLM Performance on Real-World Class-Level Code Generation", "comment": "Pre-print prepared for journal submission", "summary": "Large language models (LLMs) have advanced code generation at the function\nlevel, yet their ability to produce correct class-level implementations in\nauthentic software projects remains poorly understood. This work introduces a\nnovel benchmark derived from open-source repositories, comprising real-world\nclasses divided into seen and unseen partitions to evaluate generalization\nunder practical conditions. The evaluation examines multiple LLMs under varied\ninput specifications, retrieval-augmented configurations, and documentation\ncompleteness levels.\n  Results reveal a stark performance disparity: LLMs achieve 84% to 89%\ncorrectness on established synthetic benchmarks but only 25% to 34% on\nreal-world class tasks, with negligible differences between familiar and novel\ncodebases. Comprehensive docstrings yield modest gains of 1% to 3% in\nfunctional accuracy, though statistical significance is rare.\nRetrieval-augmented generation proves most effective with partial\ndocumentation, improving correctness by 4% to 7% by supplying concrete\nimplementation patterns absent from specifications. Error profiling identifies\nAttributeError, TypeError, and AssertionError as dominant failure modes (84% of\ncases), with synthetic tests overemphasizing assertion issues and real-world\nscenarios highlighting type and attribute mismatches. Retrieval augmentation\nreduces logical flaws but can introduce dependency conflicts.\n  The benchmark and analysis expose critical limitations in current LLM\ncapabilities for class-level engineering, offering actionable insights for\nenhancing context modelling, documentation strategies, and retrieval\nintegration in production code assistance tools.", "AI": {"tldr": "LLMs are good at function-level synthetic code but fail at real-world class-level tasks; retrieval and better docstrings help a bit, but major limitations remain in context handling and software engineering.", "motivation": "While LLMs excel at function-level code tasks, their class-level performance\u2014key for realistic software development\u2014is poorly understood and potentially overestimated by synthetic benchmarks. This motivates a real-world evaluation.", "method": "The paper introduces a benchmark with real-world classes from open-source repositories, divided into seen and unseen groups to test generalization. It evaluates various LLMs under different input specs, retrieval augmentation, and levels of documentation.", "result": "LLMs achieve high correctness (84-89%) on synthetic benchmarks but much lower rates (25-34%) on realistic class-level tasks. Retrieval-augmented generation with partial documentation offers some improvements. Main errors are attribute/type mismatches and assertion issues. Comprehensive docstrings yield minimal gains.", "conclusion": "Current LLMs show strong performance on synthetic benchmarks but struggle significantly on real-world class-level code generation, highlighting severe limitations in authentic software scenarios."}}
{"id": "2510.26016", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.26016", "abs": "https://arxiv.org/abs/2510.26016", "authors": ["Michael Arntzenius"], "title": "Fair intersection of seekable iterators", "comment": "8 pages, 2 figures, published in miniKanren 2025", "summary": "miniKanren's key semantic advance over Prolog is to implement a complete yet\nefficient search strategy, fairly interleaving execution between disjuncts.\nThis fairness is accomplished by bounding how much work is done exploring one\ndisjunct before switching to the next. We show that the same idea -- fairness\nvia bounded work -- underlies an elegant compositional approach to implementing\nworst-case optimal joins using a seekable iterator interface, suitable for\nshallow embedding in functional languages.", "AI": {"tldr": "The paper shows that the fairness technique from miniKanren's search strategy can be used to implement optimal join algorithms in a compositional way, using a seekable iterator interface.", "motivation": "Efficient and fair search and join algorithms are important for both logic programming and database query optimization, motivating the transfer of ideas between these fields.", "method": "The authors analyze the fairness achieved in miniKanren through bounded work, and show how this principle maps to compositional join algorithms using a seekable iterator interface.", "result": "The authors demonstrate that the bounded work/fairness strategy can lead to worst-case optimal, elegant, and composable join implementations, especially suited for shallow embedding in functional languages.", "conclusion": "The bounded work principle from miniKanren can be applied to build efficient and fair join operations, particularly in functional programming environments."}}
{"id": "2510.26171", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26171", "abs": "https://arxiv.org/abs/2510.26171", "authors": ["Hasnain Iqbal", "Zerina Begum", "Kazi Sakib"], "title": "Reduction of Test Re-runs by Prioritizing Potential Order Dependent Flaky Tests", "comment": null, "summary": "Flaky tests can make automated software testing unreliable due to their\nunpredictable behavior. These tests can pass or fail on the same code base on\nmultiple runs. However, flaky tests often do not refer to any fault, even\nthough they can cause the continuous integration (CI) pipeline to fail. A\ncommon type of flaky test is the order-dependent (OD) test. The outcome of an\nOD test depends on the order in which it is run with respect to other test\ncases. Several studies have explored the detection and repair of OD tests.\nHowever, their methods require re-runs of tests multiple times, that are not\nrelated to the order dependence. Hence, prioritizing potential OD tests is\nnecessary to reduce the re-runs. In this paper, we propose a method to\nprioritize potential order-dependent tests. By analyzing shared static fields\nin test classes, we identify tests that are more likely to be order-dependent.\nIn our experiment on 27 project modules, our method successfully prioritized\nall OD tests in 23 cases, reducing test executions by an average of 65.92% and\nunnecessary re-runs by 72.19%. These results demonstrate that our approach\nsignificantly improves the efficiency of OD test detection by lowering\nexecution costs.", "AI": {"tldr": "This paper proposes a way to identify and prioritize flaky, order-dependent tests by analyzing shared static fields, greatly reducing the need for repeated test executions and improving the efficiency of CI pipelines.", "motivation": "Flaky tests, especially order-dependent (OD) tests, compromise the reliability of automated software testing. Existing methods for OD test detection require excessive test re-runs, creating inefficiency and resource waste. The authors are motivated by the need to prioritize likely OD tests, thus reducing unnecessary test executions.", "method": "The paper introduces a method to prioritize potential order-dependent tests by analyzing shared static fields in test classes, thereby identifying tests with higher likelihood of order dependency before running them.", "result": "The experimental evaluation on 27 project modules found the method successfully prioritized all OD tests in 23 cases, reduced test executions by an average of 65.92%, and unnecessary re-runs by 72.19%.", "conclusion": "Prioritizing OD tests using static field analysis in test classes greatly improves OD test detection efficiency, lowers execution costs, and reduces test reruns, making automated testing pipelines more reliable."}}
{"id": "2510.26431", "categories": ["cs.SE", "cs.LO", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.26431", "abs": "https://arxiv.org/abs/2510.26431", "authors": ["Mih\u00e1ly Dobos-Kov\u00e1cs", "Levente Bajczi", "Andr\u00e1s V\u00f6r\u00f6s"], "title": "CHCVerif: A Portfolio-Based Solver for Constrained Horn Clauses", "comment": "In Proceedings HCVS 2025, arXiv:2510.25468", "summary": "Constrained Horn Clauses (CHCs) are widely adopted as intermediate\nrepresentations for a variety of verification tasks, including safety checking,\ninvariant synthesis, and interprocedural analysis. This paper introduces\nCHCVERIF, a portfolio-based CHC solver that adopts a software verification\napproach for solving CHCs. This approach enables us to reuse mature software\nverification tools to tackle CHC benchmarks, particularly those involving\nbitvectors and low-level semantics. Our evaluation shows that while the method\nenjoys only moderate success with linear integer arithmetic, it achieves modest\nsuccess on bitvector benchmarks. Moreover, our results demonstrate the\nviability and potential of using software verification tools as backends for\nCHC solving, particularly when supported by a carefully constructed portfolio.", "AI": {"tldr": "CHCVERIF is a portfolio CHC solver utilizing software verification tools, proving especially viable for bitvector-heavy benchmarks and highlighting a promising route for CHC solving research.", "motivation": "Constrained Horn Clauses (CHCs) are foundational in many verification tasks, but solving CHCs effectively\u2014especially those with challenging features like bitvectors\u2014remains difficult. Mature software verification tools may offer untapped value for this domain.", "method": "The paper introduces CHCVERIF, a portfolio-based CHC solver that harnesses established software verification tools to address CHC benchmarks, particularly those with bitvectors and low-level aspects.", "result": "CHCVERIF shows only moderate effectiveness with linear integer arithmetic CHC benchmarks but achieves modest success on benchmarks with bitvectors. It demonstrates that using software verification tools as CHC solvers is both viable and potentially promising, especially in a well-designed portfolio setting.", "conclusion": "Leveraging software verification tools within a portfolio-based framework (CHCVERIF) is a promising direction for CHC solving, showing particular utility for benchmarks involving low-level semantics like bitvectors."}}
{"id": "2510.26174", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26174", "abs": "https://arxiv.org/abs/2510.26174", "authors": ["Liming Dong", "Sung Une Lee", "Zhenchang Xing", "Muhammad Ejaz Ahmed", "Stefan Avgoustakis"], "title": "The \"4W+1H\" of Software Supply Chain Security Checklist for Critical Infrastructure", "comment": "18 pages, 4 figures", "summary": "The increasing frequency and sophistication of software supply chain attacks\npose severe risks to critical infrastructure sectors, threatening national\nsecurity, economic stability, and public safety. Despite growing awareness,\nexisting security practices remain fragmented and insufficient, with most\nframeworks narrowly focused on isolated life cycle stages or lacking alignment\nwith the specific needs of critical infrastructure (CI) sectors. In this paper,\nwe conducted a multivocal literature review across international frameworks,\nAustralian regulatory sources, and academic studies to identify and analyze\nsecurity practices across the software supply chain, especially specific CI\nsector. Our analysis found that few existing frameworks are explicitly tailored\nto CI domains. We systematically leveraged identified software supply chain\nsecurity frameworks, using a \"4W+1H\" analytical approach, we synthesized ten\ncore categories (what) of software supply chain security practices, mapped them\nacross life-cycle phases (when), stakeholder roles (who), and implementation\nlevels (how), and examined their coverage across existing frameworks (where).\nBuilding on these insights, the paper culminates in structured, multi-layered\nchecklist of 80 questions designed to relevant stakeholders evaluate and\nenhance their software supply chain security. Our findings reveal gaps between\nframework guidance and sector-specific needs, highlight the need for\nintegrated, context-aware approaches to safeguard critical infrastructure from\nevolving software supply chain risks.", "AI": {"tldr": "The paper reviews security practices for software supply chains in critical infrastructure, finds existing frameworks lacking, and offers a checklist to help stakeholders improve security, emphasizing the need for more tailored and integrated solutions.", "motivation": "Software supply chain attacks are becoming more frequent and sophisticated, posing significant risks to critical infrastructure sectors. Existing security frameworks are inadequate, either being fragmented or not addressing the specific needs of CI sectors.", "method": "The authors performed a multivocal literature review involving international frameworks, Australian regulatory sources, and academic studies. They used a '4W+1H' analytical approach to categorize and map software supply chain security practices.", "result": "The analysis identified ten core categories of practices, mapped them across phases, stakeholder roles, and implementation levels, culminating in an 80-question checklist for stakeholders. The study found notable gaps between framework guidance and sector-specific needs.", "conclusion": "There is a lack of context-aware, integrated security frameworks tailored for critical infrastructure sectors. The proposed checklist aims to help stakeholders better evaluate and enhance software supply chain security, but further integration and customization are needed."}}
{"id": "2510.26275", "categories": ["cs.SE", "cs.AI", "cs.ET", "cs.LG", "cs.MA"], "pdf": "https://arxiv.org/pdf/2510.26275", "abs": "https://arxiv.org/abs/2510.26275", "authors": ["Domenico Amalfitano", "Andreas Metzger", "Marco Autili", "Tommaso Fulcini", "Tobias Hey", "Jan Keim", "Patrizio Pelliccione", "Vincenzo Scotti", "Anne Koziolek", "Raffaela Mirandola", "Andreas Vogelsang"], "title": "A Research Roadmap for Augmenting Software Engineering Processes and Software Products with Generative AI", "comment": null, "summary": "Generative AI (GenAI) is rapidly transforming software engineering (SE)\npractices, influencing how SE processes are executed, as well as how software\nsystems are developed, operated, and evolved. This paper applies design science\nresearch to build a roadmap for GenAI-augmented SE. The process consists of\nthree cycles that incrementally integrate multiple sources of evidence,\nincluding collaborative discussions from the FSE 2025 \"Software Engineering\n2030\" workshop, rapid literature reviews, and external feedback sessions\ninvolving peers. McLuhan's tetrads were used as a conceptual instrument to\nsystematically capture the transforming effects of GenAI on SE processes and\nsoftware products.The resulting roadmap identifies four fundamental forms of\nGenAI augmentation in SE and systematically characterizes their related\nresearch challenges and opportunities. These insights are then consolidated\ninto a set of future research directions. By grounding the roadmap in a\nrigorous multi-cycle process and cross-validating it among independent author\nteams and peers, the study provides a transparent and reproducible foundation\nfor analyzing how GenAI affects SE processes, methods and tools, and for\nframing future research within this rapidly evolving area. Based on these\nfindings, the article finally makes ten predictions for SE in the year 2030.", "AI": {"tldr": "This paper presents a rigorously developed roadmap for how Generative AI will transform software engineering by 2030, identifying key areas of GenAI augmentation, research challenges, and making ten future predictions, all grounded in validated multi-source evidence.", "motivation": "Generative AI is rapidly changing software engineering practices, making it crucial to understand and systematically address how GenAI is transforming SE processes, products, and future research directions.", "method": "The paper uses a design science research methodology, conducting three iterative cycles: collaborative workshop discussions, rapid literature reviews, and peer feedback. McLuhan's tetrads are applied as a framework to analyze GenAI\u2019s impact on SE.", "result": "The roadmap identifies four key forms of GenAI augmentation in SE, detailing associated research challenges and opportunities. These are further distilled into actionable future research directions. Validation was conducted through cross-team and peer review.", "conclusion": "The study provides a systematic, transparent foundation for understanding and predicting the influence of GenAI on software engineering practices and research, presenting ten predictions for SE by 2030."}}
{"id": "2510.26287", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26287", "abs": "https://arxiv.org/abs/2510.26287", "authors": ["Guochang Li", "Yuchen Liu", "Zhen Qin", "Yunkun Wang", "Jianping Zhong", "Chen Zhi", "Binhua Li", "Fei Huang", "Yongbin Li", "Shuiguang Deng"], "title": "Empowering RepoQA-Agent based on Reinforcement Learning Driven by Monte-carlo Tree Search", "comment": null, "summary": "Repository-level software engineering tasks require large language models\n(LLMs) to efficiently navigate and extract information from complex codebases\nthrough multi-turn tool interactions. Existing approaches face significant\nlimitations: training-free, in-context learning methods struggle to guide\nagents effectively in tool utilization and decision-making based on\nenvironmental feedback, while training-based approaches typically rely on\ncostly distillation from larger LLMs, introducing data compliance concerns in\nenterprise environments. To address these challenges, we introduce\nRepoSearch-R1, a novel agentic reinforcement learning framework driven by\nMonte-carlo Tree Search (MCTS). This approach allows agents to generate\ndiverse, high-quality reasoning trajectories via self-training without\nrequiring model distillation or external supervision. Based on RepoSearch-R1,\nwe construct a RepoQA-Agent specifically designed for repository\nquestion-answering tasks. Comprehensive evaluation on repository\nquestion-answering tasks demonstrates that RepoSearch-R1 achieves substantial\nimprovements of answer completeness: 16.0% enhancement over no-retrieval\nmethods, 19.5% improvement over iterative retrieval methods, and 33% increase\nin training efficiency compared to general agentic reinforcement learning\napproaches. Our cold-start training methodology eliminates data compliance\nconcerns while maintaining robust exploration diversity and answer completeness\nacross repository-level reasoning tasks.", "AI": {"tldr": "RepoSearch-R1 uses MCTS-based reinforcement learning to enable repository question-answering agents that outperform baseline methods in completeness and efficiency, while avoiding compliance issues commonly found in distillation-based models.", "motivation": "Existing methods for repository-level software engineering tasks using large language models struggle with efficient tool use, decision-making, and feedback incorporation. Training-free in-context methods lack guidance capabilities, while training-based approaches depend on costly distillation processes and raise data compliance issues, especially for enterprise use.", "method": "The authors propose RepoSearch-R1, an agentic reinforcement learning framework powered by Monte-Carlo Tree Search (MCTS). This framework enables agents to self-train by generating diverse reasoning trajectories, without requiring model distillation or external supervision. They build RepoQA-Agent, tailored for repository question-answering, using this framework.", "result": "RepoSearch-R1 demonstrates notable improvements: a 16% increase in answer completeness over methods without retrieval, a 19.5% improvement over iterative retrieval, and a 33% boost in training efficiency versus general agentic reinforcement learning techniques. Their cold-start training removes data compliance risks while achieving diverse exploration and comprehensive answers.", "conclusion": "RepoSearch-R1 effectively addresses limitations of existing LLM-based solutions for repository-level tasks, offering improved completeness, efficiency, and compliance safety via its agentic reinforcement learning approach."}}
{"id": "2510.26413", "categories": ["cs.SE", "cs.DC"], "pdf": "https://arxiv.org/pdf/2510.26413", "abs": "https://arxiv.org/abs/2510.26413", "authors": ["Nuno Saavedra", "Alexandra Mendes", "Jo\u00e3o F. Ferreira"], "title": "Environmental Impact of CI/CD Pipelines", "comment": "This work has been submitted to the IEEE for possible publication", "summary": "CI/CD pipelines are widely used in software development, yet their\nenvironmental impact, particularly carbon and water footprints (CWF), remains\nlargely unknown to developers, as CI service providers typically do not\ndisclose such information. With the growing environmental impact of cloud\ncomputing, understanding the CWF of CI/CD services has become increasingly\nimportant.\n  This work investigates the CWF of using GitHub Actions, focusing on\nopen-source repositories where usage is free and unlimited for standard\nrunners. We build upon a methodology from the Cloud Carbon Footprint framework\nand we use the largest dataset of workflow runs reported in the literature to\ndate, comprising over 2.2 million workflow runs from more than 18,000\nrepositories.\n  Our analysis reveals that the GitHub Actions ecosystem results in a\nsubstantial CWF. Our estimates for the carbon footprint in 2024 range from\n150.5 MTCO2e in the most optimistic scenario to 994.9 MTCO2e in the most\npessimistic scenario, while the water footprint ranges from 1,989.6 to 37,664.5\nkiloliters. The most likely scenario estimates are 456.9 MTCO2e for carbon\nfootprint and 5,738.2 kiloliters for water footprint. To provide perspective,\nthe carbon footprint in the most likely scenario is equivalent to the carbon\ncaptured by 7,615 urban trees in a year, and the water footprint is comparable\nto the water consumed by an average American family over 5,053 years.\n  We explore strategies to mitigate this impact, primarily by reducing wasted\ncomputational resources. Key recommendations include deploying runners in\nregions whose energy production has a low environmental impact such as France\nand the United Kingdom, implementing stricter deactivation policies for\nscheduled runs and aligning their execution with periods when the regional\nenergy mix is more environmentally favorable, and reducing the size of\nrepositories.", "AI": {"tldr": "The paper quantifies the hidden environmental costs of using GitHub Actions (CI/CD pipelines), highlighting significant carbon and water footprints and proposing practical mitigation strategies like better runner placement, stricter job management, and repository optimization.", "motivation": "Developers use CI/CD pipelines extensively, but they lack information about the environmental impacts (carbon and water footprints) associated with these cloud-based services, as providers rarely publish this data. With cloud computing's environmental effects on the rise, quantifying and understanding these impacts for popular CI/CD services has become urgent.", "method": "The authors adapt methodologies from the Cloud Carbon Footprint framework and analyze a large dataset covering 2.2 million GitHub Actions workflow runs across 18,000 repositories. They estimate the environmental impact by calculating carbon and water footprints under different scenarios.", "result": "The analysis found that GitHub Actions' carbon footprint in 2024 ranges from 150.5 MTCO2e (optimistic) to 994.9 MTCO2e (pessimistic), with the most likely at 456.9 MTCO2e. The water footprint ranges from 1,989.6 to 37,664.5 kiloliters, with the most likely estimate being 5,738.2 kiloliters. These numbers were contextualized against everyday environmental benchmarks.", "conclusion": "GitHub Actions has a substantial carbon and water footprint. Developers and CI/CD stakeholders can reduce this impact by choosing regions with cleaner energy, deactivating unnecessary scheduled runs, timing executions when energy mixes are favorable, and reducing repository sizes. These strategies help to minimize the environmental cost of automated software workflows."}}
{"id": "2510.26423", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.26423", "abs": "https://arxiv.org/abs/2510.26423", "authors": ["Dong Huang", "Mingzhe Du", "Jie M. Zhang", "Zheng Lin", "Meng Luo", "Qianru Zhang", "See-Kiong Ng"], "title": "Nexus: Execution-Grounded Multi-Agent Test Oracle Synthesis", "comment": "Under Review", "summary": "Test oracle generation in non-regression testing is a longstanding challenge\nin software engineering, where the goal is to produce oracles that can\naccurately determine whether a function under test (FUT) behaves as intended\nfor a given input. In this paper, we introduce Nexus, a novel multi-agent\nframework to address this challenge. Nexus generates test oracles by leveraging\na diverse set of specialized agents that synthesize test oracles through a\nstructured process of deliberation, validation, and iterative self-refinement.\nDuring the deliberation phase, a panel of four specialist agents, each\nembodying a distinct testing philosophy, collaboratively critiques and refines\nan initial set of test oracles. Then, in the validation phase, Nexus generates\na plausible candidate implementation of the FUT and executes the proposed\noracles against it in a secure sandbox. For any oracle that fails this\nexecution-based check, Nexus activates an automated selfrefinement loop, using\nthe specific runtime error to debug and correct the oracle before\nre-validation. Our extensive evaluation on seven diverse benchmarks\ndemonstrates that Nexus consistently and substantially outperforms\nstate-of-theart baselines. For instance, Nexus improves the test-level oracle\naccuracy on the LiveCodeBench from 46.30% to 57.73% for GPT-4.1-Mini. The\nimproved accuracy also significantly enhances downstream tasks: the bug\ndetection rate of GPT4.1-Mini generated test oracles on HumanEval increases\nfrom 90.91% to 95.45% for Nexus compared to baselines, and the success rate of\nautomated program repair improves from 35.23% to 69.32%.", "AI": {"tldr": "Nexus, a multi-agent framework, improves non-regression test oracle generation through collaborative refinement and validation, outperforming existing methods in accuracy, bug detection, and program repair rates.", "motivation": "Test oracle generation in non-regression testing is challenging, as it is difficult to produce oracles that accurately determine whether a program behaves correctly for a given input.", "method": "Nexus is introduced as a multi-agent framework. It uses four specialist agents to deliberate and refine test oracles, validates them by executing candidate implementations in a sandbox, and iteratively refines failing oracles using observed errors.", "result": "Nexus significantly outperforms state-of-the-art baselines in oracle accuracy: for LiveCodeBench, test-level accuracy improves from 46.30% to 57.73%. Bug detection rates and automated program repair success rates also notably increase.", "conclusion": "Nexus presents an effective approach to generating highly accurate, self-improving test oracles for non-regression testing, surpassing previous methods in both accuracy and downstream task performance."}}
{"id": "2510.26457", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.26457", "abs": "https://arxiv.org/abs/2510.26457", "authors": ["Fang Liu", "Simiao Liu", "Yinghao Zhu", "Xiaoli Lian", "Li Zhang"], "title": "SecureReviewer: Enhancing Large Language Models for Secure Code Review through Secure-aware Fine-tuning", "comment": "Accepted by ICSE 2026. Code and data:\n  https://github.com/SIMIAO515/SecureReviewer", "summary": "Identifying and addressing security issues during the early phase of the\ndevelopment lifecycle is critical for mitigating the long-term negative impacts\non software systems. Code review serves as an effective practice that enables\ndevelopers to check their teammates' code before integration into the codebase.\nTo streamline the generation of review comments, various automated code review\napproaches have been proposed, where LLM-based methods have significantly\nadvanced the capabilities of automated review generation. However, existing\nmodels primarily focus on general-purpose code review, their effectiveness in\nidentifying and addressing security-related issues remains underexplored.\nMoreover, adapting existing code review approaches to target security issues\nfaces substantial challenges, including data scarcity and inadequate evaluation\nmetrics. To address these limitations, we propose SecureReviewer, a new\napproach designed for enhancing LLMs' ability to identify and resolve\nsecurity-related issues during code review. Specifically, we first construct a\ndataset tailored for training and evaluating secure code review capabilities.\nLeveraging this dataset, we fine-tune LLMs to generate code review comments\nthat can effectively identify security issues and provide fix suggestions with\nour proposed secure-aware fine-tuning strategy. To mitigate hallucination in\nLLMs and enhance the reliability of their outputs, we integrate the RAG\ntechnique, which grounds the generated comments in domain-specific security\nknowledge. Additionally, we introduce SecureBLEU, a new evaluation metric\ndesigned to assess the effectiveness of review comments in addressing security\nissues. Experimental results demonstrate that SecureReviewer outperforms\nstate-of-the-art baselines in both security issue detection accuracy and the\noverall quality and practical utility of generated review comments.", "AI": {"tldr": "SecureReviewer is a novel LLM-based automated code review tool tailored for security issues. With a specialized dataset, knowledge grounding (RAG), and the SecureBLEU metric, it delivers superior security detection and comment quality compared to existing methods.", "motivation": "Existing automated code review tools are not effective at detecting and addressing security-related issues, mainly due to their general-purpose design, lack of domain-specific datasets, and inadequate evaluation metrics. There is a need for methods that specifically target security concerns during the code review process.", "method": "The authors propose SecureReviewer, which fine-tunes large language models (LLMs) on a specially constructed dataset for secure code review. Their method includes a secure-aware fine-tuning strategy, integrates Retrieval-Augmented Generation (RAG) for grounding outputs in security knowledge, and introduces SecureBLEU, a metric that measures the effectiveness of comments in addressing security issues.", "result": "SecureReviewer, the proposed system, achieves superior performance compared to existing baselines. It generates review comments that are more accurate in detecting security issues and providing practical fix suggestions, as shown by improvements in both detection accuracy and the quality of review comments.", "conclusion": "SecureReviewer advances automated code review for security-related issues by leveraging fine-tuned LLMs, RAG for knowledge grounding, and introducing a new evaluation metric (SecureBLEU), demonstrating clear improvements over existing solutions in security issue detection and comment quality."}}
{"id": "2510.26480", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26480", "abs": "https://arxiv.org/abs/2510.26480", "authors": ["Sivajeet Chand", "Melih Kilic", "Roland W\u00fcrsching", "Sushant Kumar Pandey", "Alexander Pretschner"], "title": "Automated Extract Method Refactoring with Open-Source LLMs: A Comparative Study", "comment": "Accepted at AIware'25 - Main Track", "summary": "Automating the Extract Method refactoring (EMR) remains challenging and\nlargely manual despite its importance in improving code readability and\nmaintainability. Recent advances in open-source, resource-efficient Large\nLanguage Models (LLMs) offer promising new approaches for automating such\nhigh-level tasks. In this work, we critically evaluate five state-of-the-art\nopen-source LLMs, spanning 3B to 8B parameter sizes, on the EMR task for Python\ncode. We systematically assess functional correctness and code quality using\nautomated metrics and investigate the impact of prompting strategies by\ncomparing one-shot prompting to a Recursive criticism and improvement (RCI)\napproach. RCI-based prompting consistently outperforms one-shot prompting in\ntest pass rates and refactoring quality. The best-performing models,\nDeepseek-Coder-RCI and Qwen2.5-Coder-RCI, achieve test pass percentage (TPP)\nscores of 0.829 and 0.808, while reducing lines of code (LOC) per method from\n12.103 to 6.192 and 5.577, and cyclomatic complexity (CC) from 4.602 to 3.453\nand 3.294, respectively. A developer survey on RCI-generated refactorings shows\nover 70% acceptance, with Qwen2.5-Coder rated highest across all evaluation\ncriteria. In contrast, the original code scored below neutral, particularly in\nreadability and maintainability, underscoring the benefits of automated\nrefactoring guided by quality prompts. While traditional metrics like CC and\nLOC provide useful signals, they often diverge from human judgments,\nemphasizing the need for human-in-the-loop evaluation. Our open-source\nbenchmark offers a foundation for future research on automated refactoring with\nLLMs.", "AI": {"tldr": "The paper demonstrates that open-source large language models can automate Extract Method Refactoring for Python, particularly when using recursive prompting strategies. These techniques enhance code quality and receive strong developer approval, though automated metrics don\u2019t always match human judgment. The authors provide a benchmark for future research in LLM-powered code refactoring.", "motivation": "Extract Method Refactoring (EMR) is critical for improving code readability and maintainability, but its automation still faces significant challenges. Open-source large language models (LLMs) have recently shown potential to automate such high-level programming tasks.", "method": "The paper evaluates five open-source LLMs (3B to 8B parameters) on automating EMR for Python code. The study uses automated metrics for functional correctness and code quality, comparing one-shot prompting against a recursive criticism and improvement (RCI) prompting strategy. Additionally, a developer survey assesses the perceived quality of the refactored code.", "result": "RCI prompting yields better refactoring results than one-shot approaches: Deepseek-Coder-RCI and Qwen2.5-Coder-RCI achieve test pass rates of 82.9% and 80.8%, respectively. Both models significantly reduce lines of code and cyclomatic complexity per method. Developer survey results show >70% acceptance of RCI-generated refactorings, with Qwen2.5-Coder-RCI rated highest overall. Automated metrics sometimes diverge from human judgment, highlighting the value of human-in-the-loop evaluation.", "conclusion": "Open-source LLMs, especially when combined with RCI prompting, can effectively automate Extract Method Refactoring, improving code quality and developer acceptance. Human evaluation is essential for aligning automated metrics with subjective assessments. The benchmark introduced serves as a baseline for further research."}}
{"id": "2510.26516", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26516", "abs": "https://arxiv.org/abs/2510.26516", "authors": ["Truong Hai Dang", "Jingyu Xiao", "Yintong Huo"], "title": "Envisioning Future Interactive Web Development: Editing Webpage with Natural Language", "comment": "accepted by AIWare'25", "summary": "The evolution of web applications relies on iterative code modifications, a\nprocess that is traditionally manual and time-consuming. While Large Language\nModels (LLMs) can generate UI code, their ability to edit existing code from\nnew design requirements (e.g., \"center the logo\") remains a challenge. This is\nlargely due to the absence of large-scale, high-quality tuning data to align\nmodel performance with human expectations. In this paper, we introduce a novel,\nautomated data generation pipeline that uses LLMs to synthesize a high-quality\nfine-tuning dataset for web editing, named Instruct4Edit. Our approach\ngenerates diverse instructions, applies the corresponding code modifications,\nand performs visual verification to ensure correctness. By fine-tuning models\non Instruct4Edit, we demonstrate consistent improvement in translating human\nintent into precise, structurally coherent, and visually accurate code changes.\nThis work provides a scalable and transparent foundation for natural language\nbased web editing, demonstrating that fine-tuning smaller open-source models\ncan achieve competitive performance with proprietary systems. We release all\ndata, code implementations, and model checkpoints for reproduction.", "AI": {"tldr": "The paper introduces Instruct4Edit, an automated pipeline that generates data to fine-tune models for web code editing, enabling smaller open-source models to achieve high performance for natural language-driven web edits.", "motivation": "Current web application development often involves manual and slow iterative code modifications. Large Language Models (LLMs) can generate UI code but struggle with modifying existing code based on new design instructions due to a lack of robust training data.", "method": "An automated data generation pipeline leverages LLMs to create diverse instructions and corresponding code modifications, validates changes via visual verification, and uses this synthesized dataset to fine-tune and evaluate models for web editing tasks.", "result": "The authors present Instruct4Edit, a pipeline that uses LLMs to automatically synthesize a high-quality dataset for web code editing. Fine-tuning models on this dataset consistently improves model ability to accurately perform code changes from human commands. Fine-tuned open-source models can match proprietary system performance.", "conclusion": "Fine-tuned open-source models, using the Instruct4Edit dataset, provide scalable and transparent natural language-based web editing, potentially reducing dependence on proprietary systems. Resources are fully released for reproducibility."}}
{"id": "2510.26538", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26538", "abs": "https://arxiv.org/abs/2510.26538", "authors": ["David Williams", "Max Hort", "Maria Kechagia", "Aldeida Aleti", "Justyna Petke", "Federica Sarro"], "title": "Reflecting on Empirical and Sustainability Aspects of Software Engineering Research in the Era of Large Language Models", "comment": "5 pages", "summary": "Software Engineering (SE) research involving the use of Large Language Models\n(LLMs) has introduced several new challenges related to rigour in benchmarking,\ncontamination, replicability, and sustainability. In this paper, we invite the\nresearch community to reflect on how these challenges are addressed in SE. Our\nresults provide a structured overview of current LLM-based SE research at ICSE,\nhighlighting both encouraging practices and persistent shortcomings. We\nconclude with recommendations to strengthen benchmarking rigour, improve\nreplicability, and address the financial and environmental costs of LLM-based\nSE.", "AI": {"tldr": "This paper reviews challenges in LLM-driven software engineering research, focusing on benchmarking, contamination, replicability, and sustainability, and suggests ways for the research community to improve practices going forward.", "motivation": "The motivation for this paper is to address new challenges that have arisen in software engineering research due to the use of Large Language Models, such as issues with benchmarking rigour, dataset contamination, replicability, and sustainability.", "method": "The authors provide a structured overview of current research in LLM-based software engineering, particularly studies presented at ICSE. They analyze practices and shortcomings within these works.", "result": "The paper highlights both encouraging practices and persistent shortcomings in how the SE community addresses issues like benchmarking, contamination, replicability, and sustainability in LLM usage.", "conclusion": "The authors conclude with recommendations to improve benchmarking rigour, enhance replicability, and attend to the financial and environmental impacts associated with LLM-based SE research."}}
{"id": "2510.26576", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26576", "abs": "https://arxiv.org/abs/2510.26576", "authors": ["Filippo Scaramuzza", "Renato Cordeiro Ferreira", "Tomaz Maia Suller", "Giovanni Quattrocchi", "Damian Andrew Tamburri", "Willem-Jan van den Heuvel"], "title": "\"Show Me You Comply... Without Showing Me Anything\": Zero-Knowledge Software Auditing for AI-Enabled Systems", "comment": "This work has been submitted to the ACM Transactions on Software\n  Engineering and Methodology for possible publication", "summary": "The increasing exploitation of Artificial Intelligence (AI) enabled systems\nin critical domains has made trustworthiness concerns a paramount showstopper,\nrequiring verifiable accountability, often by regulation (e.g., the EU AI Act).\nClassical software verification and validation techniques, such as procedural\naudits, formal methods, or model documentation, are the mechanisms used to\nachieve this. However, these methods are either expensive or heavily manual and\nill-suited for the opaque, \"black box\" nature of most AI models. An intractable\nconflict emerges: high auditability and verifiability are required by law, but\nsuch transparency conflicts with the need to protect assets being audited-e.g.,\nconfidential data and proprietary models-leading to weakened accountability. To\naddress this challenge, this paper introduces ZKMLOps, a novel MLOps\nverification framework that operationalizes Zero-Knowledge Proofs\n(ZKPs)-cryptographic protocols allowing a prover to convince a verifier that a\nstatement is true without revealing additional information-within\nMachine-Learning Operations lifecycles. By integrating ZKPs with established\nsoftware engineering patterns, ZKMLOps provides a modular and repeatable\nprocess for generating verifiable cryptographic proof of compliance. We\nevaluate the framework's practicality through a study of regulatory compliance\nin financial risk auditing and assess feasibility through an empirical\nevaluation of top ZKP protocols, analyzing performance trade-offs for ML models\nof increasing complexity.", "AI": {"tldr": "Traditional methods fail to make AI transparent without leaking proprietary information. This paper introduces ZKMLOps, a framework using Zero-Knowledge Proofs for auditable, confidential AI compliance, and demonstrates its feasibility in finance regulation and various ML model complexities.", "motivation": "AI systems are increasingly used in critical domains, and regulations demand verifiable accountability. Traditional verification and validation methods are often expensive, manual, and unsuitable for black-box AI models, posing a challenge between compliance and protecting proprietary assets.", "method": "The paper proposes ZKMLOps, a novel MLOps verification framework that leverages Zero-Knowledge Proofs (ZKPs) in the machine learning lifecycle. ZKMLOps integrates ZKPs with established software engineering patterns to enable modular and repeatable cryptographic proof generation for compliance verification.", "result": "The framework's practicality is demonstrated through a finance sector compliance study and empirical evaluation of several leading ZKP protocols, assessing their performance in ML models of varying complexity.", "conclusion": "ZKMLOps provides a viable way to assure regulatory compliance in AI-enabled systems using ZKPs, balancing auditability demands with confidentiality of proprietary data and models."}}
{"id": "2510.26579", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26579", "abs": "https://arxiv.org/abs/2510.26579", "authors": ["Nathanael Nussbaumer", "Markus B\u00f6ck", "J\u00fcrgen Cito"], "title": "Online and Interactive Bayesian Inference Debugging", "comment": "Accepted by ICSE 2026", "summary": "Probabilistic programming is a rapidly developing programming paradigm which\nenables the formulation of Bayesian models as programs and the automation of\nposterior inference. It facilitates the development of models and conducting\nBayesian inference, which makes these techniques available to practitioners\nfrom multiple fields. Nevertheless, probabilistic programming is notoriously\ndifficult as identifying and repairing issues with inference requires a lot of\ntime and deep knowledge. Through this work, we introduce a novel approach to\ndebugging Bayesian inference that reduces time and required knowledge\nsignificantly. We discuss several requirements a Bayesian inference debugging\nframework has to fulfill, and propose a new tool that meets these key\nrequirements directly within the development environment. We evaluate our\nresults in a study with 18 experienced participants and show that our approach\nto online and interactive debugging of Bayesian inference significantly reduces\ntime and difficulty on inference debugging tasks.", "AI": {"tldr": "This paper presents a new tool for interactively debugging Bayesian inference in probabilistic programming, greatly reducing the required time and expertise, as verified in a user study.", "motivation": "Probabilistic programming makes Bayesian inference accessible but is challenging when debugging inference issues, often requiring significant expertise and time. There is a need for tools that make debugging Bayesian inference easier and more efficient.", "method": "The authors propose a novel debugging framework and tool for Bayesian inference, designed to work directly within a development environment. They define specific requirements for such a framework, then implement and evaluate the tool.", "result": "The tool was evaluated with 18 experienced participants. Results show that the approach significantly reduces the time and difficulty required to debug Bayesian inference tasks.", "conclusion": "Integrating online and interactive debugging tools for Bayesian inference within the development environment improves efficiency and accessibility for practitioners, making inference debugging faster and less demanding."}}
{"id": "2510.26634", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26634", "abs": "https://arxiv.org/abs/2510.26634", "authors": ["Yuan Si", "Kyle Qi", "Daming Li", "Hanyuan Shi", "Jialu Zhang"], "title": "Stitch: Step-by-step LLM Guided Tutoring for Scratch", "comment": null, "summary": "Block-based environments such as Scratch are increasingly popular in\nprogramming education. While block syntax reduces surface errors, semantic bugs\nremain common and challenging for novices to resolve. Existing debugging\nworkflows typically show the correct program directly to learners, a strategy\nthat may fix errors but undermines the development of problem-solving skills.\n  We present Stitch, an interactive tutoring system that replaces \"showing the\nanswer\" with step-by-step scaffolding. The system's Diff-Analyze module\ncontrasts a student's project with a reference implementation, identifies the\nmost critical differences, and uses a large language model to explain why these\nchanges matter. Learners inspect highlighted blocks through a custom rendering\nengine, understand the explanations, and selectively apply partial fixes. This\niterative process continues until the intended functionality is achieved.\n  We evaluate Stitch in an empirical study, comparing it against a\nstate-of-the-art automated feedback generation tool for Scratch. Our key\ninsight is that simply presenting the correct program is pedagogically\nineffective. In contrast, our interactive, step-by-step guided system promotes\na more effective learning experience. More broadly, what constitutes effective\nfeedback in block-based programming remains an open question. Our evaluation\nprovides new evidence that step-by-step tutoring significantly enhances\nlearning outcomes, outperforming both direct-answer approaches and current\nautomated feedback generation tools.", "AI": {"tldr": "The paper introduces Stitch, an interactive tutoring system for block-based programming that uses a step-by-step approach instead of simply showing students the correct answer. Stitch contrasts students' code with a reference and uses large language models to explain differences and guide partial fixes. Empirical evaluation shows that Stitch's scaffolding improves learning more than current automated feedback tools.", "motivation": "Block-based programming tools reduce syntax errors but do not address deeper semantic bugs. Existing feedback methods often give away solutions, limiting learning. There is a need for better feedback that fosters problem-solving skills in novices.", "method": "The authors developed the Stitch system, which analyzes student code via a Diff-Analyze module, highlights important differences from correct solutions, and uses LLM explanations. They conducted an empirical study comparing Stitch to an existing state-of-the-art automated feedback generator for Scratch.", "result": "The study shows that Stitch's iterative, scaffolded tutoring significantly outperforms both state-of-the-art automated feedback and direct answer provision, enhancing learning outcomes for programming novices.", "conclusion": "Step-by-step, interactive feedback in block-based programming education leads to greater learning gains than direct answer-based feedback or current automated tools."}}
{"id": "2510.26676", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26676", "abs": "https://arxiv.org/abs/2510.26676", "authors": ["Samiha Shimmi", "Nicholas M. Synovic", "Mona Rahimi", "George K. Thiruvathukal"], "title": "Process-based Indicators of Vulnerability Re-Introducing Code Changes: An Exploratory Case Study", "comment": "9 pages, 6 figures; Samiha Shimmi and Nicholas M. Synovic contributed\n  equally to this work (co-first authors); Mona Rahimi and George K.\n  Thiruvathukal contributed equally to this work (co-supervisors)", "summary": "Software vulnerabilities often persist or re-emerge even after being fixed,\nrevealing the complex interplay between code evolution and socio-technical\nfactors. While source code metrics provide useful indicators of\nvulnerabilities, software engineering process metrics can uncover patterns that\nlead to their introduction. Yet few studies have explored whether process\nmetrics can reveal risky development activities over time -- insights that are\nessential for anticipating and mitigating software vulnerabilities. This work\nhighlights the critical role of process metrics along with code changes in\nunderstanding and mitigating vulnerability reintroduction. We move beyond\nfile-level prediction and instead analyze security fixes at the commit level,\nfocusing not only on whether a single fix introduces a vulnerability but also\non the longer sequences of changes through which vulnerabilities evolve and\nre-emerge. Our approach emphasizes that reintroduction is rarely the result of\none isolated action, but emerges from cumulative development activities and\nsocio-technical conditions. To support this analysis, we conducted a case study\non the ImageMagick project by correlating longitudinal process metrics such as\nbus factor, issue density, and issue spoilage with vulnerability reintroduction\nactivities, encompassing 76 instances of reintroduced vulnerabilities. Our\nfindings show that reintroductions often align with increased issue spoilage\nand fluctuating issue density, reflecting short-term inefficiencies in issue\nmanagement and team responsiveness. These observations provide a foundation for\nbroader studies that combine process and code metrics to predict risky fixes\nand strengthen software security.", "AI": {"tldr": "This paper investigates why software vulnerabilities reappear even after being fixed, focusing on process metrics rather than just code. Analyzing the ImageMagick project, the authors find that issues in management and team responsiveness often contribute to vulnerability reintroduction. They suggest that combining process and code metrics can help predict and mitigate risky fixes in software development.", "motivation": "Software vulnerabilities frequently persist or reappear after being fixed, due to the dynamic nature of code evolution and socio-technical factors. Traditional code metrics alone are insufficient to understand or anticipate these vulnerabilities, motivating a closer examination of process metrics and development activities over time.", "method": "The study analyzes security fixes at the commit level, focusing on sequences of changes rather than isolated actions. It uses longitudinal software engineering process metrics, including bus factor, issue density, and issue spoilage, to correlate these with instances of vulnerability reintroduction. The researchers conduct a detailed case study on the ImageMagick project, investigating 76 instances of vulnerabilities that were reintroduced.", "result": "The findings reveal that vulnerability reintroduction often coincides with increased issue spoilage and varying issue density, suggesting that short-term inefficiencies in issue management and team responsiveness contribute to the problem. These process metrics provide valuable insight into the circumstances leading to vulnerability recurrence.", "conclusion": "Process metrics are vital for understanding and predicting the re-emergence of software vulnerabilities. Combining process metrics with code metrics may allow for improved identification of risky development activities and help strengthen software security."}}
{"id": "2510.26699", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26699", "abs": "https://arxiv.org/abs/2510.26699", "authors": ["Aylton Almeida", "Laerte Xavier", "Marco Tulio Valente"], "title": "Using Copilot Agent Mode to Automate Library Migration: A Quantitative Assessment", "comment": null, "summary": "Keeping software systems up to date is essential to avoid technical debt,\nsecurity vulnerabilities, and the rigidity typical of legacy systems. However,\nupdating libraries and frameworks remains a time consuming and error-prone\nprocess. Recent advances in Large Language Models (LLMs) and agentic coding\nsystems offer new opportunities for automating such maintenance tasks. In this\npaper, we evaluate the update of a well-known Python library, SQLAlchemy,\nacross a dataset of ten client applications. For this task, we use the Github's\nCopilot Agent Mode, an autonomous AI systema capable of planning and executing\nmulti-step migration workflows. To assess the effectiveness of the automated\nmigration, we also introduce Migration Coverage, a metric that quantifies the\nproportion of API usage points correctly migrated. The results of our study\nshow that the LLM agent was capable of migrating functionalities and API usages\nbetween SQLAlchemy versions (migration coverage: 100%, median), but failed to\nmaintain the application functionality, leading to a low test-pass rate\n(39.75%, median).", "AI": {"tldr": "LLM agents can automate the migration of library APIs but often break application functionality, requiring more advances before fully reliable software maintenance automation is possible.", "motivation": "Updating libraries and frameworks in software systems is crucial for avoiding technical debt and security issues but is often difficult and error-prone. Large Language Models (LLMs) and agentic coding systems may help automate this process.", "method": "The study uses Github's Copilot Agent Mode, an autonomous AI system, to migrate a popular Python library (SQLAlchemy) across ten client applications. Migration Coverage, a new metric, is introduced to measure the proportion of API usage points that were correctly migrated.", "result": "The LLM agent successfully migrated all API usage points in the majority of cases (100% migration coverage, median). However, it was much less successful in maintaining the overall application functionality, as reflected by a low test-pass rate (39.75%, median).", "conclusion": "While LLM-powered agents can automate API migrating tasks efficiently, they struggle to preserve application functionality, indicating that further improvements are necessary for robust, automated software maintenance."}}
{"id": "2510.26793", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26793", "abs": "https://arxiv.org/abs/2510.26793", "authors": ["Nafid Enan", "Gias Uddin"], "title": "Optimized Log Parsing with Syntactic Modifications", "comment": null, "summary": "Logs provide valuable insights into system runtime and assist in software\ndevelopment and maintenance. Log parsing, which converts semi-structured log\ndata into structured log data, is often the first step in automated log\nanalysis. Given the wide range of log parsers utilizing diverse techniques, it\nis essential to evaluate them to understand their characteristics and\nperformance. In this paper, we conduct a comprehensive empirical study\ncomparing syntax- and semantic-based log parsers, as well as single-phase and\ntwo-phase parsing architectures. Our experiments reveal that semantic-based\nmethods perform better at identifying the correct templates and syntax-based\nlog parsers are 10 to 1,000 times more efficient and provide better grouping\naccuracy although they fall short in accurate template identification.\nMoreover, two-phase architecture consistently improves accuracy compared to\nsingle-phase architecture. Based on the findings of this study, we propose\nSynLog+, a template identification module that acts as the second phase in a\ntwo-phase log parsing architecture. SynLog+ improves the parsing accuracy of\nsyntax-based and semantic-based log parsers by 236\\% and 20\\% on average,\nrespectively, with virtually no additional runtime cost.", "AI": {"tldr": "This paper benchmarks log parsers, showing syntax-based ones are highly efficient, while semantic-based are best for template identification. Using a two-phase system and adding their SynLog+ module greatly improves parsing accuracy for both types, without extra processing time.", "motivation": "The motivation behind this paper is the need to improve the accuracy and efficiency of log parsing, which is a critical first step in automated log analysis. With a wide range of log parsers based on different techniques available, understanding their strengths, weaknesses, and comparative performance is essential for optimizing log-based analytics and system insights.", "method": "The authors conducted a comprehensive empirical study comparing syntax-based vs. semantic-based log parsers, alongside single-phase and two-phase parsing architectures. They evaluated these parsers' performance on identifying correct log templates, efficiency, and grouping accuracy.", "result": "Semantic-based methods outperform in template identification, while syntax-based methods are 10 to 1,000 times more efficient and excel in grouping accuracy but are less accurate in template identification. Two-phase architectures improve accuracy over single-phase ones consistently. The proposed SynLog+ module, used as a second phase, boosts parsing accuracy for syntax-based log parsers by 236% and for semantic-based log parsers by 20%, with virtually no increase in runtime cost.", "conclusion": "Two-phase parsing architectures offer improved accuracy in log parsing. While semantic-based methods are superior in identifying templates, syntax-based log parsers offer significant efficiency and grouping accuracy. Adding the SynLog+ module as a second phase dramatically enhances the accuracy of existing log parsers without significant runtime overhead."}}
