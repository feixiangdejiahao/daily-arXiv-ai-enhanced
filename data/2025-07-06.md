<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 16]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [How do Software Engineering Candidates Prepare for Technical Interviews?](https://arxiv.org/abs/2507.02068)
*Brian Bell,Teresa Thomas,Sang Won Lee,Chris Brown*

Main category: cs.SE

TL;DR: Technical interviews for software engineering are hard to prepare for and not effectively addressed in current education. Most candidates don't train in realistic ways and feel unprepared and stressed. The paper identifies the challenges and offers suggestions for better support and curriculum alignment.


<details>
  <summary>Details</summary>
Motivation: Aspiring software engineers must pass technical interviews, but these interviews are complex and not usually practiced in educational programs. There is a gap between the skills taught in computing curricula and the skills needed to succeed in technical interviews.

Method: The researchers distributed a survey to 131 candidates actively preparing for technical interviews, gathering data on their preparation methods and the perceived support from educational courses.

Result: The study found that candidates rarely train for technical interviews in realistic settings, and educational courses do not adequately support preparation. This lack of support results in candidates feeling stressed and unprepared for technical interviews.

Conclusion: The findings highlight the need for stakeholders (such as educators and employers) to improve technical interview preparation for software engineering candidates. The paper suggests ways to better align curriculum and training with real-world interview demands.

Abstract: To obtain employment, aspiring software engineers must complete technical
interviews -- a hiring process which involves candidates writing code while
communicating to an audience. However, the complexities of tech interviews are
difficult to prepare for and seldom faced in computing curricula. To this end,
we seek to understand how candidates prepare for technical interviews,
investigating the effects of preparation methods and the role of education. We
distributed a survey to candidates (n = 131) actively preparing for technical
interviews. Our results suggest candidates rarely train in authentic settings
and courses fail to support preparation efforts -- leading to stress and
unpreparedness. Based on our findings, we provide implications for stakeholders
to enhance tech interview preparation for candidates pursuing software
engineering roles.

</details>


### [2] [Structural Code Search using Natural Language Queries](https://arxiv.org/abs/2507.02107)
*Ben Limpanukorn,Yanjun Wang,Zach Patterson,Pranav Garg,Murali Krishna Ramanathan,Xiaofei Ma,Anoop Deoras,Miryung Kim*

Main category: cs.SE

TL;DR: This paper presents a system that lets developers use natural language to perform powerful structural code searches by translating queries with a large language model, outperforming existing approaches and making advanced search accessible.


<details>
  <summary>Details</summary>
Motivation: Structural code search tools offer precise and powerful ways to find and manipulate code, but require developers to write queries in domain-specific languages (DSLs), which are hard to learn and use. Lowering this barrier by allowing natural language queries could greatly improve accessibility and effectiveness.

Method: The authors propose a novel method that leverages large language models (LLMs) to translate natural language queries into DSL queries usable by existing structural code search engines (specifically Semgrep and GQL). They built a benchmark with 400 queries over 10 Java projects to evaluate their approach.

Result: The proposed approach achieves high precision and recall (55%-70%) and significantly outperforms semantic code search and LLM retrieval baselines by as much as 57% and 14% in F1 scores.

Conclusion: Translating natural language code search queries to structural search DSLs via LLMs is effective, robust, and dramatically more user-friendly than existing structural search methods requiring DSL expertise.

Abstract: Searching code is a common task that developers perform to understand APIs,
learn common code patterns, and navigate code. Currently, developers most
commonly search using keywords and regular expressions that are easy to use and
widely available. Beyond keywords and regular expressions, structural code
search tools allow developers to search for code based on its syntactic
structure. This has numerous applications ranging from bug finding to
systematically refactoring code. However, these structural code search tools
operate on queries expressed in domain-specific languages (DSL) that can be
difficult to learn and write. We propose to allow developers to use natural
language to search for code structurally. Expressing queries in natural
language provides an intuitive way to search for code and lowers the barrier to
entry.
  In this work, we develop a novel general approach that combines the reasoning
capabilities of an LLM to interpret natural language search queries with the
power of structural search tools to efficiently and accurately retrieve
relevant code. We then instantiate this approach for two structural code search
DSLs: Semgrep and GQL. In our evaluation, we construct a new benchmark for
structural code search consisting of 400 queries over 10 Java projects. We show
that our approach for structural code search based on translating NL queries to
DSL queries using an LLM is effective and robust, achieving a high precision
and recall ranging from 55% - 70%. Further, our approach significantly
outperforms baselines based on semantic code search and LLM retrievals by up to
57% and 14% on F1 scores.

</details>


### [3] [Can Internal Software Metrics Predict App Popularity at Launch? Yeas! and Nays!](https://arxiv.org/abs/2507.02110)
*Md Nahidul Islam Opu,Fatima Islam Mouri,Rick Kazman,Yuanfang Cai,Shaiful Chowdhury*

Main category: cs.SE

TL;DR: The paper finds that internal source code metrics, available before app release, can help classify Android apps as popular or not, with a best-case F1-score of 0.72—challenging previous assumptions about the irrelevance of such metrics for predicting app popularity.


<details>
  <summary>Details</summary>
Motivation: Predicting mobile app popularity pre-release could benefit developers by providing a strategic edge, but it is a difficult and unresolved task. The authors aim to investigate if internal software metrics available before deployment can reliably predict popularity outcomes.

Method: The study collected a dataset of 446 open-source Android apps from F-Droid. It extracted software metrics at various code levels (system, class, method), code smells, and metadata. Additional data was gathered from the Google Play Store (user reviews, downloads, permissions). Three sets of features were evaluated using both regression and classification models: minimal Size-only, a Handpicked expert set, and a Voting set selected by algorithms.

Result: Regression models performed poorly (low R^2) because of skewed data distributions. Reframing the problem as a binary classification task (Popular vs. Unpopular) yielded much better performance, with the best model (a Multilayer Perceptron on the Voting feature set) achieving an F1-score of 0.72.

Conclusion: Internal code metrics, despite not being highly explanatory, can still be useful indicators for predicting app popularity. This finding contradicts previous claims that internal metrics are not predictive of software quality or app success.

Abstract: Predicting mobile app popularity before release can provide developers with a
strategic advantage in a competitive marketplace, yet it remains a challenging
problem. This study explores whether internal software metrics, measurable from
source code before deployment, can predict an app's popularity, defined by user
ratings (calculated from user reviews) and DownloadsPerYear (yearly downloads).
Using a dataset of 446 open-source Android apps from F-Droid, we extract a wide
array of features, including system-, class-, and method-level code metrics,
code smells, and app metadata. Additional information, such as user reviews,
download counts, and uses-permission, was collected from the Google Play Store.
We evaluate regression and classification models across three feature sets: a
minimal Size-only baseline, a domain-informed Handpicked set, and a Voting set
derived via feature selection algorithms. Regression models perform poorly due
to skewed data, with low $R^2$ scores. However, when reframed as binary
classification (Popular vs. Unpopular), results improve significantly. The best
model, a Multilayer Perceptron using the Voting set, achieves F1-scores of
0.72. These results suggest that internal code metrics, although limited in
their explanatory power, can serve as useful indicators of app popularity. This
challenges earlier findings that dismissed internal metrics as predictors of
software quality.

</details>


### [4] [A Multimodal Approach Combining Biometrics and Self-Report Instruments for Monitoring Stress in Programming: Methodological Insights](https://arxiv.org/abs/2507.02118)
*Cristina Martinez Montes,Daniela Grassi,Nicole Novielli,Birgit Penzenstadle*

Main category: cs.SE

TL;DR: This study compared self-reported and biometric measures of stress during software tasks with time pressure, finding little alignment between the methods and suggesting the stress induction was insufficient, with methodological recommendations for future research.


<details>
  <summary>Details</summary>
Motivation: Traditional studies on well-being and stress rely heavily on self-reported data, which may include biases, prompting the need for more objective measurements such as biometrics in combination with psychometric tools.

Method: An experiment was conducted where participants completed surveys, performed programming tasks while wearing biometric sensors, completed post-task surveys, and participated in exit interviews. Stress was induced by strict time limits.

Result: The psychometric instruments did not register stress. Interviews revealed some felt time pressure while others felt no stress. Biometric data showed significant differences only in EDA phasic peaks.

Conclusion: Imposing a stricter time limit was not effective in inducing measurable stress in this context. The study provides methodological guidance for future research combining biometrics and psychometric stress measurements.

Abstract: The study of well-being, stress and other human factors has traditionally
relied on self-report instruments to assess key variables. However, concerns
about potential biases in these instruments, even when thoroughly validated and
standardised, have driven growing interest in alternatives in combining these
measures with more objective methods, such as physiological measures.
  We aimed to (i) compare psychometric stress measures and biometric indicators
and (ii) identify stress-related patterns in biometric data during software
engineering tasks.
  We conducted an experiment where participants completed a pre-survey, then
programmed two tasks wearing biometric sensors, answered brief post-surveys for
each, and finally went through a short exit interview.
  Our results showed diverse outcomes; we found no stress in the psychometric
instruments. Participants in the interviews reported a mix of feeling no stress
and experiencing time pressure. Finally, the biometrics showed a significant
difference only in EDA phasic peaks.
  We conclude that our chosen way of inducing stress by imposing a stricter
time limit was insufficient. We offer methodological insights for future
studies working with stress, biometrics, and psychometric instruments.

</details>


### [5] [Towards Trustworthy Sentiment Analysis in Software Engineering: Dataset Characteristics and Tool Selection](https://arxiv.org/abs/2507.02137)
*Martin Obaidi,Marc Herrmann,Jil Klünder,Kurt Schneider*

Main category: cs.SE

TL;DR: Sentiment analysis tool performance varies across software development communication datasets. This study analyzes several datasets and tools, proposing a feature-based recommendation approach. Transformer-based models work well but context matters, so tool selection should consider dataset characteristics for optimal sentiment analysis in software engineering.


<details>
  <summary>Details</summary>
Motivation: Sentiment analysis is important for understanding team dynamics in software development, but existing tools often have inconsistent performance across different communication platforms due to variations in language and content.

Method: The study examines linguistic and statistical features of 10 developer communication datasets from 5 different platforms and evaluates the performance of 14 sentiment analysis tools. Based on the analysis, a mapping approach and questionnaire are proposed to recommend the most suitable tools for new datasets.

Result: Transformer-based sentiment analysis models (like SetFit and RoBERTa) generally perform well, but their effectiveness depends on the context and dataset characteristics. Using dataset features can help improve the selection of appropriate tools for sentiment analysis.

Conclusion: Selecting sentiment analysis tools based on the linguistic and statistical properties of datasets improves analysis reliability in software engineering. However, tool performance remains context-dependent, and continuous evaluation is recommended as communication environments evolve.

Abstract: Software development relies heavily on text-based communication, making
sentiment analysis a valuable tool for understanding team dynamics and
supporting trustworthy AI-driven analytics in requirements engineering.
However, existing sentiment analysis tools often perform inconsistently across
datasets from different platforms, due to variations in communication style and
content.
  In this study, we analyze linguistic and statistical features of 10 developer
communication datasets from five platforms and evaluate the performance of 14
sentiment analysis tools. Based on these results, we propose a mapping approach
and questionnaire that recommends suitable sentiment analysis tools for new
datasets, using their characteristic features as input.
  Our results show that dataset characteristics can be leveraged to improve
tool selection, as platforms differ substantially in both linguistic and
statistical properties. While transformer-based models such as SetFit and
RoBERTa consistently achieve strong results, tool effectiveness remains
context-dependent. Our approach supports researchers and practitioners in
selecting trustworthy tools for sentiment analysis in software engineering,
while highlighting the need for ongoing evaluation as communication contexts
evolve.

</details>


### [6] [Enhancing COBOL Code Explanations: A Multi-Agents Approach Using Large Language Models](https://arxiv.org/abs/2507.02182)
*Fangjian Lei,Jiawen Liu,Shayan Noei,Ying Zou,Derek Truong,William Alexander*

Main category: cs.SE

TL;DR: A collaborative LLM-based system is proposed for explaining COBOL code. It outperforms existing methods on various metrics and explains code at multiple granularities, making COBOL maintenance easier despite legacy challenges.


<details>
  <summary>Details</summary>
Motivation: COBOL is still widely used in critical sectors, but its maintenance is difficult due to code complexity, lack of documentation, and a shrinking pool of developers. Existing code explanation approaches using large language models (LLMs) struggle with COBOL due to its unique structure and often excessive code length.

Method: The authors propose a multi-agent system consisting of two LLM-based agents. These agents collaborate and use contextual information from the COBOL codebase to generate explanations for functions, files, and whole projects. The system is tested on 14 open-source COBOL projects.

Result: The approach outperforms baseline methods in several metrics: At the function level, improvements of 12.67% (METEOR), 18.59% (chrF), and 0.62% (SentenceBERT) were observed. At the file level, the approach provides clearer, more functional explanations, especially for long files, with up to 14.68% improvement in clarity. At the project level, 82% of selected projects had their functionality and purpose correctly conveyed by the generated explanations.

Conclusion: The multi-agent LLM approach significantly improves code explanation for COBOL systems at function, file, and project levels. This aids in better maintenance and understanding of legacy COBOL code, especially given challenges with code length and documentation.

Abstract: Common Business Oriented Language (COBOL) is a programming language used to
develop business applications that are widely adopted by financial, business,
and government agencies. Due to its age, complexity, and declining number of
COBOL developers, maintaining COBOL codebases is becoming increasingly
challenging. In particular, the lack of documentation makes it difficult for
new developers to effectively understand and maintain COBOL systems. Existing
research utilizes large language models (LLMs) to explain the functionality of
code snippets. However, COBOL presents unique challenges due to its
architectural and syntactical differences, which often cause its code to exceed
the token window size of LLMs. In this work, we propose a multi-agent approach
that leverages two LLM-based agents working collaboratively to generate
explanations for functions, files, and the overall project. These agents
incorporate together by utilizing contextual information from the codebase into
the code explanation prompts. We evaluate the effectiveness of our approach
using 14 open-source, real-world COBOL projects. Our results indicate that our
approach performs significantly better than the baseline in function code
explanation, with improvements of 12.67%, 18.59%, and 0.62% in terms of METEOR,
chrF, and SentenceBERT scores, respectively. At the file level, our approach
effectively explains both short and long COBOL files that exceed the token
window size of LLMs and surpass the baseline by 4.21%, 10.72%, and 14.68% in
explaining the purpose, functionality, and clarity of the generated
explanation. At the project level, our approach generates explanations that
convey the functionality and purpose of 82% of the selected projects.

</details>


### [7] [Precisely Detecting Python Type Errors via LLM-based Unit Test Generation](https://arxiv.org/abs/2507.02318)
*Chen Yang,Ziqi Wang,Yanjie Jiang,Lin Yang,Yuteng Zheng,Jianyi Zhou,Junjie Chen*

Main category: cs.SE

TL;DR: RTED is a new Python test generation tool that uses type constraints and reflective validation to find more type errors and cut down on false positives, outperforming previous methods and aiding in more reliable software.


<details>
  <summary>Details</summary>
Motivation: Type errors in Python can cause runtime failures, undermining software reliability and developer productivity. Existing static analysis tools tend to produce many false positives, while current unit test generation techniques often lack the necessary guidance to efficiently detect such errors.

Method: The paper introduces RTED, a type-aware test generation method. RTED combines step-by-step type constraint analysis with reflective validation, which helps guide the generation of tests targeting type errors and reduces false positives.

Result: RTED outperforms four state-of-the-art techniques, detecting 22-29 more benchmarked type errors on the BugsInPy and TypeBugs datasets. It also produces significantly fewer false positives (with a 173.9%-245.9% precision improvement) and uncovers 12 previously unknown type errors in six real-world Python projects.

Conclusion: RTED effectively boosts type error detection in Python, both increasing detection rates and reducing false positives, thus enhancing Python code reliability.

Abstract: Type errors in Python often lead to runtime failures, posing significant
challenges to software reliability and developer productivity. Existing static
analysis tools aim to detect such errors without execution but frequently
suffer from high false positive rates. Recently, unit test generation
techniques offer great promise in achieving high test coverage, but they often
struggle to produce bug-revealing tests without tailored guidance. To address
these limitations, we present RTED, a novel type-aware test generation
technique for automatically detecting Python type errors. Specifically, RTED
combines step-by-step type constraint analysis with reflective validation to
guide the test generation process and effectively suppress false positives. We
evaluated RTED on two widely-used benchmarks, BugsInPy and TypeBugs.
Experimental results show that RTED can detect 22-29 more benchmarked type
errors than four state-of-the-art techniques. RTED is also capable of producing
fewer false positives, achieving an improvement of 173.9%-245.9% in precision.
Furthermore, RTED successfully discovered 12 previously unknown type errors
from six real-world open-source Python projects.

</details>


### [8] [VeFIA: An Efficient Inference Auditing Framework for Vertical Federated Collaborative Software](https://arxiv.org/abs/2507.02376)
*Chung-ju Huang,Ziqi Zhang,Yinggui Wang,Binghui Wang,Tao Wei,Leye Wang*

Main category: cs.SE

TL;DR: VeFIA enables accurate, privacy-preserving, and highly reliable auditing of inference software execution in Vertical Federated Learning without extra system latency.


<details>
  <summary>Details</summary>
Motivation: There is currently no mechanism to audit whether the inference software of the data party in Vertical Federated Learning (VFL) is executing correctly, which poses risks for correctness and trust in cross-silo collaborations.

Method: The authors propose the Vertical Federated Inference Auditing (VeFIA) framework, which uses Trusted Execution Environments (TEE) and a coordinator to validate data party computations. VeFIA performs random sampling validation of inference results without exposing private data or adding inference latency.

Result: VeFIA enables the task party to audit and detect incorrect execution if abnormal inference exceeds 5.4%, with a detection probability of 99.99%, and no additional inference latency. It consistently achieves perfect performance metrics in detecting abnormalities (100% positive/negative predictive value and true positive rate).

Conclusion: VeFIA is the first proposed solution to ensure execution correctness for inference software in VFL, providing high-assurance auditing without privacy or performance trade-offs.

Abstract: Vertical Federated Learning (VFL) is a distributed AI software deployment
mechanism for cross-silo collaboration without accessing participants' data.
However, existing VFL work lacks a mechanism to audit the execution correctness
of the inference software of the data party. To address this problem, we design
a Vertical Federated Inference Auditing (VeFIA) framework. VeFIA helps the task
party to audit whether the data party's inference software is executed as
expected during large-scale inference without leaking the data privacy of the
data party or introducing additional latency to the inference system. The core
of VeFIA is that the task party can use the inference results from a framework
with Trusted Execution Environments (TEE) and the coordinator to validate the
correctness of the data party's computation results. VeFIA guarantees that, as
long as the abnormal inference exceeds 5.4%, the task party can detect
execution anomalies in the inference software with a probability of 99.99%,
without incurring any additional online inference latency. VeFIA's random
sampling validation achieves 100% positive predictive value, negative
predictive value, and true positive rate in detecting abnormal inference. To
the best of our knowledge, this is the first paper to discuss the correctness
of inference software execution in VFL.

</details>


### [9] [Meta-Fair: AI-Assisted Fairness Testing of Large Language Models](https://arxiv.org/abs/2507.02533)
*Miguel Romero-Arjona,José A. Parejo,Juan C. Alonso,Ana B. Sánchez,Aitor Arrieta,Sergio Segura*

Main category: cs.SE

TL;DR: Meta-Fair is a novel, automated framework for testing fairness in large language models by using metamorphic testing and the LLMs themselves for test generation and evaluation. It increases effectiveness and scalability of bias detection, showing high precision and reliable evaluation performance across various dimensions of bias, with some remaining challenges in generalizability and consistency.


<details>
  <summary>Details</summary>
Motivation: Assessing and enforcing fairness in AI systems, particularly large language models (LLMs), is crucial but challenging due to the resource-intensive and non-scalable nature of current fairness testing methods, which rely on manual evaluation and curated datasets.

Method: The proposed method, Meta-Fair, uses: (1) metamorphic testing, which examines the consistency of model outputs when input prompts are systematically modified via defined metamorphic relations (MRs); and (2) leverages LLMs themselves for automated test case generation and output evaluation. The approach is implemented with three open-source tools for test generation, execution, and evaluation.

Result: Experiments involving 12 pre-trained LLMs, 14 MRs, 5 bias dimensions, and 7,900 automatically generated test cases showed that Meta-Fair effectively uncovers bias in LLMs, with an average precision of 92% and biased behavior detected in 29% of executions. LLMs demonstrated reliable evaluation performance, with top models reaching F1-scores up to 0.79. Non-determinism impacts consistency but can be controlled by careful MR design.

Conclusion: Meta-Fair demonstrates a promising automated approach to fairness testing in LLMs, reducing the need for manual intervention and domain-specific resources while effectively identifying biases. Some challenges remain in ensuring consistent and broad applicability.

Abstract: Fairness--the absence of unjustified bias--is a core principle in the
development of Artificial Intelligence (AI) systems, yet it remains difficult
to assess and enforce. Current approaches to fairness testing in large language
models (LLMs) often rely on manual evaluation, fixed templates, deterministic
heuristics, and curated datasets, making them resource-intensive and difficult
to scale. This work aims to lay the groundwork for a novel, automated method
for testing fairness in LLMs, reducing the dependence on domain-specific
resources and broadening the applicability of current approaches. Our approach,
Meta-Fair, is based on two key ideas. First, we adopt metamorphic testing to
uncover bias by examining how model outputs vary in response to controlled
modifications of input prompts, defined by metamorphic relations (MRs). Second,
we propose exploiting the potential of LLMs for both test case generation and
output evaluation, leveraging their capability to generate diverse inputs and
classify outputs effectively. The proposal is complemented by three open-source
tools supporting LLM-driven generation, execution, and evaluation of test
cases. We report the findings of several experiments involving 12 pre-trained
LLMs, 14 MRs, 5 bias dimensions, and 7.9K automatically generated test cases.
The results show that Meta-Fair is effective in uncovering bias in LLMs,
achieving an average precision of 92% and revealing biased behaviour in 29% of
executions. Additionally, LLMs prove to be reliable and consistent evaluators,
with the best-performing models achieving F1-scores of up to 0.79. Although
non-determinism affects consistency, these effects can be mitigated through
careful MR design. While challenges remain to ensure broader applicability, the
results indicate a promising path towards an unprecedented level of automation
in LLM testing.

</details>


### [10] [LLMREI: Automating Requirements Elicitation Interviews with LLMs](https://arxiv.org/abs/2507.02564)
*Alexander Korn,Samuel Gorsch,Andreas Vogelsang*

Main category: cs.SE

TL;DR: The paper introduces LLMREI, a chatbot for automating requirements elicitation interviews. Using zero-shot and least-to-most prompting (not fine-tuning), it performs comparably to humans in error rates, requirement extraction, and context adaptation, with greatest value in large-scale interview scenarios.


<details>
  <summary>Details</summary>
Motivation: Requirements elicitation interviews are essential in gathering system requirements but are resource-intensive, subject to human biases, and prone to miscommunication. Automating parts of this process could improve efficiency and reliability.

Method: The study introduces LLMREI, a chatbot designed to conduct requirements elicitation interviews with minimal human intervention. It evaluates two main approaches: zero-shot prompting and least-to-most prompting, in 33 simulated stakeholder interviews. Fine-tuning was abandoned due to poor preliminary performance. The effectiveness of LLMREI was assessed on minimizing interviewer errors, extracting relevant requirements, and adapting to context and responses.

Result: LLMREI made a similar number of errors as human interviewers, extracted a large portion of requirements, and showed a strong ability to adapt its questions contextually.

Conclusion: LLMREI has potential to automate requirements elicitation interviews effectively, especially when conducting interviews with many stakeholders. It can reduce common interviewer errors and improve scalability, despite making a similar number of errors as humans.

Abstract: Requirements elicitation interviews are crucial for gathering system
requirements but heavily depend on skilled analysts, making them
resource-intensive, susceptible to human biases, and prone to miscommunication.
Recent advancements in Large Language Models present new opportunities for
automating parts of this process. This study introduces LLMREI, a chat bot
designed to conduct requirements elicitation interviews with minimal human
intervention, aiming to reduce common interviewer errors and improve the
scalability of requirements elicitation. We explored two main approaches,
zero-shot prompting and least-to-most prompting, to optimize LLMREI for
requirements elicitation and evaluated its performance in 33 simulated
stakeholder interviews. A third approach, fine-tuning, was initially considered
but abandoned due to poor performance in preliminary trials. Our study assesses
the chat bot's effectiveness in three key areas: minimizing common interview
errors, extracting relevant requirements, and adapting its questioning based on
interview context and user responses. Our findings indicate that LLMREI makes a
similar number of errors compared to human interviewers, is capable of
extracting a large portion of requirements, and demonstrates a notable ability
to generate highly context-dependent questions. We envision the greatest
benefit of LLMREI in automating interviews with a large number of stakeholders.

</details>


### [11] [Human-Machine Collaboration and Ethical Considerations in Adaptive Cyber-Physical Systems](https://arxiv.org/abs/2507.02578)
*Zoe Pfister*

Main category: cs.SE

TL;DR: This paper proposes solutions for integrating human-machine teamwork more naturally and ethically into adaptive cyber-physical systems by developing new interaction mechanisms and frameworks that ensure respect for human values from the earliest stages of system development.


<details>
  <summary>Details</summary>
Motivation: The motivation behind this paper is to enhance the efficiency and effectiveness of adaptive Cyber-Physical Systems (CPS) by seamlessly integrating Human-Machine Teaming (HMT), while addressing the challenges related to differing operational cadences between humans and machines and respecting human privacy and values.

Method: The paper proposes to (1) develop novel methods and processes for integrating HMT into adaptive CPS, emphasizing human-machine interaction and adapting feedback loops, and (2) design frameworks for verifying and validating ethics and human values throughout the system lifecycle, starting from requirements engineering.

Result: The main expected results include new methods and processes to better integrate HMT into adaptive CPS feedback loops, and comprehensive frameworks that ensure ethics and human values are embedded into the systems from their inception and throughout their operation.

Conclusion: By addressing integration and ethical challenges, the research aims to advance the state-of-the-art in adaptive CPS by enabling truly collaborative and ethically-aligned human-machine teams.

Abstract: Adaptive Cyber-Physical Systems (CPS) are systems that integrate both
physical and computational capabilities, which can adjust in response to
changing parameters. Furthermore, they increasingly incorporate human-machine
collaboration, allowing them to benefit from the individual strengths of humans
and machines. Human-Machine Teaming (HMT) represents the most advanced paradigm
of human-machine collaboration, envisioning seamless teamwork between humans
and machines. However, achieving effective and seamless HMT in adaptive CPS is
challenging. While adaptive CPS already benefit from feedback loops such as
MAPE-K, there is still a gap in integrating humans into these feedback loops
due to different operational cadences of humans and machines. Further, HMT
requires constant monitoring of human operators, collecting potentially
sensitive information about their actions and behavior. Respecting the privacy
and human values of the actors of the CPS is crucial for the success of
human-machine teams. This research addresses these challenges by: (1)
developing novel methods and processes for integrating HMT into adaptive CPS,
focusing on human-machine interaction principles and their incorporation into
adaptive feedback loops found in CPS, and (2) creating frameworks for
integrating, verifying, and validating ethics and human values throughout the
system lifecycle, starting from requirements engineering.

</details>


### [12] [Do Research Software Engineers and Software Engineering Researchers Speak the Same Language?](https://arxiv.org/abs/2507.02665)
*Timo Kehrer,Robert Haines,Guido Juckeland,Shurui Zhou,David E. Bernholdt*

Main category: cs.SE

TL;DR: This paper explores the communication challenges caused by differing terminologies between RSEs and SERs, presenting a methodology to map and align concepts for enhanced mutual understanding and collaboration.


<details>
  <summary>Details</summary>
Motivation: There are communication challenges between Research Software Engineers (RSEs) and Software Engineering Researchers (SERs) due to the use of different terminologies for similar concepts.

Method: The authors conducted an investigation into how fundamental software engineering concepts from the SER community are interpreted within the RSE community. They used a systematic terminology mapping methodology to identify aligned concepts, knowledge gaps, and potential areas for adapting terminology.

Result: Preliminary findings reveal opportunities for mutual learning and collaboration between RSEs and SERs. The methodology provides a foundation for future crowd-sourced extension and validation of the terminology mapping.

Conclusion: The systematic mapping and comparison of terminology between RSE and SER communities helps identify overlaps, gaps, and opportunities for collaboration, offering a path towards improving cross-community understanding and cooperation.

Abstract: Anecdotal evidence suggests that Research Software Engineers (RSEs) and
Software Engineering Researchers (SERs) often use different terminologies for
similar concepts, creating communication challenges. To better understand these
divergences, we have started investigating how SE fundamentals from the SER
community are interpreted within the RSE community, identifying aligned
concepts, knowledge gaps, and areas for potential adaptation. Our preliminary
findings reveal opportunities for mutual learning and collaboration, and our
systematic methodology for terminology mapping provides a foundation for a
crowd-sourced extension and validation in the future.

</details>


### [13] [RLHGNN: Reinforcement Learning-driven Heterogeneous Graph Neural Network for Next Activity Prediction in Business Processes](https://arxiv.org/abs/2507.02690)
*Jiaxing Wang,Yifeng Yu,Jiahan Song,Bin Cao,Jing Fan,Ji Zhang*

Main category: cs.SE

TL;DR: Existing sequential and graph-based methods struggle with complex business process activity prediction. RLHGNN addresses this by adaptively generating heterogeneous graph structures with reinforcement learning from event logs, achieving superior prediction accuracy and real-time performance on diverse datasets.


<details>
  <summary>Details</summary>
Motivation: Next activity prediction is crucial for optimizing business processes in modern service architectures, but existing sequence-based and graph-based methods have significant limitations in representing complex, real-world process interactions, particularly parallelism and conditional dependencies.

Method: The authors propose RLHGNN, a framework that transforms event logs into heterogeneous process graphs with three edge types (based on process mining theory). It generates four flexible graph structures by combining these edges and uses reinforcement learning (formulated as a Markov Decision Process) to select the optimal structure for each process instance. Then, heterogeneous graph convolution with relation-specific aggregation predicts the next activity.

Result: Comprehensive evaluation on six real-world datasets shows that RLHGNN consistently outperforms current state-of-the-art methods, with an inference latency of roughly 1 ms per prediction, making it suitable for real-time monitoring.

Conclusion: RLHGNN offers a robust, adaptive, and efficient solution for next activity prediction in complex business process environments, effectively modeling both sequential and non-sequential relationships and enabling real-time deployment.

Abstract: Next activity prediction represents a fundamental challenge for optimizing
business processes in service-oriented architectures such as microservices
environments, distributed enterprise systems, and cloud-native platforms, which
enables proactive resource allocation and dynamic service composition. Despite
the prevalence of sequence-based methods, these approaches fail to capture
non-sequential relationships that arise from parallel executions and
conditional dependencies. Even though graph-based approaches address structural
preservation, they suffer from homogeneous representations and static
structures that apply uniform modeling strategies regardless of individual
process complexity characteristics. To address these limitations, we introduce
RLHGNN, a novel framework that transforms event logs into heterogeneous process
graphs with three distinct edge types grounded in established process mining
theory. Our approach creates four flexible graph structures by selectively
combining these edges to accommodate different process complexities, and
employs reinforcement learning formulated as a Markov Decision Process to
automatically determine the optimal graph structure for each specific process
instance. RLHGNN then applies heterogeneous graph convolution with
relation-specific aggregation strategies to effectively predict the next
activity. This adaptive methodology enables precise modeling of both sequential
and non-sequential relationships in service interactions. Comprehensive
evaluation on six real-world datasets demonstrates that RLHGNN consistently
outperforms state-of-the-art approaches. Furthermore, it maintains an inference
latency of approximately 1 ms per prediction, representing a highly practical
solution suitable for real-time business process monitoring applications. The
source code is available at https://github.com/Joker3993/RLHGNN.

</details>


### [14] [Sustainability Flags for the Identification of Sustainability Posts in Q&A Platforms](https://arxiv.org/abs/2507.02695)
*Sahar Ahmadisakha,Lech Bialek,Mohamed Soliman,Vasilios Andrikopoulos*

Main category: cs.SE

TL;DR: The paper proposes 'sustainability flags' to help identify sustainability in cloud architecture discussions. Experiments show these flags improve identification accuracy and are seen as more practical than relying on definitions alone.


<details>
  <summary>Details</summary>
Motivation: As sustainability becomes increasingly important in software and especially cloud-based systems, it is crucial to identify sustainability considerations in architectural decisions. However, current discussions among practitioners, such as those on Q&A forums, lack clear ways to pinpoint sustainability topics.

Method: The authors introduce 'sustainability flags'—indicators developed from thematic analyses of best practices among cloud providers—to highlight sustainability-related content in software architecture discussions. They evaluate the usefulness of these flags in a controlled experiment.

Result: Preliminary findings show that using sustainability flags helps participants classify fewer posts as sustainability-related but with greater certainty and much better performance compared to a control group. Additionally, users find these flags more helpful and easier to understand than standalone definitions of sustainability.

Conclusion: Sustainability flags are effective tools for helping practitioners identify sustainability topics in cloud architecture discussions. They lead to more precise classification and are perceived as more practical and comprehensible than abstract definitions.

Abstract: In recent years, sustainability in software systems has gained significant
attention, especially with the rise of cloud computing and the shift towards
cloud-based architectures. This shift has intensified the need to identify
sustainability in architectural discussions to take informed architectural
decisions. One source to see these decisions is in online Q&A forums among
practitioners' discussions. However, recognizing sustainability concepts within
software practitioners' discussions remains challenging due to the lack of
clear and distinct guidelines for this task. To address this issue, we
introduce the notion of sustainability flags as pointers in relevant
discussions, developed through thematic analysis of multiple sustainability
best practices from cloud providers. This study further evaluates the
effectiveness of these flags in identifying sustainability within cloud
architecture posts, using a controlled experiment. Preliminary results suggest
that the use of flags results in classifying fewer posts as
sustainability-related compared to a control group, with moderately higher
certainty and significantly improved performance. Moreover, sustainability
flags are perceived as more useful and understandable than relying solely on
definitions for identifying sustainability.

</details>


### [15] [Legal Requirements Translation from Law](https://arxiv.org/abs/2507.02846)
*Anmol Singhal,Travis Breaux*

Main category: cs.SE

TL;DR: The paper presents an automated approach for translating complex legal texts into executable Python representations using textual entailment and in-context learning. This reduces manual effort, improves handling of metadata relationships, and demonstrates strong accuracy and generalization in legal compliance tasks.


<details>
  <summary>Details</summary>
Motivation: Ensuring software systems comply with legal regulations is challenging and resource-intensive, especially for small companies lacking legal expertise. Extracting legal requirements from lengthy, complex legal documents is a particularly difficult step that existing automated solutions handle poorly, especially in terms of capturing relationships between metadata and generalizing to new laws.

Method: The authors propose an automated approach using textual entailment and in-context learning to generate canonical, executable Python representations of legal text. This method is grounded in a manually designed Python class structure (a metamodel) that captures both structural and semantic metadata as well as their interrelationships, minimizing the need for large amounts of manual labeling.

Result: The approach was applied to 13 U.S. state data breach notification laws, with the generated Python representations passing 89.4% of test cases and achieving 82.2 precision and 88.7 recall, indicating strong performance and generalizability.

Conclusion: The proposed method effectively reduces manual effort required to extract legal requirements, improves generalizability to new legislation, and provides high-accuracy, executable representations of legal regulations, thereby supporting software compliance in resource-constrained organizations.

Abstract: Software systems must comply with legal regulations, which is a
resource-intensive task, particularly for small organizations and startups
lacking dedicated legal expertise. Extracting metadata from regulations to
elicit legal requirements for software is a critical step to ensure compliance.
However, it is a cumbersome task due to the length and complex nature of legal
text. Although prior work has pursued automated methods for extracting
structural and semantic metadata from legal text, key limitations remain: they
do not consider the interplay and interrelationships among attributes
associated with these metadata types, and they rely on manual labeling or
heuristic-driven machine learning, which does not generalize well to new
documents. In this paper, we introduce an approach based on textual entailment
and in-context learning for automatically generating a canonical representation
of legal text, encodable and executable as Python code. Our representation is
instantiated from a manually designed Python class structure that serves as a
domain-specific metamodel, capturing both structural and semantic legal
metadata and their interrelationships. This design choice reduces the need for
large, manually labeled datasets and enhances applicability to unseen
legislation. We evaluate our approach on 13 U.S. state data breach notification
laws, demonstrating that our generated representations pass approximately 89.4%
of test cases and achieve a precision and recall of 82.2 and 88.7,
respectively.

</details>


### [16] [Requirements Elicitation Follow-Up Question Generation](https://arxiv.org/abs/2507.02858)
*Yuchen Shen,Anmol Singhal,Travis Breaux*

Main category: cs.SE

TL;DR: Using GPT-4o to generate follow-up questions in requirements elicitation interviews yields questions that are as good or better than those written by humans, especially when guided by common mistakes, suggesting LLMs can improve the interview process.


<details>
  <summary>Details</summary>
Motivation: Interviewing is a critical technique in software requirements elicitation, but conducting effective interviews is challenging due to real-time question formulation, domain unfamiliarity, cognitive load, and information overload. Leveraging recent advances in large language models (LLMs), this paper explores how AI can assist interviewers.

Method: The authors apply GPT-4o, a state-of-the-art large language model, to generate follow-up interview questions during requirements elicitation. They use a framework of common interviewer mistakes and develop methods to generate questions based on interviewee speech. The approach is evaluated through two controlled experiments: one comparing LLM- and human-generated questions with minimal guidance, and another where LLM question generation is guided by interviewer mistake types.

Result: The experiments show that LLM-generated questions are at least as clear, relevant, and informative as human-authored questions. Furthermore, when LLMs are guided by common mistake types, their questions actually outperform human-generated ones in these metrics.

Conclusion: LLMs like GPT-4o can effectively assist interviewers by generating high-quality, real-time follow-up questions during requirements elicitation interviews, potentially enhancing interview quality and reducing interviewer burden.

Abstract: Interviews are a widely used technique in eliciting requirements to gather
stakeholder needs, preferences, and expectations for a software system.
Effective interviewing requires skilled interviewers to formulate appropriate
interview questions in real time while facing multiple challenges, including
lack of familiarity with the domain, excessive cognitive load, and information
overload that hinders how humans process stakeholders' speech. Recently, large
language models (LLMs) have exhibited state-of-the-art performance in multiple
natural language processing tasks, including text summarization and entailment.
To support interviewers, we investigate the application of GPT-4o to generate
follow-up interview questions during requirements elicitation by building on a
framework of common interviewer mistake types. In addition, we describe methods
to generate questions based on interviewee speech. We report a controlled
experiment to evaluate LLM-generated and human-authored questions with minimal
guidance, and a second controlled experiment to evaluate the LLM-generated
questions when generation is guided by interviewer mistake types. Our findings
demonstrate that, for both experiments, the LLM-generated questions are no
worse than the human-authored questions with respect to clarity, relevancy, and
informativeness. In addition, LLM-generated questions outperform human-authored
questions when guided by common mistakes types. This highlights the potential
of using LLMs to help interviewers improve the quality and ease of requirements
elicitation interviews in real time.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [17] [DecoRTL: A Run-time Decoding Framework for RTL Code Generation with LLMs](https://arxiv.org/abs/2507.02226)
*Mohammad Akyash,Kimia Azar,Hadi Kamali*

Main category: cs.PL

TL;DR: Standard LLM decoding fails on RTL code due to structural/semantic challenges. DecoRTL introduces syntax-aware sampling strategies that greatly enhance validity and correctness of RTL generation without slowing inference or requiring model changes.


<details>
  <summary>Details</summary>
Motivation: Conventional LLM decoding strategies—originally tailored for natural language—do not address the structural and semantic intricacies of RTL code, leading to frequent generation errors. There's a need for decoding methods that distinguish between syntax- and design-critical code regions to yield valid and innovative outputs in RTL tasks.

Method: The authors empirically analyze decoding failures in LLMs by investigating token-level entropy during RTL code generation. Based on observed deficiencies, they introduce DecoRTL, which combines self-consistency sampling (generating and re-ranking multiple outputs) and syntax-aware temperature adaptation (adjusting sampling temperature based on token syntactic/functional roles).

Result: DecoRTL demonstrates significant gains in syntactic validity, functional correctness, and diversity of generated RTL code on VerilogEval, with negligible execution overhead and no need for model retraining.

Conclusion: The paper concludes that DecoRTL, a novel syntax-aware and contrastive decoding strategy for LLM-based RTL code generation, significantly enhances the quality of generated code. It improves syntactic validity, functional correctness, and output diversity, with negligible performance overhead and requires no additional model fine-tuning.

Abstract: As one of their many applications, large language models (LLMs) have recently
shown promise in automating register transfer level (RTL) code generation.
However, conventional LLM decoding strategies, originally designed for natural
language, often fail to meet the structural and semantic demands of RTL,
leading to hallucinated, repetitive, or invalid code outputs. In this paper, we
first investigate the root causes of these decoding failures through an
empirical analysis of token-level entropy during RTL generation. Our findings
reveal that LLMs exhibit low confidence in regions of structural ambiguity or
semantic complexity, showing that standard decoding strategies fail to
differentiate between regions requiring determinism (syntax-critical regions)
and those that benefit from creative exploratory variability (design-critical
regions). Then, to overcome this, we introduce DecoRTL, a novel run-time
decoding strategy, that is both syntax-aware and contrastive for RTL code
generation. DecoRTL integrates two complementary components: (i)
self-consistency sampling, which generates multiple candidates and re-ranks
them based on token-level agreement to promote correctness while maintaining
diversity; and (ii) syntax-aware temperature adaptation, which classifies
tokens by their syntactical and functional roles and adjusts the sampling
temperature accordingly, enforcing low temperature for syntax-critical tokens
and higher temperature for exploratory ones. Our approach operates entirely at
inference time without requiring any additional model fine-tuning. Through
evaluations on multiple open-source LLMs using the VerilogEval benchmark, we
demonstrate significant improvements in syntactic validity, functional
correctness, and output diversity, while the execution overhead (performance
overhead) is imperceptible.

</details>
