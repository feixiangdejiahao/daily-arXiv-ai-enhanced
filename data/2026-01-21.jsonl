{"id": "2601.11647", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.11647", "abs": "https://arxiv.org/abs/2601.11647", "authors": ["Aniket Abhishek Soni", "Milan Parikh", "Rashi Nimesh Kumar Dhenia", "Jubin Abhishek Soni", "Ayush Raj Jha", "Sneja Mitinbhai Shah"], "title": "Reinforcement Learning for Dynamic Workflow Optimization in CI/CD Pipelines", "comment": "Accepted and presented at CICN 2025 (International Conference on Computational Intelligence and Communication Networks). 7 pages, 5 figures", "summary": "Continuous Integration and Continuous Deployment (CI/CD) pipelines are central to modern software delivery, yet their static workflows often introduce inefficiencies as systems scale. This paper proposes a reinforcement learning (RL) based approach to dynamically optimize CI/CD pipeline workflows. The pipeline is modeled as a Markov Decision Process, and an RL agent is trained to make runtime decisions such as selecting full, partial, or no test execution in order to maximize throughput while minimizing testing overhead.\n  A configurable CI/CD simulation environment is developed to evaluate the approach across build, test, and deploy stages. Experimental results show that the RL optimized pipeline achieves up to a 30 percent improvement in throughput and approximately a 25 percent reduction in test execution time compared to static baselines, while maintaining a defect miss rate below 5 percent. The agent learns to selectively skip or abbreviate tests for low risk commits, accelerating feedback cycles without significantly increasing failure risk.\n  These results demonstrate the potential of reinforcement learning to enable adaptive and intelligent DevOps workflows, providing a practical pathway toward more efficient, resilient, and sustainable CI/CD automation."}
{"id": "2601.11655", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2601.11655", "abs": "https://arxiv.org/abs/2601.11655", "authors": ["Caihua Li", "Lianghong Guo", "Yanlin Wang", "Daya Guo", "Wei Tao", "Zhenyu Shan", "Mingwei Liu", "Jiachi Chen", "Haoyu Song", "Duyu Tang", "Hongyu Zhang", "Zibin Zheng"], "title": "Advances and Frontiers of LLM-based Issue Resolution in Software Engineering: A Comprehensive Survey", "comment": "26 pages, 4 figures, 5 tables", "summary": "Issue resolution, a complex Software Engineering (SWE) task integral to real-world development, has emerged as a compelling challenge for artificial intelligence. The establishment of benchmarks like SWE-bench revealed this task as profoundly difficult for large language models, thereby significantly accelerating the evolution of autonomous coding agents. This paper presents a systematic survey of this emerging domain. We begin by examining data construction pipelines, covering automated collection and synthesis approaches. We then provide a comprehensive analysis of methodologies, spanning training-free frameworks with their modular components to training-based techniques, including supervised fine-tuning and reinforcement learning. Subsequently, we discuss critical analyses of data quality and agent behavior, alongside practical applications. Finally, we identify key challenges and outline promising directions for future research. An open-source repository is maintained at https://github.com/DeepSoftwareAnalytics/Awesome-Issue-Resolution to serve as a dynamic resource in this field."}
{"id": "2601.11659", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.11659", "abs": "https://arxiv.org/abs/2601.11659", "authors": ["Aaron Adcock", "Aayushi Srivastava", "Abhimanyu Dubey", "Abhinav Jauhri", "Abhinav Pande", "Abhinav Pandey", "Abhinav Sharma", "Abhishek Kadian", "Abhishek Kumawat", "Adam Kelsey", "Adam Stelle", "Adeel Cheema", "Adela Kabiljo", "Adina Katz", "Adithya Gangidi", "Aditya Tayade", "Adolfo Victoria", "Adrian Samatan Alastuey", "Adrien Conrath", "Afroz Mohiuddin", "Ahmed Sharif", "Ahnaf Siddiqui", "Ahuva Goldstand", "Aijung Li", "Aidan Boyd", "Aidin Kazemi Daliri", "Aisha Iqbal", "Ajay Menon", "Ajit Mathews", "Akhil Mathur", "Akshat Agarwal", "Alan Schelten", "Alana Shine", "Alejandro Castillejo Muñoz", "Aleksei Guliaev", "Alex Radovic", "Alex Song", "Alex Vaughan", "Alexander Simeonov", "Alexandre Rezende", "Alexandre Rezende", "Alexei Baevski", "Alexey Roubaud", "Allen Ma", "Alvin Lee", "Alyssa Pereira", "Aman Ahmed", "Aman Shankar", "Amanda Kallet", "Amar Budhiraja", "Ameya Khandekar", "Amine Benhalloum", "Amir Gershman", "Amit Nagpal", "Amit Zohar", "Amr Sharaf", "Anant Desai", "Anastasia Razdaibiedina", "Anca Agape", "Andranik Kurghinyan", "Andre Perunicic", "Andrea Madotto", "Andrei Darabanov", "Andrés Alvarado", "Andrew Brown", "Andrew Cohen", "Andrew Fang", "Andrew Freeman", "Andrew Gallagher", "Andrew Gu", "Andrew Prasetyo Jo", "Andrew Ryan", "Andrew Steffen", "Andrew Wei", "Andrey Rusakov", "Andrii Golovei", "Andy Shang", "Angela Fan", "Angela Fan", "Angela Flewellen", "Animesh Pathak", "Anirudh Goyal", "Ankit Ramchandani", "Ankur Pai", "Ankur Singh", "Ankush Garg", "Anlu Xing", "Anna Cai", "Anna Grosul", "Anna Prochowska", "Anna Sun", "Annie Dong", "Annie Franco", "Anqi Hu", "Anshul Chawla", "Anthony Hartshorn", "Antonia Sheng", "Antony Thomas", "Anuj Goyal", "Anusha De", "Anvit Bodiwala", "Anvit Bodiwala", "Aobo Yang", "Aparajita Saraf", "Apurva Samudra", "Aran Mun", "Arash Rahnama", "Archi Mitra", "Archie Sravankumar", "Archit Gupta", "Aria Haghighi", "Ariel Stolerman", "Arkabandhu Chowdhury", "Arnab Choudhury", "Artem Korenev", "Arthur Guo", "Arthur Hinsvark", "Arun Mallya", "Arvind Neelakantan", "Arya Talebzadeh", "Ashish Shah", "Ashmitha Jeevaraj Shetty", "Ashwin Bharambe", "Asif Islam", "Aston Zhang", "Austen Gregerson", "Avi Lewis", "Aya Ibrahim", "Ayaz Minhas", "Ayelet Dahan", "Ayelet Regev Dabah", "Bangsheng Tang", "Bar Ulman", "Bardiya Sadeghi", "Bartosz Jedrzejewski", "Barys Skarabahaty", "Beibei Zhu", "Beibin Li", "Ben Bharier", "Benjamin Leonhardi", "Benjamin Muller", "Bennett Plessala", "Bernie Huang", "Beth Loyd", "Bhargavi Paranjape", "Bhavik Sheth", "Bill Bonner", "Bill Holland", "Bill Wang", "Bingzhe Liu", "Binh Tang", "Bo Liu", "Bo Wu", "Boduo Li", "Bokai Yu", "Bor-Chun Chen", "Boris Araya", "Boris Vidolov", "Botao Chen", "Boya Peng", "Boyu Ni", "Bradley Davis", "Bram Wasti", "Brandon Adams", "Brandon Taylor", "Brandon Wu", "Brant Swidler", "Brian Chiang", "Brian Clerkin", "Brian Fuller", "Brooks Cutter", "Bruno Novais", "Bryan Gmyrek", "Bysshe Easton", "Cait Campos", "Canaan Case", "Carl Chengyan Fu", "Carly Burton", "Caro Diaz", "Catherine Cole", "Ce Liu", "Cedric Fougerat", "Cen Peng", "Cen Peng", "Cen Zhao", "Changhan Wang", "Changkyu Kim", "Chantal Shaib", "Chao Zhou", "Charlotte Caucheteux", "Chau Nguyen", "Chawin Sitawarin", "Chaya Nayak", "Chelsea Asher", "Chen Fan", "Chen Zhu", "Cheng Cheng", "Cheng Zhang", "Chenguang Zhu", "Chengxiong Ruan", "Chengzhu Yu", "Chenheli Hua", "Chenxi Whitehouse", "Cheryl Holloway", "Ching-Hsiang Chu", "Ching-Yao Chuang", "Chinmay Karande", "Chirag Nagpal", "Chloé Bakalar", "Chloe Bi", "Chris Cai", "Chris Marra", "Chris McConnell", "Chris Thi", "Chris Tindal", "Chris Waterson", "Christian Deverall", "Christian Fuegen", "Christian Keller", "Christine Cheng", "Christine Jou", "Christine Smith", "Christine Wang", "Christoph Feichtenhofer", "Christophe Touret", "Christopher Luc", "Christy Sauper", "Chuanhao Zhuge", "Chun-Yi Sung", "Chunqiang Tang", "Chunyang Wu", "Clara Siegel", "Cody Heale", "Cody Wilbourn", "Colin White", "Congying Xia", "Corinne Wong", "Cornel Rat", "Cristian Canton Ferrer", "Cyrille Habis", "Cyrus Nikolaidis", "D Lohachov", "Da Ju", "Dalton Flanagan", "Damien Allonsius", "Damon Civin", "Dan Johnson", "Daniel Bolya", "Daniel Francisco", "Daniel Fried", "Daniel Hawthorne", "Daniel Haziza", "Daniel Ho", "Daniel Kreymer", "Daniel Li", "Daniel Machlab", "Daniel McKinnon", "Daniel Obenshain", "Daniel Rodriguez", "Daniel Song", "Daniel Tse", "Danielle Pintz", "Danny Livshits", "Daryl James Rodrigo", "Dat Huynh", "Daulet Askarov", "David Brandfonbrener", "David Esiobu", "David Kant", "David Levin", "David Renardy", "David Soofian", "David Stevens", "David Xu", "David Zhang", "Deep Shah", "Delia David", "Demi Douglas", "Denis Boyda", "Desh Raj", "Devamanyu Hazarika", "Dheeraj Mekala", "Dhruv Choudhary", "Dhruv Mahajan", "Di Jin", "Didac Suris Coll-Vinent", "Didem Foss", "Diego Garcia-Olano", "Diego Perino", "Dieuwke Hupkes", "DiJia Su", "Dilip Madathil", "Dinesh Govindasamy", "Dinesh Yeduguru", "Dmitry Vengertsev", "Dong He", "Dong Li", "Dong Wang", "Dongzhuo Li", "Duc Le", "Dunant Hin", "Dustin Holland", "Duy Nguyen", "Duy Nguyen", "Ed Dowling", "Eden Litt", "Egor Lakomkin", "Ehab AlBadawy", "Ehsan K. Ardestani", "Elad Eckstein", "Elahe Dabir", "Elaine Montgomery", "Elina Lobanova", "Elior Abramoviz", "Eliot Hedeman", "Elissa Li", "Elizabeth Hilbert", "Ellen Xiaoqing Tan", "Elliot Yun", "Elodie Stener", "Emilian Stoimenov", "Emilien Garreau", "Emily Dinan", "Emily Hahn", "Emily Wood", "Emma Li", "Emmanuel Ademuwagun", "Emrah Seker", "Eric Alamillo", "Eric Gan", "Eric Han", "Eric Huang", "Eric Michael Smith", "Eric-Tuan Le", "Ernie Chang", "Eryk Helenowski", "Eslam Elnikety", "Esteban Arcaute", "Ethan Myers", "Eugene Nho", "Eugene Poliukhovych", "Evan Dunbar", "Evgeniy Litvinenko", "Evrim Altıntaş", "Eyal Hochman", "Eyal Shtrauch", "Fabian Mastenbroek", "Faiza Zeb", "Faizan Ahmad", "Farhad Farahbakhshian", "Fei Kou", "Fei Sun", "Feiyu Chen", "Felix Chung", "Feng Tian", "Feng Xu", "Filip Radenovic", "Filippos Kokkinos", "Francesco Barbieri", "Francesco Caggioni", "Francisco Esparza", "Francisco Guzmán", "Frank Kanayet", "Frank Seide", "Frank Zhang", "Fred Lewis", "Freda Huang", "Fulton Wang", "Gabriel Synnaeve", "Gabriela Jacques-Silva", "Gabriella Schwarz", "Gaganjit Ghardhora", "Gal Elfer", "Garrett Dickson", "Gaurav Chaurasia", "Gautam Sewani", "Geet Shingi", "Gefei Zuo", "Geonhwa Jeong", "George Puthanpurackal", "Georgia Swee", "Gerard Moreno-Torres Bertran", "Gil Keren", "Gina Ling", "Gjergji Stasa", "Gobinda Saha", "Gor Safran", "Gordy French", "Goutham Rajendran", "Govind Thattai", "Grace Cineas", "Graeme Nail", "Greg Fletcher", "Grégoire Mialon", "Griffin Adams", "Grigory Sizov", "Guan Pang", "Hady Elsahar", "Hai Dang Tran", "Hailey Nguyen", "Haiping Wu", "Hakan Inan", "Hamid Eghbalzadeh", "Han Fang", "Han Zou", "Hannah Doyle", "Hannah Korevaar", "Hannah Wang", "Hannah Werbel", "Hanwen Zha", "Hany Morsy", "Hao Ma", "Haoci Zhang", "Haonan Sun", "Haozhu Wang", "Hardik Shah", "Haroun Habeeb", "Harrison Rudolph", "Harsh Gupta", "Harsh Poddar", "Harshil Parikh", "Hejia Zhang", "Heming Wang", "Hengduo Li", "Himanshu Sharma", "Hoang Phi Nguyen", "Hongbo Zhang", "Honghao Qiu", "Hongjiang Lv", "Hongli Xu", "Hongyuan Zhan", "Hossein Hamooni", "Howard Huang", "Hu Xu", "Hugo Laurençon", "Hugo Touvron", "Hung Dinh", "Hunter Goldman", "Hussein Mehanna", "Huy Nguyen", "Hweimi Tsuo", "Ian Graves", "Ian Yu", "Ibrahim Damlaj", "Idan Cohen", "Igor Tufanov", "Ilan Goldenstein", "Ilias Leontiadis", "Iliyan Zarov", "Imad Ahmed", "Innocent Djiofack", "Iosif Spulber", "Irina-Elena Veliche", "Isabella Ramos", "Ishan Misra", "Itai Gal", "Ivan Evtimov", "Ivan Evtimov", "Ivan Obraztsov", "Jack Wu", "Jacqueline Romero Vertino", "Jaemo Koo", "Jaewon Lee", "Jake Jung", "Jake Weissman", "James Beldock", "James Crnkovich", "James Grinage", "James Hongyi Zeng", "James Kohli", "James Tian", "Jamie Cahill", "Jan Geffert", "Jan Seidel", "Jan Seidel", "Janey Tracey", "Jang Hyun Cho", "Janice Wei", "Jarrod Kahn", "Jasmyn Howell", "Jason Long Vu", "Jason Park", "Jason Yan", "Jason Yip", "Jay Li", "Jay Mahadeokar", "Jaya Bharath R Goluguri", "Jayasi Mehar", "Jean-Baptiste Gaya", "Jeet Shah", "Jeff Hanson", "Jeff Marcus", "Jeff Walsh", "Jeff Yang", "Jelmer van der Linde", "Jemma Fan", "Jennifer Chan", "Jenny Zhen", "Jenya Lee", "Jeremy Fu", "Jeremy Reizenstein", "Jeremy Teboul", "Jesse He", "Jessica Zhong", "Ji Hou", "Ji Yang", "Jia Ding", "Jiabo Hu", "Jiacheng Zhu", "Jiadong Guo", "Jialiang Wang", "Jialin Ouyang", "Jianfeng Chi", "Jianyu Huang", "Jianyun Zhao", "Jiaowen Yang", "Jiatong Zhou", "Jiawei Zhao", "Jiawen Liu", "Jie Wang", "Jie You", "Jiecao Yu", "Jillian Schwiep", "Jilong Wu", "Jing Huang", "Jing Li", "Jing Yu Koh", "Jing Zhang", "Jingxiang Chen", "Jingyi Yang", "Jingyue Shen", "Jinho Hwang", "Jinxi Guo", "Jiwan Khatiwada", "Joanna Bitton", "Joe Li", "Joe Quanaim", "Joel Beales", "Johan Schuijt", "John Chang", "John Quan", "Johnnie Chan", "Jon Shepard", "Jona Harris", "Jonah Rubin", "Jonathan Janzen", "Jonathan Kaldor", "Jorge Lopez Silva", "Jose Leitao", "Joseph Greer", "Joseph Moon", "Joseph Rocca", "Joseph Tighe", "Josh Fromm", "Joshua Deng", "Joshua Fernandes", "Joshua Saxe", "Joyce Zheng", "Juan Pino", "Julien Prigent", "Jun Chen", "Junjiao Tian", "Junjie Qi", "Junjie Wang", "Junteng Jia", "Kade Baker", "Kai Londenberg", "Kai Wang", "Kainan Peng", "Kaiyan Peng", "Kaiyue Yang", "Kalyan Vasudev Alwala", "Kam Hou Yu", "Kanika Narang", "Karan Chadha", "Karan Sikka", "Karen Zhang", "Karina Schuberts", "Karishma Mandyam", "Karthik Abinav Sankararaman", "Karthik Padthe", "Karthik Prasad", "Karthik Sivakumar", "Kartikeya Upasani", "Kate Plawiak", "Kate Saenko", "Kateřina Žmolíková", "Kathryn Stadler", "Kathy Matosich", "Katie Doulgass", "Kaveh Hassani", "Kay Ji", "Ke Li", "Kenneth Heafield", "Kenny Yu", "Keqian Li", "Kevin Chih-Yao Ma", "Kevin Hannan", "Keyu Man", "Kezhen Chen", "Khalid El-Arini", "Khrystyna Hutsulyak", "Kieran Nash", "Kiran Jagadeesh", "Kody Bartelt", "Konstantin Topaloglou-Mundy", "Konstantinos Chatziioannou", "Konstantinos Karanasos", "Konstantinos Vougioukas", "Kostas Tsiampouris", "Kristen Hamill", "Kristy Choi", "Krithika Iyer", "Kshitiz Malik", "Kuenley Chiu", "Kun Huang", "Kunal Bhalla", "Kunal Chawla", "Kunpeng Li", "Kushal Lakhotia", "Kyle Monk", "Lakshya Garg", "Lalit Chourey", "Lars Hamre", "Laura Gustafson", "Lauren Deason", "Laurence Rouesnel", "Laurens van der Maaten", "Lavender A", "Lawrence Chen", "Lawrence Jang", "Leandro Silva", "Leda Sari", "Lee Hetherington", "Lei Zhang", "Leiyu Zhao", "Lele Chen", "Leo Chenghui Li", "Leon Yang", "Leon Zhan", "Levi Corallo", "Liang Tan", "Licheng Yu", "Lijuan Liu", "Lilach Mor", "Lincoln Lin", "Linfeng Li", "Lisa Titus", "Liz Jenkins", "Lovish Madaan", "Lu Fang", "Lu Yuan", "Lucas Nava", "Lucas Pasqualin", "Lucas Switzer", "Lucia Fang", "Lucy Sun", "Luka Tadic", "Lukas Blecher", "Lukas Landzaat", "Luxin Zhang", "Madhavi Rao", "Madian Khabsa", "Mahalia Miller", "Mahendra Kariya", "Mahesh Pasupuleti", "Mahi Luthra", "Manaal Faruqui", "Manav Avlani", "Manchen Wang", "Mannat Singh", "Manohar Paluri", "Manoj Chakkaravarthy", "Manoj Nair", "Maquelle Tiffany", "Marcin Pawlowski", "Marcus Wu", "Maria Lomeli", "Mario Consuegra", "Marion Boiteux", "Marios Andreas Galanis", "Marshall Chen", "Martin Gleize", "Maryam Fazel-Zarandi", "Matan Hasson", "Mathew Oldham", "Mathieu Rita", "Matt Dordal", "Matt Setzler", "Matt Staats", "Matt Staats", "Matt Wilde", "Matthew Clark", "Matthew Grange", "Matthew Lennie", "Matthew Schmohl", "Max Raphael", "Maxim Naumov", "Maxim Samoylov", "Maxime Lecanu", "Maya Pavlova", "Md Taha Bin Jawaid", "Meghan Keneally", "Melanie Kambadur", "Meng Zhang", "Mengchen Liu", "Mengdi Lin", "Mengjiao Wang", "Mervyn Abraham", "Miao Liu", "Michael Au-Yeung", "Michael Feldergraf", "Michael Man", "Michael Matheny", "Michael Suo", "Michael Tontchev", "Michel Meyer", "Michelle Ma", "Mihir Patel", "Mihir Sanjay Kale", "Mik Vyatskov", "Mikayla Alexander", "Mike Andersland", "Mike Clark", "Mike Lewis", "Mike Li", "Mike Macey", "Mike Macey", "Mike Seltzer", "Mikel Jimenez Fernandez", "Mikhail Antonov", "Mikhail Plekhanov", "Milan Zhou", "Min Si", "Ming Qiao", "Mingbo Ma", "Mingjun Zhang", "Mingyi Liang", "Miquel Jubert Hermoso", "Mirac Suzgun", "Mirjam Skarica", "Mitesh Kumar Singh", "Mohammad Kabbani", "Mohammad Rastegari", "Mona Sarantakos", "Monica Sim", "Monika Gangapuram", "Mor Moshe", "Morrie Doulaty", "Morvarid Metanat", "Moya Chen", "Mrinal Kumar", "Munish Bansal", "Murali Ramarao", "Na Li", "Nadav Azaria", "Nahiyan Malik", "Naman Goyal", "Nancy Vargas Balderas", "Nanshu Wang", "Naoyuki Kanda", "Natalia Gimelshein", "Natalia Neverova", "Nathan Aclander", "Natt Sithiviraporn", "Navneet Madhu Kumar", "Ned Newton", "Neeraj Bahl", "Negar Ghorbani", "Neil Patel", "Neta-lee Golan", "Nicholas Longenbaugh", "Nick Egebo", "Nikhil Johri", "Nikhil Mehta", "Nikhil Naik", "Niko Moritz", "Nikolay Bashlykov", "Nikolay Bogoychev", "Nikolay Pavlovich Laptev", "Niladri Chatterji", "Nile Jones", "Nimish Shah", "Ning Dong", "Ning Li", "Ning Li", "Ning Zhang", "Nishant Yadav", "Noam Paz", "Norman Cheng", "Norman Cheng", "Olaoluwa Adesanya", "Oleg Repin", "Oleksandr Maksymets", "Omkar Salpekar", "Omri Harosh", "Onkar Pednekar", "Onur Çelebi", "Oran Gafni", "Oren Edinger", "Osama Hanna", "Owais Khan Mohammed", "Ozlem Kalinli", "Paden Tomasello", "Pankaj Singh", "Paola Quevedo", "Parag Jain", "Paria Rashidinejad", "Parker Tooley", "Parth Parekh", "Parth Thakkar", "Parvin Taheri", "Pasan Hapuarachchi", "Pascal Kesseli", "Patrick Alrassy", "Paulo de Rezende Pinatti", "Pavan Balaji", "Pawan Sisodiya", "Pedro Jose Ferreira Moreira", "Pedro Rittner", "Pedro Valenzuela", "Peize Sun", "Peizhao Zhang", "Peng-Jen Chen", "Pengchao Wang", "Pengchuan Zhang", "Pengwei Li", "Petar Vasic", "Peter Carras", "Peter Ney", "Peter Weng", "Petru Dumea", "Phil Hayes", "Philip Woods", "Pierre Andrews", "Pierre Ménard", "Ping-Hao Wu", "Pingchuan Liu", "Piotr Dollar", "Plamen Dzhelepov", "Polina Zvyagina", "Posten A", "Prabhav Agrawal", "Pradhapan Rajendran", "Pradyot Prakash", "Prajjwal Bhargava", "Pramono", "Pranay Shah", "Pranshu Dave", "Prash Jain", "Pratik Dubal", "Praveen Gollakota", "Praveen Krishnan", "Pritish Yuvraj", "Projjal Ghosh", "Punit Singh Koura", "Puxin Xu", "Qi Qi", "Qi Zhou", "Qian Guan", "Qian Sun", "Qiang Liu", "Qing He", "Qinqing Zheng", "Qirui Yang", "Qizhen Guo", "Quanzeng You", "Quentin Carbonneaux", "Quentin Carbonneaux", "Quentin Duval", "Quintin Fettes", "Rachad Alao", "Rachel Batish", "Rachel Guo", "Rachel Rodriguez", "Radhika Bhargava", "Rafael Asuncion", "Raghotham Murthy", "Rahul Dutta", "Rahul Jha", "Rahul Kindi", "Rahul Mitra", "Raj Ganapathy", "Raj Shah", "Rajarshi Das", "Rajat Shrivastava", "Rajesh Nishtala", "Ramakant Shankar", "Raman Shukhau", "Ramon Calderer", "Rangaprabhu Parthasarathy", "Ranjan Subramanian", "Raphael Bensadoun", "Rares Bostan", "Rashnil Chaturvedi", "Ravi Agrawal", "Ray Gao", "Raymond Li", "Rebecca Kogen", "Ricardo Juan Palma Duran", "Ricardo Silveira Cabral", "Richard Lee", "Richard Yuanzhe Pang", "Riddhish Bhalodia", "Riham Mansour", "Rishabh Singh", "Rishi Godugu", "Ritun Patney", "Rob Boyle", "Robbie Goldfarb", "Robert Caldwell", "Robert Kuo", "Roberta Raileanu", "Robin Battey", "Robin Sharma", "Rochit Sapra", "Rocky Wang", "Rodolfo Granata", "Rodrigo De Castro", "Rodrigo Paim", "Rohan Maheshwari", "Rohan Varma", "Rohit Girdhar", "Rohit Patel", "Roshan Sumbaly", "Roy Sheaffer", "Ruan Silva", "Ruben Rodriguez Buchillon", "Rui Hou", "Ruiming Xie", "Ruslan Mavlyutov", "Ruslan Semenov", "Rustam Dinov", "Ruxiao Bao", "Ryan Fox", "Ryan Kilpatrick", "Ryan Kwan", "Ryan Lim", "Ryan Smith", "Saaketh Narayan", "Sabrina Qiao", "Sachin Mehta", "Sachin Siby", "Sagar Jain", "Saghar Hosseini", "Sagie Gur-Ari", "Sahana Chennabasappa", "Sahin Geyik", "Sai Jayesh Bondu", "Sai Mounika Chowdhary Nekkalapudi", "Saif Hasan", "Saisuke Okabayashi", "Saketh Rambhatla", "Salil Sawhney", "Sam Dunster", "Sam Zhao", "Saman Keon", "Samaneh Azadi", "Sameet Sapra", "Samuel Dooley", "Samyak Datta", "Sandeep Parab", "Sang Michael Xie", "Sanjay Singh", "Sanyuan Chen", "Sara Behn", "Sara Khodeir", "Sarah Shirazyan", "Sargun Dhillon", "Sarunya Pumma", "Sasha Sidorov", "Saskia Adaime", "Saurabh Khanna", "Sayem Wani", "Scott Brenton", "Sean Bell", "Sean Kelly", "Sean Koger", "Sean Nunley", "Sean Perry", "Sebastian Caicedo", "Sebastian Dahlgren", "Sebastian Ruder", "Seiji Yamamoto", "Selam Mehretu", "Selvan Sunitha Ravi", "Sen Lyu", "Senthil Chellapan", "Serafeim Mellos", "Sergey Edunov", "Sergey Royt", "Shaina Cohen", "Shangfu Peng", "Shannon Adams", "Shaoliang Nie", "Sharadh Ramaswamy", "Sharan Narang", "Shashank Pisupati", "Shashi Gandham", "Shaun Lim", "Shaun Lindsay", "Sheena Artrip", "Shelly Sheynin", "Shen Yan", "Sheng Feng", "Sheng Shen", "Shengbao Zheng", "Shenghao Lin", "Shengjie Bi", "Shengxin Cindy Zha", "Shengye Wan", "Shengyi Qian", "Shengyong Cai", "Shengzhi Shao", "Shervin Shahidi", "Shikai Li", "Shimon Bernholtz", "Shiqi Wang", "Shishir G. Patil", "Shiv Verma", "Shiva Shankar P", "Shiyang Chen", "Sho Yaida", "Shoubhik Debnath", "Shreyas Siravara", "Shruti Bhosale", "Shuang Ma", "Shun Zhang", "Shuo Tang", "Shuqiang Zhang", "Shuyan Zhou", "Sicong Che", "Sidd Srinivisan", "Siddharth Bhattacharya", "Siddharth Patki", "Sijia Chen", "Sili Chen", "Simon Vandenhende", "Simone Merello", "Sinong Wang", "Sivan Barzily", "Sixian Yi", "Siyu Lin", "SK Bong", "Sky Yin", "Sneha Agarwal", "Sneha Agarwal", "Soerian Lieve", "Soji Sajuyigbe", "Song Jiang", "Songlin Li", "Sonia Kim", "Sopan Khosla", "Soumi Maiti", "Spencer Whitman", "Sravya Popuri", "Sreen Tallam", "Srinivas Vaidyanathan", "Srinivas Vaidyanathan", "Sten Sootla", "Stephane Collot", "Stephanie Ding", "Stephen Chen", "Steven Cai", "Suchin Gururangan", "Sudarshan Govindaprasad", "Sue Young", "Suganthi Dewakar", "Sujan Kumar Gonugondla", "Sujeet Bhandari", "Suman Gumudavelli", "Suman Gumudavelli", "Sumit Gupta", "Summer Deng", "Sungmin Cho", "Suresh Ganapathy", "Surjyendu Dhal", "Susan Fedynak", "Susana Contrera", "Suyoun Kim", "Sylvestre Rebuffi", "Takshak Chahande", "Tamar Herman", "Tan Li", "Tao Xu", "Tara Fowler", "Tarek Sheasha", "Tarun Anand", "Tarun Kalluri", "Tarun Singh", "Tatiana Shavrina", "Ted Li", "Teja Rao", "Tejas Patil", "Teng Li", "Thach Bui", "Thai Quach", "Thamer Alharbash", "Thanh Vinh Vo", "Thawan Kooburat", "Thilo Koehler", "Thomas Georgiou", "Thomas Scialom", "Tian Ye", "Tianhe Li", "Tianjun Zhang", "Tianyu Li", "Tijmen Blankevoort", "Timon Willi", "Timothy Chou", "Timothy Leung", "TJ Lee", "Todor Mihaylov", "Tom Heatwole", "Tong Xiao", "Tony Cao", "Tony Lee", "Trang Le", "Tristan Rice", "Tsz Kei Serena Chan", "Tuan Tran", "Tudor Tiplea", "Tyler Baumgartner", "Uday Savagaonkar", "Ujjwal Karn", "Ulises Martinez Araiza", "Umar Farooq", "Uriel Cohen", "Usman Sharif", "Utkarsh Murarka", "Van Phung", "Varun Joginpalli", "Varun Saravagi", "Vasu Sharma", "Vasudha Viswamurthy", "Vedanuj Goswami", "Vedika Seth", "Venkat Ramesh", "Venkat Ramesh", "Vibhor Gupta", "Victoria Montanez", "Vidhya Natarajan", "Vidya Sarma", "Vignesh Ramanathan", "Viktor Kerkez", "Vinay Rao", "Vincent Gonguet", "Vincent Mauge", "Virginie Do", "Vish Vogeti", "Vishrav Chaudhary", "Viswesh Sankaran", "Vítor Albiero", "Vivek Miglani", "Vivek Pai", "Vlad Cojanu", "Vlad Shubin", "Vlad Tiberiu Mihailescu", "Vladan Petrovic", "Vladimir Ivanov", "Vladislav Vorotilov", "Vrushali Bhutada", "Wai I Ng", "Wei Cheng", "Wei Sun", "Wei Tu", "Wei Wei", "Wei Zhou", "Wei-Ning Hsu", "Weiwei Chu", "Weizhe Yuan", "Wenchen Wang", "Wenjun Zhao", "Wenwen Jiang", "Wenyin Fu", "Wenzhe Jiang", "Whitney Meers", "Will Constable", "Will Wang", "William R. Wong", "Xavier Martinet", "Xi Victoria Lin", "Xi Yan", "Xi Yin", "Xian Li", "Xianfeng Rui", "Xianjun Yang", "Xiaocheng Tang", "Xiaodong Wang", "Xiaofang Wang", "Xiaolan Wang", "Xiaoliang Dai", "Xiaoliang Peng", "Xiaopeng Li", "Xiaozhu Meng", "Xibei Zhang", "Xide Xia", "Xin Jin", "xinbo Gao", "Xinfeng Xie", "Xingyi Zhou", "Xu Ma", "Xuan Ju", "Xuanyi Zhao", "Xubo Liu", "Xuchao Jia", "Xuedong Zhang", "Xuefei Cao", "Xuewei Wang", "Xuewei Wu", "Xunnan Xu", "Xutai Ma", "Xuyang Wang", "Yan Cui", "Yang Chen", "Yang Li", "Yang Shu", "Yang Xia", "Yanjun Chen", "Yanjun Zhou", "Yash Mehta", "Yash Patel", "Yash Tekena", "Yashesh Gaur", "Yasmine Babaei", "Yaxuan Zhou", "Ye Hu", "Ye Qi", "Yejin Lee", "Yeming Wen", "Yen-Cheng Liu", "Yexin Bruce Wu", "Yi Pan", "Yi Yang", "Yi-Hui Lin", "Yifan Wang", "Yifan Wu", "Yifan Yang", "Yifei Huang", "Yiftah Ben Aharon", "Yilin Yang", "Yiling You", "Ying Xu", "Ying Zhang", "Yingquan Yuan", "Yingru Liu", "Yingyi Ma", "Yining Yang", "Yiting Lu", "Yonatan Komornik", "Yongjie Lin", "Yoni Goyhman", "Yossi Moran Mamo", "Youngjin Nam", "Yu Wang", "Yu Lu", "Yu Zhao", "Yu-Ho Hsieh", "Yu-Jung Lo", "Yuandong Tian", "Yuanhan Zhang", "Yuanhao Xiong", "Yuanshun Yao", "Yuchen Hao", "Yuchen Zhang", "Yuchuan Li", "Yue Cao", "Yue Yu", "Yue Zhao", "Yuhan Guo", "Yuhao Wang", "Yuheng Huang", "Yujie Lu", "Yujun Shi", "Yulun Wang", "Yun He", "Yun Wang", "Yundi Qian", "Yunfan Wang", "Yunhao Tang", "Yuning Mao", "Yunlu Li", "Yuqi Dai", "Yuriy Hulovatyy", "Yushi Hu", "Yuxuan Sun", "Zach Rait", "Zach Wentz", "Zacharie Delpierre Coudert", "Zachary Collins", "Zahra Hankir", "Zecheng He", "Zeeshan Ahmed", "Zeeshan Ahmed", "Zef RosnBrick", "Zhan Shu", "Zhanna Rohalska", "Zhaoduo Wen", "Zhe Liu", "Zhe Liu", "Zhen Qiao", "Zhenggang Xu", "Zhengwen Zhou", "Zhengxing Chen", "Zhenyu Tang", "Zhichen Wu", "Zhicheng Ouyang", "Zhihong Lei", "Zhipeng Hong", "Zhiping Xiu", "Zhiwei Zhao", "Zhong Meng", "Zhou Jin", "Zhouhao Zeng", "Zichang Liu", "Zihang Meng", "Zihuan Qiao", "Zinnia Zheng", "Zixi Qi", "Ziyi Luo", "Zoe Foulkes Birkhead", "Zoey Sun", "Zohar Achdut"], "title": "The Llama 4 Herd: Architecture, Training, Evaluation, and Deployment Notes", "comment": "15 pages", "summary": "This document consolidates publicly reported technical details about Metas Llama 4 model family. It summarizes (i) released variants (Scout and Maverick) and the broader herd context including the previewed Behemoth teacher model, (ii) architectural characteristics beyond a high-level MoE description covering routed/shared-expert structure, early-fusion multimodality, and long-context design elements reported for Scout (iRoPE and length generalization strategies), (iii) training disclosures spanning pre-training, mid-training for long-context extension, and post-training methodology (lightweight SFT, online RL, and lightweight DPO) as described in release materials, (iv) developer-reported benchmark results for both base and instruction-tuned checkpoints, and (v) practical deployment constraints observed across major serving environments, including provider-specific context limits and quantization packaging. The manuscript also summarizes licensing obligations relevant to redistribution and derivative naming, and reviews publicly described safeguards and evaluation practices. The goal is to provide a compact technical reference for researchers and practitioners who need precise, source-backed facts about Llama 4."}
{"id": "2601.11672", "categories": ["cs.SE", "eess.SY"], "pdf": "https://arxiv.org/pdf/2601.11672", "abs": "https://arxiv.org/abs/2601.11672", "authors": ["Deepak Babu Piskala"], "title": "From Everything-is-a-File to Files-Are-All-You-Need: How Unix Philosophy Informs the Design of Agentic AI Systems", "comment": null, "summary": "A core abstraction in early Unix systems was the principle that 'everything is a file', enabling heterogeneous devices and kernel resources to be manipulated via uniform read/write interfaces. This paper explores how an analogous unification is emerging in contemporary agentic AI. We trace the evolution from Unix to DevOps, Infrastructure-as-Code, and finally autonomous software agents, highlighting how file-like abstractions and code-based specifications collapse diverse resources into consistent, composable interfaces. The resulting perspective suggests that adopting file- and code-centric interaction models may enable agentic systems that are more maintainable, auditable, and operationally robust."}
{"id": "2601.12385", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.12385", "abs": "https://arxiv.org/abs/2601.12385", "authors": ["Feifei Li", "Xiao Chen", "Xiaoyu Sun", "Xi Xiao", "Shaohua Wang", "Yong Ding", "Sheng Wen", "Qing Li"], "title": "Context-Free Grammar Inference for Complex Programming Languages in Black Box Settings", "comment": null, "summary": "Grammar inference for complex programming languages remains a significant challenge, as existing approaches fail to scale to real world datasets within practical time constraints. In our experiments, none of the state-of-the-art tools, including Arvada, Treevada and Kedavra were able to infer grammars for complex languages such as C, C++, and Java within 48 hours. Arvada and Treevada perform grammar inference directly on full-length input examples, which proves inefficient for large files commonly found in such languages. While Kedavra introduces data decomposition to create shorter examples for grammar inference, its lexical analysis still relies on the original inputs. Additionally, its strict no-overgeneralization constraint limits the construction of complex grammars.\n  To overcome these limitations, we propose Crucio, which builds a decomposition forest to extract short examples for lexical and grammar inference via a distributional matrix. Experimental results show that Crucio is the only method capable of successfully inferring grammars for complex programming languages (where the number of nonterminals is up to 23x greater than in prior benchmarks) within reasonable time limits. On the prior simple benchmark, Crucio achieves an average recall improvement of 1.37x and 1.19x over Treevada and Kedavra, respectively, and improves F1 scores by 1.21x and 1.13x."}
{"id": "2601.11687", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.11687", "abs": "https://arxiv.org/abs/2601.11687", "authors": ["Harmohit Singh"], "title": "Semantic Caching and Intent-Driven Context Optimization for Multi-Agent Natural Language to Code Systems", "comment": null, "summary": "We present a production-optimized multi-agent system designed to translate natural language queries into executable Python code for structured data analytics. Unlike systems that rely on expensive frontier models, our approach achieves high accuracy and cost efficiency through three key innovations: (1) a semantic caching system with LLM-based equivalence detection and structured adaptation hints that provides cache hit rates of 67% on production queries; (2) a dual-threshold decision mechanism that separates exact-match retrieval from reference-guided generation; and (3) an intent-driven dynamic prompt assembly system that reduces token consumption by 40-60% through table-aware context filtering. The system has been deployed in production for enterprise inventory management, processing over 10,000 queries with an average latency of 8.2 seconds and 94.3% semantic accuracy. We describe the architecture, present empirical results from production deployment, and discuss practical considerations for deploying LLM-based analytics systems at scale."}
{"id": "2601.12741", "categories": ["cs.PL", "cs.LO", "math.CO"], "pdf": "https://arxiv.org/pdf/2601.12741", "abs": "https://arxiv.org/abs/2601.12741", "authors": ["Gyeongwon Jeong", "Seonghun Park", "Hongseok Yang"], "title": "An Introduction to Razborov's Flag Algebra as a Proof System for Extremal Graph Theory", "comment": null, "summary": "Razborov's flag algebra forms a powerful framework for deriving asymptotic inequalities between induced subgraph densities, underpinning many advances in extremal graph theory. This survey introduces flag algebra to computer scientists working in logic, programming languages, automated verification, and formal methods. We take a logical perspective on flag algebra and present it in terms of syntax, semantics, and proof strategies, in a style closer to formal logic. One popular proof strategy derives valid inequalities by first proving inequalities in a labelled variant of flag algebra and then transferring them to the original unlabelled setting using the so-called downward operator. We explain this strategy in detail and highlight that its transfer mechanism relies on the notion of what we call an adjoint pair, reminiscent of Galois connections and categorical adjunctions, which appear frequently in work on automated verification and programming languages. Along the way, we work through representative examples, including Mantel's theorem and Goodman's bound on Ramsey multiplicity, to illustrate how mathematical arguments can be carried out symbolically in the flag algebra framework."}
{"id": "2601.11688", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.11688", "abs": "https://arxiv.org/abs/2601.11688", "authors": ["Vedant Nipane", "Pulkit Agrawal", "Amit Singh"], "title": "SpecMap: Hierarchical LLM Agent for Datasheet-to-Code Traceability Link Recovery in Systems Engineering", "comment": null, "summary": "Establishing precise traceability between embedded systems datasheets and their corresponding code implementations remains a fundamental challenge in systems engineering, particularly for low-level software where manual mapping between specification documents and large code repositories is infeasible. Existing Traceability Link Recovery approaches primarily rely on lexical similarity and information retrieval techniques, which struggle to capture the semantic, structural, and symbol level relationships prevalent in embedded systems software. We present a hierarchical datasheet-to-code mapping methodology that employs large language models for semantic analysis while explicitly structuring the traceability process across multiple abstraction levels. Rather than performing direct specification-to-code matching, the proposed approach progressively narrows the search space through repository-level structure inference, file-level relevance estimation, and fine-grained symbollevel alignment. The method extends beyond function-centric mapping by explicitly covering macros, structs, constants, configuration parameters, and register definitions commonly found in systems-level C/C++ codebases. We evaluate the approach on multiple open-source embedded systems repositories using manually curated datasheet-to-code ground truth. Experimental results show substantial improvements over traditional information-retrieval-based baselines, achieving up to 73.3% file mapping accuracy. We significantly reduce computational overhead, lowering total LLM token consumption by 84% and end-to-end runtime by approximately 80%. This methodology supports automated analysis of large embedded software systems and enables downstream applications such as training data generation for systems-aware machine learning models, standards compliance verification, and large-scale specification coverage analysis."}
{"id": "2601.12813", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2601.12813", "abs": "https://arxiv.org/abs/2601.12813", "authors": ["Keyin Wang", "Xiaomu Shi", "Jiaxiang Liu", "Zhilin Wu", "Taolve Chen", "Fu Song", "David N. Jansen"], "title": "A Formally Verified Procedure for Width Inference in FIRRTL", "comment": "Arxiv version for the European Symposium on Programming (ESOP 2026)(to appear) This work was supported by the Strategic Priority Research Program of the Chinese Academy of Sciences, Grant No.~XDA0320101, and partially supported by NSFC-RGC Collaborative Research Grant No.~62561160151. D.N. Jansen is supported by Beijing Natural Science Foundation Project No.~IS25071", "summary": "FIRRTL is an intermediate representation language for Register Transfer Level (RTL) hardware designs. In FIRRTL programs, the bit widths of many components are not specified explicitly and must be inferred during compilation. In mainstream FIRRTL compilers, such as the official compiler firtool, width inference is conducted by a compilation pass referred to as InferWidths, which may fail even for simple FIRRTL programs. In this paper, we thoroughly investigate the width inference problem for FIRRTL programs. We show that, if the constraints obtained from a FIRRTL program are satisfiable, there exists a unique least solution. Based on this result, we propose a complete procedure for solving the width inference problem. We implement it in the interactive theorem prover Rocq and prove its functional correctness. From the Rocq implementation, we extract an OCaml implementation, which is the first formally verified implementation of the InferWidths pass. Extensive experiments demonstrate that our approach can solve more instances than the official InferWidths pass in firtool, normally with high efficiency."}
{"id": "2601.11693", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.11693", "abs": "https://arxiv.org/abs/2601.11693", "authors": ["Shane K. Panter", "Nasir U. Eisty"], "title": "Technical Lag as Latent Technical Debt: A Rapid Review", "comment": "Accepted to: TechDebt 2026 - International Conference on Technical Debt April 12--15, 2026 Rio de Janeiro, Brazil", "summary": "Context: Technical lag accumulates when software systems fail to keep pace with technological advancements, leading to a deterioration in software quality. Objective: This paper aims to consolidate existing research on technical lag, clarify definitions, explore its detection and quantification methods, examine underlying causes and consequences, review current management practices, and lay out a vision as an indicator of passively accumulated technical debt. Method: We conducted a Rapid Review with snowballing to select the appropriate peer-reviewed studies. We leveraged the ACM Digital Library, IEEE Xplore, Scopus, and Springer as our primary source databases. Results: Technical lag accumulates passively, often unnoticed due to inadequate detection metrics and tools. It negatively impacts software quality through outdated dependencies, obsolete APIs, unsupported platforms, and aging infrastructure. Strategies to manage technical lag primarily involve automated dependency updates, continuous integration processes, and regular auditing. Conclusions: Enhancing and extending the current standardized metrics, detection methods, and empirical studies to use technical lag as an indication of accumulated latent debt can greatly improve the process of maintaining large codebases that are heavily dependent on external packages. We have identified the research gaps and outlined a future vision for researchers and practitioners to explore."}
{"id": "2601.12943", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.12943", "abs": "https://arxiv.org/abs/2601.12943", "authors": ["Han Xu", "Di Wang"], "title": "Dependently-Typed AARA: A Non-Affine Approach for Resource Analysis of Higher-Order Programs", "comment": null, "summary": "Static resource analysis determines the resource consumption (e.g., time complexity) of a program without executing it. Among the numerous existing approaches for resource analysis, affine type systems have been one dominant approach. However, these affine type systems fall short of deriving precise resource behavior of higher-order programs, particularly in cases that involve partial applications.\n  This article presents λ_\\ms{amor}^\\ms{na}}, a non-affine AARA-style dependent type system for resource reasoning about higher-order functional programs. The key observation is that the main issue in previous approaches comes from (i) the close coupling of types and resources, and (ii) the conflict between affine and higher-order typing mechanisms. To derive precise resource behavior of higher-order functions, λ_\\ms{amor}^\\ms{na}} decouples resources from types and follows a non-affine typing mechanism. The non-affine type system of λ_\\ms{amor}^\\ms{na}} achieves this by using dependent types, which allows expressing type-level potential functions separate from ordinary types. This article formalizes λ_\\ms{amor}^\\ms{na}}'s syntax and semantics, and proves its soundness, which guarantees the correctness of resource bounds. Several challenging classic and higher-order examples are presented to demonstrate the expressiveness and compositionality of λ_\\ms{amor}^\\ms{na}}'s reasoning capability."}
{"id": "2601.11783", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2601.11783", "abs": "https://arxiv.org/abs/2601.11783", "authors": ["Murtuza N. Shergadwala"], "title": "The Stability Trap: Evaluating the Reliability of LLM-Based Instruction Adherence Auditing", "comment": null, "summary": "The enterprise governance of Generative AI (GenAI) in regulated sectors, such as Human Resources (HR), demands scalable yet reproducible auditing mechanisms. While Large Language Model (LLM)-as-a-Judge approaches offer scalability, their reliability in evaluating adherence of different types of system instructions remains unverified. This study asks: To what extent does the instruction type of an Application Under Test (AUT) influence the stability of judge evaluations? To address this, we introduce the Scoped Instruction Decomposition Framework to classify AUT instructions into Objective and Subjective types, isolating the factors that drive judge instability. We applied this framework to two representative HR GenAI applications, evaluating the stability of four judge architectures over variable runs. Our results reveal a ``Stability Trap'' characterized by a divergence between Verdict Stability and Reasoning Stability. While judges achieved near-perfect verdict agreement ($>99\\%$) for both objective and subjective evaluations, their accompanying justification traces diverged significantly. Objective instructions requiring quantitative analysis, such as word counting, exhibited reasoning stability as low as $\\approx19\\%$, driven by variances in numeric justifications. Similarly, reasoning stability for subjective instructions varied widely ($35\\%$--$83\\%$) based on evidence granularity, with feature-specific checks failing to reproduce consistent rationale. Conversely, objective instructions focusing on discrete entity extraction achieved high reasoning stability ($>90\\%$). These findings demonstrate that high verdict stability can mask fragile reasoning. Thus, we suggest that auditors scope automated evaluation protocols strictly: delegate all deterministically verifiable logic to code, while reserving LLM judges for complex semantic evaluation."}
{"id": "2601.13224", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.13224", "abs": "https://arxiv.org/abs/2601.13224", "authors": ["Michael Hanus", "Steven Libby"], "title": "Functional Logic Program Transformations", "comment": "Presented at Conference on Declarative Programming (DECLARE 2025)", "summary": "Many tools used to process programs, like compilers, analyzers, or verifiers, perform transformations on their intermediate program representation, like abstract syntax trees. Implementing such program transformations is a non-trivial task, since it is necessary to iterate over the complete syntax tree and apply various transformations at nodes in a tree. In this paper we show how the features of functional logic programming are useful to implement program transformations in a compact and comprehensible manner. For this purpose, we propose to write program transformations as partially defined and non-deterministic operations. Since the implementation of non-determinism usually causes some overhead compared to deterministically defined operations, we compare our approach to a deterministic transformation method. We evaluate these alternatives for the functional logic language Curry and its intermediate representation FlatCurry which is used in various analysis and verification tools and compilers."}
{"id": "2601.11835", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.11835", "abs": "https://arxiv.org/abs/2601.11835", "authors": ["Yufan Zhang", "Jaromir Savelka", "Seth Goldstein", "Michael Conway"], "title": "Changes in Coding Behavior and Performance Since the Introduction of LLMs", "comment": null, "summary": "The widespread availability of large language models (LLMs) has changed how students engage with coding and problem-solving. While these tools may increase student productivity, they also make it more difficult for instructors to assess students' learning and effort. In this quasi-longitudinal study, we analyze five years of student source code submissions in a graduate-level cloud computing course, focusing on an assignment that remained unchanged and examining students' behavior during the period spanning five semesters before the release of ChatGPT and five semesters after.\n  Student coding behavior has changed significantly since Fall 2022. The length of their final submissions increased. Between consecutive submissions, average edit distances increased while average score improvement decreased, suggesting that both student productivity and learning have decreased after ChatGPT's release. Additionally, there are statistically significant correlations between these behavioral changes and their overall performance. Although we cannot definitively attribute them to LLM misuse, they are consistent with our hypothesis that some students are over-reliant on LLMs, which is negatively affecting their learning outcomes. Our findings raise an alarm around the first generation of graduates in the age of LLMs, calling upon both educators and employers to reflect on their evaluation methods for genuine expertise and productivity."}
{"id": "2601.13341", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.13341", "abs": "https://arxiv.org/abs/2601.13341", "authors": ["Namratha Gangamreddypalli", "Constantin Enea", "Shaz Qadeer"], "title": "Reduction for Structured Concurrent Programs", "comment": null, "summary": "Commutativity reasoning based on Lipton's movers is a powerful technique for verification of concurrent programs. The idea is to define a program transformation that preserves a subset of the initial set of interleavings, which is sound modulo reorderings of commutative actions. Scaling commutativity reasoning to routinely-used features in software systems, such as procedures and parallel composition, remains a significant challenge.\n  In this work, we introduce a novel reduction technique for structured concurrent programs that unifies two key advances. First, we present a reduction strategy that soundly replaces parallel composition with sequential composition. Second, we generalize Lipton's reduction to support atomic sections containing (potentially recursive) procedure calls. Crucially, these two foundational strategies can be composed arbitrarily, greatly expanding the scope and flexibility of reduction-based reasoning. We implemented this technique in Civl and demonstrated its effectiveness on a number of challenging case studies, including a snapshot object, a fault-tolerant and linearizable register, the FLASH cache coherence protocol, and a non-trivial variant of Two-Phase Commit."}
{"id": "2601.11836", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.11836", "abs": "https://arxiv.org/abs/2601.11836", "authors": ["Finn Hackett", "Evan Wrench", "Peter Macko", "A. Jesse Jiryu Davis", "Yuanhao Wei", "Ivan Beschastnikh"], "title": "Trace Validation of Unmodified Concurrent Systems with OmniLink", "comment": null, "summary": "Concurrent systems are notoriously difficult to validate: subtle bugs may only manifest under rare thread interleavings, and existing tools often require intrusive instrumentation or unrealistic execution models. We present OmniLink, a new methodology for validating concurrent implementations against high-level specifications in TLA+. Unlike prior TLA+ based approaches which use a technique called trace validation, OmniLink treats system events as black boxes with a timebox in which they occurred and a meaning in TLA+, solving for a logical total order of actions. Unlike prior approaches based on linearizability checking, which already solves for total orders of actions with timeboxes, OmniLink uses a flexible specification language, and offers a different linearizability checking method based on off-the-shelf model checking. OmniLink offers different features compared existing linearizability checking tools, and we show that it outperforms the state of the art on large scale validation tasks.\n  Our evaluation validates WiredTiger, a state-of-the-art industrial database storage layer, as well as Balanced Augmented Tree (BAT), a state-of-the art lock-free data structure from the research community, and ConcurrentQueue, a popular lock-free queue featuring aggressive performance optimizations. We use OmniLink to improve WiredTiger's existing TLA+ model, as well as develop new TLA+ models that closely match the behavior of the modeled systems, including non-linearizable behaviors. OmniLink is able to find known bugs injected into the systems under test, as well as help discover two previously unknown bugs (1 in BAT, 1 in ConcurrentQueue), which we have confirmed with the authors of those systems."}
{"id": "2601.13727", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.13727", "abs": "https://arxiv.org/abs/2601.13727", "authors": ["Bart Jacobs"], "title": "Foundational VeriFast: Pragmatic Certification of Verification Tool Results through Hinted Mirroring", "comment": "8 pages, 2 figures", "summary": "VeriFast is a leading tool for the modular formal verification of correctness properties of single-threaded and multi-threaded C and Rust programs. It verifies a program by symbolically executing each function in isolation, exploiting user-annotated preconditions, postconditions, and loop invariants written in a form of separation logic, and using a separation logic-based symbolic representation of memory. However, the tool itself, written in roughly 30K lines of OCaml code, has not been formally verified. Therefore, bugs in the tool could cause it to falsely report the correctness of the input program. We here report on an early result extending VeriFast to emit, upon successful verification of a Rust program, a Rocq proof script that proves correctness of the program with respect to a Rocq-encoded axiomatic semantics of Rust. This significantly enhances VeriFast's applicability in safety-critical domains. We apply hinted mirroring: we record key information from VeriFast's symbolic execution run, and use it to direct a replay of the run in Rocq."}
{"id": "2601.11868", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.11868", "abs": "https://arxiv.org/abs/2601.11868", "authors": ["Mike A. Merrill", "Alexander G. Shaw", "Nicholas Carlini", "Boxuan Li", "Harsh Raj", "Ivan Bercovich", "Lin Shi", "Jeong Yeon Shin", "Thomas Walshe", "E. Kelly Buchanan", "Junhong Shen", "Guanghao Ye", "Haowei Lin", "Jason Poulos", "Maoyu Wang", "Marianna Nezhurina", "Jenia Jitsev", "Di Lu", "Orfeas Menis Mastromichalakis", "Zhiwei Xu", "Zizhao Chen", "Yue Liu", "Robert Zhang", "Leon Liangyu Chen", "Anurag Kashyap", "Jan-Lucas Uslu", "Jeffrey Li", "Jianbo Wu", "Minghao Yan", "Song Bian", "Vedang Sharma", "Ke Sun", "Steven Dillmann", "Akshay Anand", "Andrew Lanpouthakoun", "Bardia Koopah", "Changran Hu", "Etash Guha", "Gabriel H. S. Dreiman", "Jiacheng Zhu", "Karl Krauth", "Li Zhong", "Niklas Muennighoff", "Robert Amanfu", "Shangyin Tan", "Shreyas Pimpalgaonkar", "Tushar Aggarwal", "Xiangning Lin", "Xin Lan", "Xuandong Zhao", "Yiqing Liang", "Yuanli Wang", "Zilong Wang", "Changzhi Zhou", "David Heineman", "Hange Liu", "Harsh Trivedi", "John Yang", "Junhong Lin", "Manish Shetty", "Michael Yang", "Nabil Omi", "Negin Raoof", "Shanda Li", "Terry Yue Zhuo", "Wuwei Lin", "Yiwei Dai", "Yuxin Wang", "Wenhao Chai", "Shang Zhou", "Dariush Wahdany", "Ziyu She", "Jiaming Hu", "Zhikang Dong", "Yuxuan Zhu", "Sasha Cui", "Ahson Saiyed", "Arinbjörn Kolbeinsson", "Jesse Hu", "Christopher Michael Rytting", "Ryan Marten", "Yixin Wang", "Alex Dimakis", "Andy Konwinski", "Ludwig Schmidt"], "title": "Terminal-Bench: Benchmarking Agents on Hard, Realistic Tasks in Command Line Interfaces", "comment": null, "summary": "AI agents may soon become capable of autonomously completing valuable, long-horizon tasks in diverse domains. Current benchmarks either do not measure real-world tasks, or are not sufficiently difficult to meaningfully measure frontier models. To this end, we present Terminal-Bench 2.0: a carefully curated hard benchmark composed of 89 tasks in computer terminal environments inspired by problems from real workflows. Each task features a unique environment, human-written solution, and comprehensive tests for verification. We show that frontier models and agents score less than 65\\% on the benchmark and conduct an error analysis to identify areas for model and agent improvement. We publish the dataset and evaluation harness to assist developers and researchers in future work at https://www.tbench.ai/ ."}
{"id": "2601.13991", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.13991", "abs": "https://arxiv.org/abs/2601.13991", "authors": ["Darion Haase", "Kevin Batz", "Adrian Gallus", "Benjamin Lucien Kaminski", "Joost-Pieter Katoen", "Lutz Klinkenberg", "Tobias Winkler"], "title": "Generating Functions Meet Occupation Measures: Invariant Synthesis for Probabilistic Loops (Extended Version)", "comment": "Full version of ESOP2026 paper 'Generating Functions Meet Occupation Measures: Invariant Synthesis for Probabilistic Loops'", "summary": "A fundamental computational task in probabilistic programming is to infer a program's output (posterior) distribution from a given initial (prior) distribution. This problem is challenging, especially for expressive languages that feature loops or unbounded recursion. While most of the existing literature focuses on statistical approximation, in this paper we address the problem of mathematically exact inference.\n  To achieve this for programs with loops, we rely on a relatively underexplored type of probabilistic loop invariant, which is linked to a loop's so-called occupation measure. The occupation measure associates program states with their expected number of visits, given the initial distribution. Based on this, we derive the notion of an occupation invariant. Such invariants are essentially dual to probabilistic martingales, the predominant technique for formal probabilistic loop analysis in the literature. A key feature of occupation invariants is that they can take the initial distribution into account and often yield a proof of positive almost sure termination as a by-product.\n  Finally, we present an automatic, template-based invariant synthesis approach for occupation invariants by encoding them as generating functions. The approach is implemented and evaluated on a set of benchmarks."}
{"id": "2601.11926", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.11926", "abs": "https://arxiv.org/abs/2601.11926", "authors": ["Ananya Halgatti", "Shaunak Biswas", "Hiya Bhatt", "Srinivasan Rakhunathan", "Karthik Vaidhyanathan"], "title": "Harmonica: A Self-Adaptation Exemplar for Sustainable MLOps", "comment": "This paper has been accepted to SEAMS 2026 Artifact Track", "summary": "Machine learning enabled systems (MLS) often operate in settings where they regularly encounter uncertainties arising from changes in their surrounding environment. Without structured oversight, such changes can degrade model behavior, increase operational cost, and reduce the usefulness of deployed systems. Although Machine Learning Operations (MLOps) streamlines the lifecycle of ML models, it provides limited support for addressing runtime uncertainties that influence the longer term sustainability of MLS. To support continued viability, these systems need a mechanism that detects when execution drifts outside acceptable bounds and adjusts system behavior in response. Despite the growing interest in sustainable and self-adaptive MLS, there has been limited work towards exemplars that allow researchers to study these challenges in MLOps pipelines. This paper presents Harmonica, a self-adaptation exemplar built on the HarmonE approach, designed to enable the sustainable operation of such pipelines. Harmonica introduces structured adaptive control through MAPE-K loop, separating high-level adaptation policy from low-level tactic execution. It continuously monitors sustainability metrics, evaluates them against dynamic adaptation boundaries, and automatically triggers architectural tactics when thresholds are violated. We demonstrate the tool through case studies in time series regression and computer vision, examining its ability to improve system stability and reduce manual intervention. The results show that Harmonica offers a practical and reusable foundation for enabling adaptive behavior in MLS that rely on MLOps pipelines for sustained operation."}
{"id": "2601.14059", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2601.14059", "abs": "https://arxiv.org/abs/2601.14059", "authors": ["Andrea Gilot", "Axel Bergström", "Eva Darulova"], "title": "Verifying Floating-Point Programs in Stainless", "comment": null, "summary": "We extend the Stainless deductive verifier with floating-point support, providing the first automated verification support for floating-point numbers for a subset of Scala that includes polymorphism, recursion and higher-order functions. We follow the recent approach in the KeY verifier to axiomatise reasoning about mathematical functions, but go further by supporting all functions from Scala's math API, and by verifying the correctness of the axioms against the actual implementation in Stainless itself. We validate Stainless' floating-point support on a new set of benchmarks sampled from real-world code from GitHub, showing that it can verify specifications about, e.g., ranges of output or absence of special values for most supported functions, or produce counter-examples when the specifications do not hold."}
{"id": "2601.11972", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2601.11972", "abs": "https://arxiv.org/abs/2601.11972", "authors": ["Chi Thien Tran"], "title": "Enhancing Fuzz Testing Efficiency through Automated Fuzz Target Generation", "comment": "4 tables, 4 figures, 7 pages", "summary": "Fuzzing continues to be the most effective method for identifying security vulnerabilities in software. In the context of fuzz testing, the fuzzer supplies varied inputs to fuzz targets, which are designed to comprehensively exercise critical sections of the client code. Various studies have focused on optimizing and developing advanced fuzzers, such as AFL++, libFuzzer, Honggfuzz, syzkaller, ISP-Fuzzer, which have substantially enhanced vulnerability detection in widely used software and libraries. Nevertheless, achieving greater coverage necessitates improvements in both the quality and quantity of fuzz targets. In large-scale software projects and libraries -- characterized by numerous user defined functions and data types -- manual creation of fuzz targets is both labor-intensive and time-consuming. This challenge underscores the need for automated techniques not only to generate fuzz targets but also to streamline the execution and analysis of their results. In this paper, we introduce an approach to improving fuzz target generation through static analysis of library source code. The proposed method encompasses several key aspects: it analyzes source code structures to accurately construct function calls and generate fuzz targets; it maps fuzzer input data to the corresponding function parameters; it synthesizes compilation information for the fuzz targets; and it automatically collects and analyzes execution results. Our findings are demonstrated through the application of this approach to the generation of fuzz targets for C/C++ libraries."}
{"id": "2601.14114", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.14114", "abs": "https://arxiv.org/abs/2601.14114", "authors": ["Liam Chung", "Tobias Kappé"], "title": "Partial Reductions for Kleene Algebra with Linear Hypotheses", "comment": null, "summary": "Kleene algebra (KA) is an important tool for reasoning about general program equivalences, with a decidable and complete equational theory. However, KA cannot always prove equivalences between specific programs. For this purpose, one adds hypotheses to KA that encode program-specific knowledge. Traditionally, a map on regular expressions called a reduction then lets us lift decidability and completeness to these more expressive systems. Explicitly constructing such a reduction requires significant labour. Moreover, due to regularity constraints, a reduction may not exist for all combinations of expression and hypothesis.\n  We describe an automaton-based construction to mechanically derive reductions for a wide class of hypotheses. These reductions can be partial, in which case they yield partial completeness: completeness for expressions in their domain. This allows us to automatically establish the provability of more equivalences than what is covered in existing work."}
{"id": "2601.12146", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.12146", "abs": "https://arxiv.org/abs/2601.12146", "authors": ["Viktor Kjellberg", "Miroslaw Staron", "Farnaz Fotrousi"], "title": "From LLMs to Agents in Programming: The Impact of Providing an LLM with a Compiler", "comment": null, "summary": "Large Language Models have demonstrated a remarkable capability in natural language and program generation and software development. However, the source code generated by the LLMs does not always meet quality requirements and may fail to compile. Therefore, many studies evolve into agents that can reason about the problem before generating the source code for the solution. The goal of this paper is to study the degree to which such agents benefit from access to software development tools, in our case, a \\texttt{gcc} compiler. We conduct a computational experiment on the RosettaCode dataset, on 699 programming tasks in C. We evaluate how the integration with a compiler shifts the role of the language model from a passive generator to an active agent capable of iteratively developing runnable programs based on feedback from the compiler. We evaluated 16 language models with sizes ranging from small (135 million) to medium (3 billion) and large (70 billion). Our results show that access to a compiler improved the compilation success by 5.3 to 79.4 percentage units in compilation without affecting the semantics of the generated program. Syntax errors dropped by 75\\%, and errors related to undefined references dropped by 87\\% for the tasks where the agents outperformed the baselines. We also observed that in some cases, smaller models with a compiler outperform larger models with a compiler. We conclude that it is essential for LLMs to have access to software engineering tools to enhance their performance and reduce the need for large models in software engineering, such as reducing our energy footprint."}
{"id": "2601.13682", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2601.13682", "abs": "https://arxiv.org/abs/2601.13682", "authors": ["Jianfeng Cai", "Jinhua Zhu", "Ruopei Sun", "Kangwen Zhao", "Dongyun Xue", "Mingxiao Feng", "Wengang Zhou", "Houqiang Li"], "title": "CodeContests-O: Powering LLMs via Feedback-Driven Iterative Test Case Generation", "comment": null, "summary": "The rise of reasoning models necessitates large-scale verifiable data, for which programming tasks serve as an ideal source. However, while competitive programming platforms provide abundant problems and solutions, high-quality test cases for verification remain scarce. Existing approaches attempt to synthesize test cases using Large Language Models (LLMs), but rely solely on the model's intrinsic generation capabilities without external feedback, frequently resulting in insufficiently diverse cases. To address this limitation, we propose a $\\textbf{Feedback-Driven Iterative Framework}$ for comprehensive test case construction. Specifically, our method leverages the LLM to generate initial test cases, executes them against known correct and incorrect solutions, and utilizes the failed results as feedback to guide the LLM in refining the test cases toward high fidelity and discriminability. We then apply this method to the CodeContests dataset to construct an optimized high-quality derivative, $\\textbf{CodeContests-O}$. Evaluating against the entire pool of solutions ($1.1 \\times 10^7$ in total), our dataset achieves an average True Positive Rate (TPR) of $89.37\\%$ and True Negative Rate (TNR) of $90.89\\%$, significantly outperforming the CodeContests and CodeContests+ by margins of $4.32\\%$ and $9.37\\%$, respectively. Furthermore, fine-tuning the Qwen2.5-7B model on CodeContests-O results in a $9.52\\%$ improvement on LiveCodeBench (Pass@1). Experiments demonstrate the effectiveness of our framework and the quality of CodeContests-O. To support reproducibility and facilitate future research, we release the $\\href{https://github.com/cai-jianfeng/CodeContests-O}{code}$ and $\\href{https://huggingface.co/datasets/caijanfeng/CodeContests-O}{dataset}$."}
{"id": "2601.12148", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.12148", "abs": "https://arxiv.org/abs/2601.12148", "authors": ["Muhammad Umar Zeshan", "Motunrayo Ibiyo", "Claudio Di Sipio", "Phuong T. Nguyen", "Davide Di Ruscio"], "title": "Many Hands Make Light Work: An LLM-based Multi-Agent System for Detecting Malicious PyPI Packages", "comment": "The paper has been peer-reviewed and accepted for publication to the Journal of Systems and Software (https://www.sciencedirect.com/journal/journal-of-systems-and-software)", "summary": "Malicious code in open-source repositories such as PyPI poses a growing threat to software supply chains. Traditional rule-based tools often overlook the semantic patterns in source code that are crucial for identifying adversarial components. Large language models (LLMs) show promise for software analysis, yet their use in interpretable and modular security pipelines remains limited. This paper presents LAMPS, a multi-agent system that employs collaborative LLMs to detect malicious PyPI packages. The system consists of four role-specific agents for package retrieval, file extraction, classification, and verdict aggregation, coordinated through the CrewAI framework. A prototype combines a fine-tuned CodeBERT model for classification with LLaMA-3 agents for contextual reasoning. LAMPS has been evaluated on two complementary datasets: D1, a balanced collection of 6,000 setup.py files, and D2, a realistic multi-file dataset with 1,296 files and natural class imbalance. On D1, LAMPS achieves 97.7% accuracy, surpassing MPHunter--one of the state-of-the-art approaches. On D2, it reaches 99.5% accuracy and 99.5% balanced accuracy, outperforming RAG-based approaches and fine-tuned single-agent baselines. McNemar's test confirmed these improvements as highly significant. The results demonstrate the feasibility of distributed LLM reasoning for malicious code detection and highlight the benefits of modular multi-agent designs in software supply chain security."}
{"id": "2601.12186", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.12186", "abs": "https://arxiv.org/abs/2601.12186", "authors": ["Vatsal Venkatkrishna", "Indraneil Paul", "Iryna Gurevych"], "title": "Aletheia: What Makes RLVR For Code Verifiers Tick?", "comment": "8 pages, 6 figures", "summary": "Multi-domain thinking verifiers trained via Reinforcement Learning from Verifiable Rewards (RLVR) are a prominent fixture of the Large Language Model (LLM) post-training pipeline, owing to their ability to robustly rate and rerank model outputs. However, the adoption of such verifiers towards code generation has been comparatively sparse, with execution feedback constituting the dominant signal. Nonetheless, code verifiers remain valuable toward judging model outputs in scenarios where execution feedback is hard to obtain and are a potentially powerful addition to the code generation post-training toolbox. To this end, we create and open-source Aletheia, a controlled testbed that enables execution-grounded evaluation of code verifiers' robustness across disparate policy models and covariate shifts. We examine components of the RLVR-based verifier training recipe widely credited for its success: (1) intermediate thinking traces, (2) learning from negative samples, and (3) on-policy training. While experiments show the optimality of RLVR, we uncover important opportunities to simplify the recipe. Particularly, despite code verification exhibiting positive training- and inference-time scaling, on-policy learning stands out as the key component at small verifier sizes, and thinking-based training emerges as the most important component at larger scales."}
{"id": "2601.12262", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2601.12262", "abs": "https://arxiv.org/abs/2601.12262", "authors": ["Tongtong Wu", "Rongyi Chen", "Wenjie Du", "Suyu Ma", "Guilin Qi", "Zhenchang Xing", "Shahram Khadivi", "Ramesh Periyathambi", "Gholamreza Haffari"], "title": "Environment-Aware Code Generation: How far are We?", "comment": "ICSE 2026", "summary": "Recent progress in large language models (LLMs) has improved code generation, but most evaluations still test isolated, small-scale code (e.g., a single function) under default or unspecified software environments. As a result, it is unclear whether LLMs can reliably generate executable code tailored to a user's specific environment. We present the first systematic study of Environment-Aware Code Generation (EACG), where generated code must be functionally correct and directly executable under arbitrary software configurations. To enable realistic evaluation, we introduce VersiBCB, a benchmark that is multi-package, execution-verified, and deprecation-aware, capturing complex and evolving environments that prior datasets often overlook. Using VersiBCB, we investigate three complementary adaptation axes: data, parameters, and cache, and develop representative strategies for each. Our results show that current LLMs struggle with environment-specific code generation, while our adaptations improve environment compatibility and executability. These findings highlight key challenges and opportunities for deploying LLMs in practical software engineering workflows."}
{"id": "2601.12273", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.12273", "abs": "https://arxiv.org/abs/2601.12273", "authors": ["Chihiro Yoshida", "Yuta Ishimoto", "Olivier Nourry", "Masanari Kondo", "Makoto Matsushita", "Yasutaka Kamei", "Yoshiki Higo"], "title": "Leveraging Mutation Analysis for LLM-based Repair of Quantum Programs", "comment": "6 pages, Accepted at SANER-ERA 2026", "summary": "In recent years, Automated Program Repair (APR) techniques specifically designed for quantum programs have been proposed. However, existing approaches often suffer from low repair success rates or poor understandability of the generated patches. In this study, we construct a framework in which a large language model (LLM) generates code repairs along with a natural language explanation of the applied repairs. To investigate how the contextual information included in prompts influences APR performance for quantum programs, we design four prompt configurations with different combinations of static information, dynamic information, and mutation analysis results. Mutation analysis evaluates how small changes to specific parts of a program affect its execution results and provides more detailed dynamic information than simple execution outputs such as stack traces. Our experimental results show that mutation analysis can provide valuable contextual information for LLM-based APR of quantum programs, improving repair success rates (achieving 94.4% in our experiment) and in some cases also improving the quality of generated explanations. Our findings point toward new directions for developing APR techniques for quantum programs that enhance both reliability and explainability."}
{"id": "2601.12274", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.12274", "abs": "https://arxiv.org/abs/2601.12274", "authors": ["Mahdi Eslamimehr"], "title": "Hybrid Concolic Testing with Large Language Models for Guided Path Exploration", "comment": "12 pages, 2 Figures, 2 Tables", "summary": "Concolic testing, a powerful hybrid software testing technique, has historically been plagued by fundamental limitations such as path explosion and the high cost of constraint solving, which hinder its practical application in large-scale, real-world software systems. This paper introduces a novel algorithmic framework that synergistically integrates concolic execution with Large Language Models (LLMs) to overcome these challenges. Our hybrid approach leverages the semantic reasoning capabilities of LLMs to guide path exploration, prioritize interesting execution paths, and assist in constraint solving. We formally define the system architecture and algorithms that constitute this new paradigm. Through a series of experiments on both synthetic and real-world Fintech applications, we demonstrate that our approach significantly outperforms traditional concolic testing, random testing, and genetic algorithm-based methods in terms of branch coverage, path coverage, and time-to-coverage. The results indicate that by combining the strengths of both concolic execution and LLMs, our method achieves a more efficient and effective exploration of the program state space, leading to improved bug detection capabilities."}
{"id": "2601.12327", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.12327", "abs": "https://arxiv.org/abs/2601.12327", "authors": ["Lucas Gren", "Felix Dobslaw"], "title": "The Expert Validation Framework (EVF): Enabling Domain Expert Control in AI Engineering", "comment": null, "summary": "Generative AI (GenAI) systems promise to transform knowledge work by automating a range of tasks, yet their deployment in enterprise settings remains hindered by the lack of systematic quality assurance mechanisms. We present an Expert Validation Framework that places domain experts at the center of building software with GenAI components, enabling them to maintain authoritative control over system behavior through structured specification, testing, validation, and continuous monitoring processes. Our framework addresses the critical gap between AI capabilities and organizational trust by establishing a rigorous, expert-driven methodology for ensuring quality across diverse GenAI applications. Through a four-stage implementation process encompassing specification, system creation, validation, and production monitoring, the framework enables organizations to leverage GenAI capabilities while maintaining expert oversight and quality standards."}
{"id": "2601.12360", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.12360", "abs": "https://arxiv.org/abs/2601.12360", "authors": ["Xinabang He", "Yuanwei Chen", "Hao Wu", "Jikang Zhang", "Zicheng Wang", "Ligeng Chen", "Junjie Peng", "Haiyang Wei", "Yi Qian", "Tiantai Zhang", "Linzhang Wang", "Bing Mao"], "title": "Discovering 100+ Compiler Defects in 72 Hours via LLM-Driven Semantic Logic Recomposition", "comment": null, "summary": "Compilers constitute the foundational root-of-trust in software supply chains; however, their immense complexity inevitably conceals critical defects. Recent research has attempted to leverage historical bugs to design new mutation operators or fine-tune models to increase program diversity for compiler fuzzing.We observe, however, that bugs manifest primarily based on the semantics of input programs rather than their syntax. Unfortunately, current approaches, whether relying on syntactic mutation or general Large Language Model (LLM) fine-tuning, struggle to preserve the specific semantics found in the logic of bug-triggering programs. Consequently, these critical semantic triggers are often lost, resulting in a limitation of the diversity of generated programs.\n  To explicitly reuse such semantics, we propose FeatureFuzz, a compiler fuzzer that combines features to generate programs. We define a feature as a decoupled primitive that encapsulates a natural language description of a bug-prone invariant, such as an out-of-bounds array access, alongside a concrete code witness of its realization. FeatureFuzz operates via a three-stage workflow: it first extracts features from historical bug reports, synthesizes coherent groups of features, and finally instantiates these groups into valid programs for compiler fuzzing.\n  We evaluated FeatureFuzz on GCC and LLVM. Over 24-hour campaigns, FeatureFuzz uncovered 167 unique crashes, which is 2.78x more than the second-best fuzzer. Furthermore, through a 72-hour fuzzing campaign, FeatureFuzz identified 106 bugs in GCC and LLVM, 76 of which have already been confirmed by compiler developers, validating the approach's ability to stress-test modern compilers effectively."}
{"id": "2601.12448", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.12448", "abs": "https://arxiv.org/abs/2601.12448", "authors": ["Yang Liu", "Yixing Luo", "Xiaofeng Li", "Xiaogang Dong", "Bin Gu", "Zhi Jin"], "title": "Evaluating Large Language Models for Time Series Anomaly Detection in Aerospace Software", "comment": "This paper has been accepted by ASE 2025", "summary": "Time series anomaly detection (TSAD) is essential for ensuring the safety and reliability of aerospace software systems. Although large language models (LLMs) provide a promising training-free alternative to unsupervised approaches, their effectiveness in aerospace settings remains under-examined because of complex telemetry, misaligned evaluation metrics, and the absence of domain knowledge. To address this gap, we introduce ATSADBench, the first benchmark for aerospace TSAD. ATSADBench comprises nine tasks that combine three pattern-wise anomaly types, univariate and multivariate signals, and both in-loop and out-of-loop feedback scenarios, yielding 108,000 data points. Using this benchmark, we systematically evaluate state-of-the-art open-source LLMs under two paradigms: Direct, which labels anomalies within sliding windows, and Prediction-Based, which detects anomalies from prediction errors. To reflect operational needs, we reformulate evaluation at the window level and propose three user-oriented metrics: Alarm Accuracy (AA), Alarm Latency (AL), and Alarm Contiguity (AC), which quantify alarm correctness, timeliness, and credibility. We further examine two enhancement strategies, few-shot learning and retrieval-augmented generation (RAG), to inject domain knowledge. The evaluation results show that (1) LLMs perform well on univariate tasks but struggle with multivariate telemetry, (2) their AA and AC on multivariate tasks approach random guessing, (3) few-shot learning provides modest gains whereas RAG offers no significant improvement, and (4) in practice LLMs can detect true anomaly onsets yet sometimes raise false alarms, which few-shot prompting mitigates but RAG exacerbates. These findings offer guidance for future LLM-based TSAD in aerospace software."}
{"id": "2601.12522", "categories": ["cs.SE", "cs.AI", "cs.IR", "cs.LG", "cs.MA"], "pdf": "https://arxiv.org/pdf/2601.12522", "abs": "https://arxiv.org/abs/2601.12522", "authors": ["Asif Mohammed Samir", "Mohammad Masudur Rahman"], "title": "Improved Bug Localization with AI Agents Leveraging Hypothesis and Dynamic Cognition", "comment": "13 pages, 7 tables, 5 figures", "summary": "Software bugs cost technology providers (e.g., AT&T) billions annually and cause developers to spend roughly 50% of their time on bug resolution. Traditional methods for bug localization often analyze the suspiciousness of code components (e.g., methods, documents) in isolation, overlooking their connections with other components in the codebase. Recent advances in Large Language Models (LLMs) and agentic AI techniques have shown strong potential for code understanding, but still lack causal reasoning during code exploration and struggle to manage growing context effectively, limiting their capability. In this paper, we present a novel agentic technique for bug localization -- CogniGent -- that overcomes the limitations above by leveraging multiple AI agents capable of causal reasoning, call-graph-based root cause analysis and context engineering. It emulates developers-inspired debugging practices (a.k.a., dynamic cognitive debugging) and conducts hypothesis testing to support bug localization. We evaluate CogniGent on a curated dataset of 591 bug reports using three widely adopted performance metrics and compare it against six established baselines from the literature. Experimental results show that our technique consistently outperformed existing traditional and LLM-based techniques, achieving MAP improvements of 23.33-38.57% at the document and method levels. Similar gains were observed in MRR, with increases of 25.14-53.74% at both granularity levels. Statistical significance tests also confirm the superiority of our technique. By addressing the reasoning, dependency, and context limitations, CogniGent advances the state of bug localization, bridging human-like cognition with agentic automation for improved performance."}
{"id": "2601.12559", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.12559", "abs": "https://arxiv.org/abs/2601.12559", "authors": ["Yvan Labiche"], "title": "Automated Tool Support for Category-Partition Testing: Design Decisions, UI and Examples of Use", "comment": null, "summary": "Category-Partition is a functional testing technique that is based on the idea that the input domain of the system under test can be divided into sub-domains, with the assumption that inputs that belong to the same sub-domain trigger a similar behaviour and that therefore it is sufficient to select one input from each sub-domain. Category-Partition proceeds in several steps, from the identification of so-called categories and choices, possibly constrained, which are subsequently used to form test frames, i.e., combinations of choices, and eventually test cases. This paper reports on an ongoing attempt to automate as many of those steps as possible, with graphical-user interface tool support. Specifically, the user interface allows the user to specify parameters as well as so-called environment variables, further specify categories and choices with optional constraints. Choices are provided with precise specifications with operations specific to their types (e.g., Boolean, Integer, Real, String). Then, the tool automates the construction of test frames, which are combinations of choices, according to alternative selection criteria, and the identification of input values for parameters and environment variables for these test frames, thereby producing test cases. The paper illustrates the capabilities of the tool with the use of nine different case studies."}
{"id": "2601.12735", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.12735", "abs": "https://arxiv.org/abs/2601.12735", "authors": ["Hao Chen", "Yunchun Li", "Chen Chen", "Fengxu Lin", "Wei Li"], "title": "OpenAI for OpenAPI: Automated generation of REST API specification via LLMs", "comment": null, "summary": "REST APIs, based on the REpresentational State Transfer (REST) architecture, are the primary type of Web API. The OpenAPI Specification (OAS) serves as the de facto standard for describing REST APIs and is crucial for multiple software engineering tasks. However, developers face challenges in writing and maintaining OAS. Although static analysis shows potential for OAS generation, it is limited to specific programming languages and development frameworks. The powerful code understanding capabilities of LLMs offer new opportunities for OAS generation, yet they are constrained by context limitations and hallucinations. To address these challenges, we propose the OpenAI OpenAPI Project Scanner (OOPS), the first technology-agnostic LLM-based static analysis method for OAS generation, requiring fewer technology-specific rules and less human expert intervention. OOPS is implemented as an LLM agent workflow comprising two key steps: endpoint method extraction and OAS generation. By constructing an API dependency graph, it establishes necessary file associations to address LLMs' context limitations. Through multi-stage generation and self-refine, it mitigates both syntactic and semantic hallucinations during OAS generation. We evaluated OOPS on 12 real-world REST APIs spanning 5 programming languages and 8 development frameworks. Experimental results demonstrate that OOPS accurately generates high-quality OAS for REST APIs implemented with diverse technologies, achieving an average F1-score exceeding 98% for endpoint method inference, 97% for both request parameter and response inference, and 92% for parameter constraint inference. The input tokens average below 5.6K with a maximum of 16.2K, while the output tokens average below 0.9K with a maximum of 7.7K."}
{"id": "2601.12762", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.12762", "abs": "https://arxiv.org/abs/2601.12762", "authors": ["Xingjie Gao", "Pengcheng Huang", "Zhenghao Liu", "Yukun Yan", "Shuo Wang", "Zulong Chen", "Chen Qian", "Ge Yu", "Yu Gu"], "title": "Teaching LLMs to Learn Tool Trialing and Execution through Environment Interaction", "comment": null, "summary": "Equipping Large Language Models (LLMs) with external tools enables them to solve complex real-world problems. However, the robustness of existing methods remains a critical challenge when confronting novel or evolving tools. Existing trajectory-centric paradigms primarily rely on memorizing static solution paths during training, which limits the ability of LLMs to generalize tool usage to newly introduced or previously unseen tools. In this paper, we propose ToolMaster, a framework that shifts tool use from imitating golden tool-calling trajectories to actively learning tool usage through interaction with the environment. To optimize LLMs for tool planning and invocation, ToolMaster adopts a trial-and-execution paradigm, which trains LLMs to first imitate teacher-generated trajectories containing explicit tool trials and self-correction, followed by reinforcement learning to coordinate the trial and execution phases jointly. This process enables agents to autonomously explore correct tool usage by actively interacting with environments and forming experiential knowledge that benefits tool execution. Experimental results demonstrate that ToolMaster significantly outperforms existing baselines in terms of generalization and robustness across unseen or unfamiliar tools. All code and data are available at https://github.com/NEUIR/ToolMaster."}
{"id": "2601.12811", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.12811", "abs": "https://arxiv.org/abs/2601.12811", "authors": ["Julien Malka", "Stefano Zacchiroli", "Théo Zimmermann"], "title": "Docker Does Not Guarantee Reproducibility", "comment": null, "summary": "The reproducibility of software environments is a critical concern in modern software engineering, with ramifications ranging from the effectiveness of collaboration workflows to software supply chain security and scientific reproducibility. Containerization technologies like Docker address this problem by encapsulating software environments into shareable filesystem snapshots known as images. While Docker is frequently cited in the literature as a tool that enables reproducibility in theory, the extent of its guarantees and limitations in practice remains under-explored.\n  In this work, we address this gap through two complementary approaches. First, we conduct a systematic literature review to examine how Docker is framed in scientific discourse on reproducibility and to identify documented best practices for writing Dockerfiles enabling reproducible image building. Then, we perform a large-scale empirical study of 5298 Docker builds collected from GitHub workflows. By rebuilding these images and comparing the results with their historical counterparts, we assess the real reproducibility of Docker images and evaluate the effectiveness of the best practices identified in the literature."}
{"id": "2601.12845", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.12845", "abs": "https://arxiv.org/abs/2601.12845", "authors": ["João Pascoal Faria", "Emanuel Trigo", "Vinicius Honorato", "Rui Abreu"], "title": "Automatic Generation of Formal Specification and Verification Annotations Using LLMs and Test Oracles", "comment": null, "summary": "Recent verification tools aim to make formal verification more accessible to software engineers by automating most of the verification process. However, annotating conventional programs with the formal specification and verification constructs (preconditions, postconditions, loop invariants, auxiliary predicates and functions and proof helpers) required to prove their correctness still demands significant manual effort and expertise. This paper investigates how LLMs can automatically generate such annotations for programs written in Dafny, a verification-aware programming language, starting from conventional code accompanied by natural language specifications (in comments) and test code. In experiments on 110 Dafny programs, a multimodel approach combining Claude Opus 4.5 and GPT-5.2 generated correct annotations for 98.2% of the programs within at most 8 repair iterations, using verifier feedback. A logistic regression analysis shows that proof-helper annotations contribute disproportionately to problem difficulty for current LLMs. Assertions in the test cases served as static oracles to automatically validate the generated pre/postconditions. We also compare generated and manual solutions and present an extension for Visual Studio Code to incorporate automatic generation into the IDE, with encouraging usability feedback."}
{"id": "2601.12890", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.12890", "abs": "https://arxiv.org/abs/2601.12890", "authors": ["Hang Gao", "Tao Peng", "Baoquan Cui", "Hong Huang", "Fengge Wu", "Junsuo Zhao", "Jian Zhang"], "title": "Efficient Code Analysis via Graph-Guided Large Language Models", "comment": null, "summary": "Malicious behavior is often hidden in small, easily overlooked code fragments, especially within large and complex codebases. The cross-file dependencies of these fragments make it difficult for even powerful large language models (LLMs) to detect them reliably. We propose a graph-centric attention acquisition pipeline that enhances LLMs' ability to localize malicious behavior. The approach parses a project into a code graph, uses an LLM to encode nodes with semantic and structural signals, and trains a Graph Neural Network (GNN) under sparse supervision. The GNN performs an initial detection, and through backtracking of its predictions, identifies key code sections that are most likely to contain malicious behavior. These influential regions are then used to guide the LLM's attention for in-depth analysis. This strategy significantly reduces interference from irrelevant context while maintaining low annotation costs. Extensive experiments show that the method consistently outperforms existing methods on multiple public and self-built datasets, highlighting its potential for practical deployment in software security scenarios."}
{"id": "2601.12927", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.12927", "abs": "https://arxiv.org/abs/2601.12927", "authors": ["Weilin Jin", "Chenyu Zhao", "Zeshun Huang", "Chaoyun Zhang", "Qingwei Lin", "Chetan Bansal", "Saravan Rajmohan", "Shenglin Zhang", "Yongqian Sun", "Dan Pei", "Yifan Wu", "Tong Jia", "Ying Li", "Zhonghai Wu", "Minghua Ma"], "title": "A Benchmark for Language Models in Real-World System Building", "comment": null, "summary": "During migration across instruction set architectures (ISAs), software package build repair is a critical task for ensuring the reliability of software deployment and the stability of modern operating systems. While Large Language Models (LLMs) have shown promise in tackling this challenge, prior work has primarily focused on single instruction set architecture (ISA) and homogeneous programming languages. To address this limitation, we introduce a new benchmark designed for software package build repair across diverse architectures and languages. Comprising 268 real-world software package build failures, the benchmark provides a standardized evaluation pipeline. We evaluate six state-of-the-art LLMs on the benchmark, and the results show that cross-ISA software package repair remains difficult and requires further advances. By systematically exposing this challenge, the benchmark establishes a foundation for advancing future methods aimed at improving software portability and bridging architectural gaps."}
{"id": "2601.12951", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.12951", "abs": "https://arxiv.org/abs/2601.12951", "authors": ["Felix Mächtle", "Jan-Niclas Serr", "Nils Loose", "Thomas Eisenbarth"], "title": "Beyond Accuracy: Characterizing Code Comprehension Capabilities in (Large) Language Models", "comment": "Published in the Proceedings of DeepTest 2026", "summary": "Large Language Models (LLMs) are increasingly integrated into software engineering workflows, yet current benchmarks provide only coarse performance summaries that obscure the diverse capabilities and limitations of these models. This paper investigates whether LLMs' code-comprehension performance aligns with traditional human-centric software metrics or instead reflects distinct, non-human regularities. We introduce a diagnostic framework that reframes code understanding as a binary input-output consistency task, enabling the evaluation of classification and generative models. Using a large-scale dataset, we correlate model performance with traditional, human-centric complexity metrics, such as lexical size, control-flow complexity, and abstract syntax tree structure. Our analyses reveal minimal correlation between human-defined metrics and LLM success (AUROC 0.63), while shadow models achieve substantially higher predictive performance (AUROC 0.86), capturing complex, partially predictable patterns beyond traditional software measures. These findings suggest that LLM comprehension reflects model-specific regularities only partially accessible through either human-designed or learned features, emphasizing the need for benchmark methodologies that move beyond aggregate accuracy and toward instance-level diagnostics, while acknowledging fundamental limits in predicting correct outcomes."}
{"id": "2601.13007", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.13007", "abs": "https://arxiv.org/abs/2601.13007", "authors": ["Rusheng Pan", "Bingcheng Mao", "Tianyi Ma", "Zhenhua Ling"], "title": "ArchAgent: Scalable Legacy Software Architecture Recovery with LLMs", "comment": "to be published in ICASSP 2026", "summary": "Recovering accurate architecture from large-scale legacy software is hindered by architectural drift, missing relations, and the limited context of Large Language Models (LLMs). We present ArchAgent, a scalable agent-based framework that combines static analysis, adaptive code segmentation, and LLM-powered synthesis to reconstruct multiview, business-aligned architectures from cross-repository codebases. ArchAgent introduces scalable diagram generation with contextual pruning and integrates cross-repository data to identify business-critical modules. Evaluations of typical large-scale GitHub projects show significant improvements over existing benchmarks. An ablation study confirms that dependency context improves the accuracy of generated architectures of production-level repositories, and a real-world case study demonstrates effective recovery of critical business logics from legacy projects. The dataset is available at https://github.com/panrusheng/arch-eval-benchmark."}
{"id": "2601.13015", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13015", "abs": "https://arxiv.org/abs/2601.13015", "authors": ["Nowfel Mashnoor", "Mohammad Akyash", "Hadi Kamali", "Kimia Azar"], "title": "MeltRTL: Multi-Expert LLMs with Inference-time Intervention for RTL Code Generation", "comment": null, "summary": "The automated generation of hardware register-transfer level (RTL) code with large language models (LLMs) shows promise, yet current solutions struggle to produce syntactically and functionally correct code for complex digital designs. This paper introduces MeltRTL, a novel framework that integrates multi-expert attention with inference-time intervention (ITI) to significantly improve LLM-based RTL code generation accuracy without retraining the base model. MeltRTL introduces three key innovations: (1) A multi-expert attention architecture that dynamically routes design specifications to specialized expert networks, enabling targeted reasoning across various hardware categories; (2) An inference-time intervention mechanism that employs non-linear probes to detect and correct hardware-specific inaccuracies during generation; and (3) An efficient intervention framework that selectively operates on expert-specific attention heads with minimal computational overhead. We evaluate MeltRTL on the VerilogEval benchmark, achieving 96% synthesizability and 60% functional correctness, compared to the base LLM's 85.3% and 45.3%, respectively. These improvements are obtained entirely at inference time, with only 27% computational overhead and no model fine-tuning, making MeltRTL immediately deployable on existing pre-trained LLMs. Ablation studies further show the complementary benefits of multi-expert architecture and ITI, highlighting their synergistic effects when combined."}
{"id": "2601.13097", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.13097", "abs": "https://arxiv.org/abs/2601.13097", "authors": ["Elena Bruches", "Daniil Grebenkin", "Mikhail Klementev", "Vadim Alperovich", "Roman Derunets", "Dari Baturova", "Georgy Mkrtchyan", "Oleg Sedukhin", "Ivan Bondarenko", "Nikolay Bushkov", "Stanislav Moiseev"], "title": "RM -RF: Reward Model for Run-Free Unit Test Evaluation", "comment": "This paper has been accepted for publication at the 33rd IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER 2026)", "summary": "We present RM-RF, a lightweight reward model for run-free evaluation of automatically generated unit tests. Instead of repeatedly compiling and executing candidate tests, RM-RF predicts - from source and test code alone - three execution-derived signals: (1) whether the augmented test suite compiles and runs successfully, (2) whether the generated test cases increase code coverage, and (3) whether the generated test cases improve the mutation kill rate. To train and evaluate RM-RF we assemble a multilingual dataset (Java, Python, Go) of focal files, test files, and candidate test additions labeled by an execution-based pipeline, and we release an associated dataset and methodology for comparative evaluation. We tested multiple model families and tuning regimes (zero-shot, full fine-tuning, and PEFT via LoRA), achieving an average F1 of 0.69 across the three targets. Compared to conventional compile-and-run instruments, RM-RF provides substantially lower latency and infrastructure cost while delivering competitive predictive fidelity, enabling fast, scalable feedback for large-scale test generation and RL-based code optimization."}
{"id": "2601.13118", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13118", "abs": "https://arxiv.org/abs/2601.13118", "authors": ["Alessandro Midolo", "Alessandro Giagnorio", "Fiorella Zampetti", "Rosalia Tufano", "Gabriele Bavota", "Massimiliano Di Penta"], "title": "Guidelines to Prompt Large Language Models for Code Generation: An Empirical Characterization", "comment": null, "summary": "Large Language Models (LLMs) are nowadays extensively used for various types of software engineering tasks, primarily code generation. Previous research has shown how suitable prompt engineering could help developers in improving their code generation prompts. However, so far, there do not exist specific guidelines driving developers towards writing suitable prompts for code generation. In this work, we derive and evaluate development-specific prompt optimization guidelines. First, we use an iterative, test-driven approach to automatically refine code generation prompts, and we analyze the outcome of this process to identify prompt improvement items that lead to test passes. We use such elements to elicit 10 guidelines for prompt improvement, related to better specifying I/O, pre-post conditions, providing examples, various types of details, or clarifying ambiguities. We conduct an assessment with 50 practitioners, who report their usage of the elicited prompt improvement patterns, as well as their perceived usefulness, which does not always correspond to the actual usage before knowing our guidelines. Our results lead to implications not only for practitioners and educators, but also for those aimed at creating better LLM-aided software development tools."}
{"id": "2601.13134", "categories": ["cs.SE", "cs.CV"], "pdf": "https://arxiv.org/pdf/2601.13134", "abs": "https://arxiv.org/abs/2601.13134", "authors": ["Heng Fang", "Adam J. Stewart", "Isaac Corley", "Xiao Xiang Zhu", "Hossein Azizpour"], "title": "Earth Embeddings as Products: Taxonomy, Ecosystem, and Standardized Access", "comment": null, "summary": "Geospatial Foundation Models (GFMs) provide powerful representations, but high compute costs hinder their widespread use. Pre-computed embedding data products offer a practical \"frozen\" alternative, yet they currently exist in a fragmented ecosystem of incompatible formats and resolutions. This lack of standardization creates an engineering bottleneck that prevents meaningful model comparison and reproducibility. We formalize this landscape through a three-layer taxonomy: Data, Tools, and Value. We survey existing products to identify interoperability barriers. To bridge this gap, we extend TorchGeo with a unified API that standardizes the loading and querying of diverse embedding products. By treating embeddings as first-class geospatial datasets, we decouple downstream analysis from model-specific engineering, providing a roadmap for more transparent and accessible Earth observation workflows."}
{"id": "2601.13139", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13139", "abs": "https://arxiv.org/abs/2601.13139", "authors": ["Alessandro Midolo", "Emiliano Tramontana", "Massimiliano Di Penta"], "title": "From Human to Machine Refactoring: Assessing GPT-4's Impact on Python Class Quality and Readability", "comment": null, "summary": "Refactoring is a software engineering practice that aims to improve code quality without altering program behavior. Although automated refactoring tools have been extensively studied, their practical applicability remains limited. Recent advances in Large Language Models (LLMs) have introduced new opportunities for automated code refactoring. The evaluation of such an LLM-driven approach, however, leaves unanswered questions about its effects on code quality. In this paper, we present a comprehensive empirical study on LLM-driven refactoring using GPT-4o, applied to 100 Python classes from the ClassEval benchmark. Unlike prior work, our study explores a wide range of class-level refactorings inspired by Fowler's catalog and evaluates their effects from three complementary perspectives: (i) behavioral correctness, verified through unit tests; (ii) code quality, assessed via Pylint, Flake8, and SonarCloud; and (iii) readability, measured using a state-of-the-art readability tool. Our findings show that GPT-4o generally produces behavior-preserving refactorings that reduce code smells and improve quality metrics, albeit at the cost of decreased readability. Our results provide new evidence on the capabilities and limitations of LLMs in automated software refactoring, highlighting directions for integrating LLMs into practical refactoring workflows."}
{"id": "2601.13240", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.13240", "abs": "https://arxiv.org/abs/2601.13240", "authors": ["Xue Jiang", "Jiaru Qian", "Xianjie Shi", "Chenjie Li", "Hao Zhu", "Ziyu Wang", "Jielun Zhang", "Zheyu Zhao", "Kechi Zhang", "Jia Li", "Wenpin Jiao", "Zhi Jin", "Ge Li", "Yihong Dong"], "title": "KOCO-BENCH: Can Large Language Models Leverage Domain Knowledge in Software Development?", "comment": null, "summary": "Large language models (LLMs) excel at general programming but struggle with domain-specific software development, necessitating domain specialization methods for LLMs to learn and utilize domain knowledge and data. However, existing domain-specific code benchmarks cannot evaluate the effectiveness of domain specialization methods, which focus on assessing what knowledge LLMs possess rather than how they acquire and apply new knowledge, lacking explicit knowledge corpora for developing domain specialization methods. To this end, we present KOCO-BENCH, a novel benchmark designed for evaluating domain specialization methods in real-world software development. KOCO-BENCH contains 6 emerging domains with 11 software frameworks and 25 projects, featuring curated knowledge corpora alongside multi-granularity evaluation tasks including domain code generation (from function-level to project-level with rigorous test suites) and domain knowledge understanding (via multiple-choice Q&A). Unlike previous benchmarks that only provide test sets for direct evaluation, KOCO-BENCH requires acquiring and applying diverse domain knowledge (APIs, rules, constraints, etc.) from knowledge corpora to solve evaluation tasks. Our evaluations reveal that KOCO-BENCH poses significant challenges to state-of-the-art LLMs. Even with domain specialization methods (e.g., SFT, RAG, kNN-LM) applied, improvements remain marginal. Best-performing coding agent, Claude Code, achieves only 34.2%, highlighting the urgent need for more effective domain specialization methods. We release KOCO-BENCH, evaluation code, and baselines to advance further research at https://github.com/jiangxxxue/KOCO-bench."}
{"id": "2601.13334", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13334", "abs": "https://arxiv.org/abs/2601.13334", "authors": ["Tarik Houichime", "Younes El Amrani"], "title": "SEER: Spectral Entropy Encoding of Roles for Context-Aware Attention-Based Design Pattern Detection", "comment": null, "summary": "This paper presents SEER, an upgraded version of our prior method Context Is All You Need for detecting Gang of Four (GoF) design patterns from source code. The earlier approach modeled code as attention-ready sequences that blended lightweight structure with behavioral context; however, it lacked explicit role disambiguation within classes and treated call edges uniformly. SEER addresses these limitations with two principled additions: (i) a spectral-entropy role encoder that derives per-member role embeddings from the Laplacian spectrum of each class's interaction graph, and (ii) a time-weighted calling context that assigns empirically calibrated duration priors to method categories (e.g., constructors, getters/setters, static calls, virtual dispatch, cloning). Together, these components sharpen the model's notion of \"who does what\" and \"how much it matters,\" while remaining portable across languages with minimal adaptation and fully compatible with Transformer-based sequence encoders. Importantly, SEER does not \"force\" a win by capacity or data; it nudges the classifier, steering attention toward role-consistent and temporally calibrated signals that matter most. We evaluate SEER on PyDesignNet (1,832 files, 35,000 sequences, 23 GoF patterns) and observe consistent gains over our previous system: macro-F1 increases from 92.47% to 93.20% and accuracy from 92.52% to 93.98%, with macro-precision 93.98% and macro-recall 92.52%. Beyond aggregate metrics, SEER reduces false positives by nearly 20%, a decisive improvement that strengthens its robustness and practical reliability. Moreover, SEER yields interpretable, symbol-level attributions aligned with canonical roles, exhibits robustness under small graph perturbations, and shows stable calibration."}
{"id": "2601.13345", "categories": ["cs.SE", "cs.PF"], "pdf": "https://arxiv.org/pdf/2601.13345", "abs": "https://arxiv.org/abs/2601.13345", "authors": ["Saurabhsingh Rajput", "Alexander Brandt", "Vadim Elisseev", "Tushar Sharma"], "title": "FlipFlop: A Static Analysis-based Energy Optimization Framework for GPU Kernels", "comment": null, "summary": "Artificial Intelligence (AI) applications, such as Large Language Models, are primarily driven and executed by Graphics Processing Units (GPUs). These GPU programs (kernels) consume substantial amounts of energy, yet software developers often lack the hardware expertise and ad hoc knowledge required to optimize for power efficiency. We propose FlipFlop, a framework using static code analysis to predict energy consumption and recommend Pareto-optimal thread block configurations considering both power consumption and execution time. Our framework requires no runtime execution and analyzes PTX code, a low-level instruction set for CUDA-enabled GPUs. It is validated across a diverse set of GPUs and kernels, including multi-head attention, convolution, and matrix multiplication. FlipFlop achieves 83% accuracy in identifying locally optimal energy-efficient configurations, while also minimizing developer effort by reducing the optimization search space by 93.4%. For multi-head attention kernels, it yields up to 79% energy savings and 106% throughput gains relative to NVIDIA's occupancy heuristic. By integrating static analysis with real-time monitoring and providing explainable optimization guidance, FlipFlop empowers developers to create sustainable, high-performance GPU software which minimizes environmental and computational costs."}
{"id": "2601.13384", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2601.13384", "abs": "https://arxiv.org/abs/2601.13384", "authors": ["Jiajun Zhang", "Zeyu Cui", "Jiaxi Yang", "Lei Zhang", "Yuheng Jing", "Zeyao Ma", "Tianyi Bai", "Zilei Wang", "Qiang Liu", "Liang Wang", "Binyuan Hui", "Junyang Lin"], "title": "From Completion to Editing: Unlocking Context-Aware Code Infilling via Search-and-Replace Instruction Tuning", "comment": null, "summary": "The dominant Fill-in-the-Middle (FIM) paradigm for code completion is constrained by its rigid inability to correct contextual errors and reliance on unaligned, insecure Base models. While Chat LLMs offer safety and Agentic workflows provide flexibility, they suffer from performance degradation and prohibitive latency, respectively. To resolve this dilemma, we propose Search-and-Replace Infilling (SRI), a framework that internalizes the agentic verification-and-editing mechanism into a unified, single-pass inference process. By structurally grounding edits via an explicit search phase, SRI harmonizes completion tasks with the instruction-following priors of Chat LLMs, extending the paradigm from static infilling to dynamic context-aware editing. We synthesize a high-quality dataset, SRI-200K, and fine-tune the SRI-Coder series. Extensive evaluations demonstrate that with minimal data (20k samples), SRI-Coder enables Chat models to surpass the completion performance of their Base counterparts. Crucially, unlike FIM-style tuning, SRI preserves general coding competencies and maintains inference latency comparable to standard FIM. We empower the entire Qwen3-Coder series with SRI, encouraging the developer community to leverage this framework for advanced auto-completion and assisted development."}
{"id": "2601.13460", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13460", "abs": "https://arxiv.org/abs/2601.13460", "authors": ["Alexandra González", "Oscar Cerezo", "Xavier Franch", "Silverio Martínez-Fernández"], "title": "A Tool for Automatically Cataloguing and Selecting Pre-Trained Models and Datasets for Software Engineering", "comment": null, "summary": "The rapid growth of machine learning assets has made it increasingly difficult for software engineers to identify models and datasets that match their specific needs. Browsing large registries, such as Hugging Face, is time-consuming, error-prone, and rarely tailored to Software Engineering (SE) tasks. We present MLAssetSelection, a web application that automatically extracts SE assets and supports four key functionalities: (i) a configurable leaderboard for ranking models across multiple benchmarks and metrics; (ii) requirements-based selection of models and datasets; (iii) real-time automated updates through scheduled jobs that keep asset information current; and (iv) user-centric features including login, personalized asset lists, and configurable alert notifications. A demonstration video is available at https://youtu.be/t6CJ6P9asV4."}
{"id": "2601.13466", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13466", "abs": "https://arxiv.org/abs/2601.13466", "authors": ["Pedro Oliveira", "Doris Amoakohene", "Toby Hocking", "Marco Gerosa", "Igor Steinmacher"], "title": "Governance Matters: Lessons from Restructuring the data.table OSS Project", "comment": "ICSME 2025", "summary": "Open source software (OSS) forms the backbone of industrial data workflows and enterprise systems. However, many OSS projects face operational risks due to informal or centralized governance. This paper presents a practical case study of data.table, a high-performance R package widely adopted in production analytics pipelines, which underwent a community-led governance reform to address scalability and sustainability concerns. Before the reform, data.table faced a growing backlog of unresolved issues and open pull requests, unclear contributor pathways, and bottlenecks caused by reliance on a single core maintainer. In response, the community initiated a redesign of its governance structure. In this paper, we evaluated the impact of this transition through a mixed-methods approach, combining a contributor survey (n=17) with mining project repository data. Our results show that following the reform, the project experienced a 200% increase in new contributor recruitment, a drop in pull request resolution time from over 700 days to under a week, and a 3x increase in contributor retention. Community sentiment improved around transparency, onboarding, and project momentum, though concerns around fairness and conflict resolution remain. This case study provides practical guidance for maintainers, companies, and foundations seeking to enhance OSS governance."}
{"id": "2601.13597", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13597", "abs": "https://arxiv.org/abs/2601.13597", "authors": ["Shyam Agarwal", "Hao He", "Bogdan Vasilescu"], "title": "AI IDEs or Autonomous Agents? Measuring the Impact of Coding Agents on Software Development", "comment": null, "summary": "Large language model (LLM)-based coding agents increasingly act as autonomous contributors that generate and merge pull requests, yet their real-world effects on software projects are unclear, especially relative to widely adopted IDE-based AI assistants. We present a longitudinal causal study of agent adoption in open-source repositories using staggered difference-in-differences with matched controls. Using the AIDev dataset, we define adoption as the first agent-generated pull request and analyze monthly repository-level outcomes spanning development velocity (commits, lines added) and software quality (static-analysis warnings, cognitive complexity, duplication, and comment density). Results show large, front-loaded velocity gains only when agents are the first observable AI tool in a project; repositories with prior AI IDE usage experience minimal or short-lived throughput benefits. In contrast, quality risks are persistent across settings, with static-analysis warnings and cognitive complexity rising roughly 18% and 35%, indicating sustained agent-induced complexity debt even when velocity advantages fade. These heterogeneous effects suggest diminishing returns to AI assistance and highlight the need for quality safeguards, provenance tracking, and selective deployment of autonomous agents. Our findings establish an empirical basis for understanding how agentic and IDE-based tools interact, and motivate research on balancing acceleration with maintainability in AI-integrated development workflows."}
{"id": "2601.13655", "categories": ["cs.SE", "cs.AI", "cs.DC"], "pdf": "https://arxiv.org/pdf/2601.13655", "abs": "https://arxiv.org/abs/2601.13655", "authors": ["Guangba Yu", "Zirui Wang", "Yujie Huang", "Renyi Zhong", "Yuedong Zhong", "Yilun Wang", "Michael R. Lyu"], "title": "Why Does the LLM Stop Computing: An Empirical Study of User-Reported Failures in Open-Source LLMs", "comment": null, "summary": "The democratization of open-source Large Language Models (LLMs) allows users to fine-tune and deploy models on local infrastructure but exposes them to a First Mile deployment landscape. Unlike black-box API consumption, the reliability of user-managed orchestration remains a critical blind spot. To bridge this gap, we conduct the first large-scale empirical study of 705 real-world failures from the open-source DeepSeek, Llama, and Qwen ecosystems.\n  Our analysis reveals a paradigm shift: white-box orchestration relocates the reliability bottleneck from model algorithmic defects to the systemic fragility of the deployment stack. We identify three key phenomena: (1) Diagnostic Divergence: runtime crashes distinctively signal infrastructure friction, whereas incorrect functionality serves as a signature for internal tokenizer defects. (2) Systemic Homogeneity: Root causes converge across divergent series, confirming reliability barriers are inherent to the shared ecosystem rather than specific architectures. (3) Lifecycle Escalation: Barriers escalate from intrinsic configuration struggles during fine-tuning to compounded environmental incompatibilities during inference. Supported by our publicly available dataset, these insights provide actionable guidance for enhancing the reliability of the LLM landscape."}
{"id": "2601.13682", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2601.13682", "abs": "https://arxiv.org/abs/2601.13682", "authors": ["Jianfeng Cai", "Jinhua Zhu", "Ruopei Sun", "Kangwen Zhao", "Dongyun Xue", "Mingxiao Feng", "Wengang Zhou", "Houqiang Li"], "title": "CodeContests-O: Powering LLMs via Feedback-Driven Iterative Test Case Generation", "comment": null, "summary": "The rise of reasoning models necessitates large-scale verifiable data, for which programming tasks serve as an ideal source. However, while competitive programming platforms provide abundant problems and solutions, high-quality test cases for verification remain scarce. Existing approaches attempt to synthesize test cases using Large Language Models (LLMs), but rely solely on the model's intrinsic generation capabilities without external feedback, frequently resulting in insufficiently diverse cases. To address this limitation, we propose a $\\textbf{Feedback-Driven Iterative Framework}$ for comprehensive test case construction. Specifically, our method leverages the LLM to generate initial test cases, executes them against known correct and incorrect solutions, and utilizes the failed results as feedback to guide the LLM in refining the test cases toward high fidelity and discriminability. We then apply this method to the CodeContests dataset to construct an optimized high-quality derivative, $\\textbf{CodeContests-O}$. Evaluating against the entire pool of solutions ($1.1 \\times 10^7$ in total), our dataset achieves an average True Positive Rate (TPR) of $89.37\\%$ and True Negative Rate (TNR) of $90.89\\%$, significantly outperforming the CodeContests and CodeContests+ by margins of $4.32\\%$ and $9.37\\%$, respectively. Furthermore, fine-tuning the Qwen2.5-7B model on CodeContests-O results in a $9.52\\%$ improvement on LiveCodeBench (Pass@1). Experiments demonstrate the effectiveness of our framework and the quality of CodeContests-O. To support reproducibility and facilitate future research, we release the $\\href{https://github.com/cai-jianfeng/CodeContests-O}{code}$ and $\\href{https://huggingface.co/datasets/caijanfeng/CodeContests-O}{dataset}$."}
{"id": "2601.13713", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.13713", "abs": "https://arxiv.org/abs/2601.13713", "authors": ["Aditya Bharat Soni", "Rajat Ghosh", "Vaishnavi Bhargava", "Valerie Chen", "Debojyoti Dutta"], "title": "SWE-Tester: Training Open-Source LLMs for Issue Reproduction in Real-World Repositories", "comment": null, "summary": "Software testing is crucial for ensuring the correctness and reliability of software systems. Automated generation of issue reproduction tests from natural language issue descriptions enhances developer productivity by simplifying root cause analysis, promotes test-driven development -- \"test first, write code later\", and can be used for improving the effectiveness of automated issue resolution systems like coding agents. Existing methods proposed for this task predominantly rely on closed-source LLMs, with limited exploration of open models. To address this, we propose SWE-Tester -- a novel pipeline for training open-source LLMs to generate issue reproduction tests. First, we curate a high-quality training dataset of 41K instances from 2.6K open-source GitHub repositories and use it to train LLMs of varying sizes and families. The fine-tuned models achieve absolute improvements of up to 10\\% in success rate and 21\\% in change coverage on SWT-Bench Verified. Further analysis shows consistent improvements with increased inference-time compute, more data, and larger models. These results highlight the effectiveness of our framework for advancing open-source LLMs in this domain."}
{"id": "2601.13743", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13743", "abs": "https://arxiv.org/abs/2601.13743", "authors": ["Zhenya Zhang", "Parv Kapoor", "Jie An", "Eunsuk Kang"], "title": "Counterexample Classification against Signal Temporal Logic Specifications", "comment": null, "summary": "Signal Temporal Logic (STL) has been widely adopted as a specification language for specifying desirable behaviors of hybrid systems. By monitoring a given STL specification, we can detect the executions that violate it, which are often referred to as counterexamples. In practice, these counterexamples may arise from different causes and thus are relevant to different system defects. To effectively address this, we need a proper criterion for classifying these counterexamples, by which we can comprehend the possible violation patterns and the distributions of these counterexamples with respect to the patterns. In this paper, we propose a classification criterion by using parametric signal temporal logic (PSTL) to represent each class. Due to this formalism, identifying the classes of a counterexample requires finding proper parameter values of PSTL that enable a class to include the counterexample. To improve the efficiency of class identification, we further derive an inclusion relation between different classes, and then propose a binary search-like approach over it that significantly prunes the classes needed to query. We implement a prototype tool and experimentally evaluate its effectiveness on two widely-studied systems."}
{"id": "2601.13754", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13754", "abs": "https://arxiv.org/abs/2601.13754", "authors": ["Haoyu Gao", "Peerachai Banyongrakkul", "Hao Guan", "Mansooreh Zahedi", "Christoph Treude"], "title": "On Autopilot? An Empirical Study of Human-AI Teaming and Review Practices in Open Source", "comment": "accepted as MSR short paper", "summary": "Large Language Models (LLMs) increasingly automate software engineering tasks. While recent studies highlight the accelerated adoption of ``AI as a teammate'' in Open Source Software (OSS), developer interaction patterns remain under-explored. In this work, we investigated project-level guidelines and developers' interactions with AI-assisted pull requests (PRs) by expanding the AIDev dataset to include finer-grained contributor code ownership and a comparative baseline of human-created PRs. We found that over 67.5\\% of AI-co-authored PRs originate from contributors without prior code ownership. Despite this, the majority of repositories lack guidelines for AI-coding agent usage. Notably, we observed a distinct interaction pattern: AI-co-authored PRs are merged significantly faster with minimal feedback. In contrast to human-created PRs where non-owner developers receive the most feedback, AI-co-authored PRs from non-owners receive the least, with approximately 80\\% merged without any explicit review. Finally, we discuss implications for developers and researchers."}
{"id": "2601.13772", "categories": ["cs.SE", "cs.DC", "cs.SI", "eess.SY"], "pdf": "https://arxiv.org/pdf/2601.13772", "abs": "https://arxiv.org/abs/2601.13772", "authors": ["Matteo Vaccargiu", "Azmat Ullah", "Pierluigi Gallo"], "title": "A Blockchain-Oriented Software Engineering Architecture for Carbon Credit Certification Systems", "comment": "2026 IEEE International Conference on Software Analysis, Evolution and Reengineering - Companion (SANER-C) 9th International Workshop on Blockchain Oriented Software Engineering March 17-20, 2026 Limassol, Cyprus", "summary": "Carbon credit systems have emerged as a policy tool to incentivize emission reductions and support the transition to clean energy. Reliable carbon-credit certification depends on mechanisms that connect actual, measured renewable-energy production to verifiable emission-reduction records. Although blockchain and IoT technologies have been applied to emission monitoring and trading, existing work offers limited support for certification processes, particularly for small and medium-scale renewable installations. This paper introduces a blockchain-based carbon-credit certification architecture, demonstrated through a 100 kWp photovoltaic case study, that integrates real-time IoT data collection, edge-level aggregation, and secure on-chain storage on a permissioned blockchain with smart contracts. Unlike approaches focused on trading mechanisms, the proposed system aligns with European legislation and voluntary carbon-market standards, clarifying the practical requirements and constraints that apply to photovoltaic operators. The resulting architecture provides a structured pathway for generating verifiable carbon-credit records and supporting third-party verification."}
{"id": "2601.13894", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13894", "abs": "https://arxiv.org/abs/2601.13894", "authors": ["Alisa Welter", "Christof Tinnes", "Sven Apel"], "title": "Multi-Location Software Model Completion", "comment": "Accepted at the 48th IEEE/ACM International Conference on Software Engineering (ICSE 2026) - Research Track", "summary": "In model-driven engineering and beyond, software models are key development artifacts. In practice, they often grow to substantial size and complexity, undergoing thousands of modifications over time due to evolution, refactoring, and maintenance. The rise of AI has sparked interest in how software modeling activities can be automated. Recently, LLM-based approaches for software model completion have been proposed, however, the state of the art supports only single-location model completion by predicting changes at a specific location. Going beyond, we aim to bridge the gap toward handling coordinated changes that span multiple locations across large, complex models. Specifically, we propose a novel global embedding-based next focus predictor, NextFocus, which is capable of multi-location model completion for the first time. The predictor consists of a neural network with an attention mechanism that is trained on historical software model evolution data. Starting from an existing change, it predicts further model elements to change, potentially spanning multiple parts of the model. We evaluate our approach on multi-location model changes that have actually been performed by developers in real-world projects. NextFocus achieves promising results for multi-location model completion, even when changes are heavily spread across the model. It achieves an average Precision@k score of 0.98 for $k \\leq 10$, significantly outperforming the three baseline approaches."}
{"id": "2601.13933", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13933", "abs": "https://arxiv.org/abs/2601.13933", "authors": ["Mingming Zhang", "Xu Wang", "Jian Zhang", "Xiangxin Meng", "Jiayi Zhang", "Chunming Hu"], "title": "VulnResolver: A Hybrid Agent Framework for LLM-Based Automated Vulnerability Issue Resolution", "comment": null, "summary": "As software systems grow in complexity, security vulnerabilities have become increasingly prevalent, posing serious risks and economic costs. Although automated detection tools such as fuzzers have advanced considerably, effective resolution still often depends on human expertise. Existing automated vulnerability repair (AVR) methods rely heavily on manually provided annotations (e.g., fault locations or CWE labels), which are often difficult and time-consuming to obtain, while overlooking the rich, naturally embedded semantic context found in issue reports from developers.\n  In this paper, we present VulnResolver, the first LLM-based hybrid agent framework for automated vulnerability issue resolution. VulnResolver unites the adaptability of autonomous agents with the stability of workflow-guided repair through two specialized agents. The Context Pre-Collection Agent (CPCAgent) adaptively explores the repository to gather dependency and contextual information, while the Safety Property Analysis Agent (SPAAgent) generates and validates the safety properties violated by vulnerabilities. Together, these agents produce structured analyses that enrich the original issue reports, enabling more accurate vulnerability localization and patch generation.\n  Evaluations on the SEC-bench benchmark show that VulnResolver resolves 75% of issues on SEC-bench Lite, achieving the best resolution performance. On SEC-bench Full, VulnResolver also significantly outperforms the strongest baseline, the agent-based OpenHands, confirming its effectiveness. Overall, VulnResolver delivers an adaptive and security-aware framework that advances end-to-end automated vulnerability issue resolution through workflow stability and the specialized agents' capabilities in contextual reasoning and property-based analysis."}
{"id": "2601.13943", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13943", "abs": "https://arxiv.org/abs/2601.13943", "authors": ["Zhiyuan Peng", "Xin Yin", "Pu Zhao", "Fangkai Yang", "Lu Wang", "Ran Jia", "Xu Chen", "Qingwei Lin", "Saravan Rajmohan", "Dongmei Zhang"], "title": "RepoGenesis: Benchmarking End-to-End Microservice Generation from Readme to Repository", "comment": null, "summary": "Large language models and agents have achieved remarkable progress in code generation. However, existing benchmarks focus on isolated function/class-level generation (e.g., ClassEval) or modifications to existing codebases (e.g., SWE-Bench), neglecting complete microservice repository generation that reflects real-world 0-to-1 development workflows. To bridge this gap, we introduce RepoGenesis, the first multilingual benchmark for repository-level end-to-end web microservice generation, comprising 106 repositories (60 Python, 46 Java) across 18 domains and 11 frameworks, with 1,258 API endpoints and 2,335 test cases verified through a \"review-rebuttal\" quality assurance process. We evaluate open-source agents (e.g., DeepCode) and commercial IDEs (e.g., Cursor) using Pass@1, API Coverage (AC), and Deployment Success Rate (DSR). Results reveal that despite high AC (up to 73.91%) and DSR (up to 100%), the best-performing system achieves only 23.67% Pass@1 on Python and 21.45% on Java, exposing deficiencies in architectural coherence, dependency management, and cross-file consistency. Notably, GenesisAgent-8B, fine-tuned on RepoGenesis (train), achieves performance comparable to GPT-5 mini, demonstrating the quality of RepoGenesis for advancing microservice generation. We release our benchmark at https://github.com/pzy2000/RepoGenesis."}
{"id": "2601.13996", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.13996", "abs": "https://arxiv.org/abs/2601.13996", "authors": ["Rui Abreu", "Shaukat Ali", "Paolo Arcaini", "Jose Campos", "Michael Felderer", "Claude Gravel", "Fuyuki Ishikawa", "Stefan Klikovits", "Andriy Miranskyy", "Mohammad Mousavi", "Masaomi Yamaguchi", "Lei Zhang", "Jianjun Zhao", "Anila Mjeda"], "title": "Software Testing in the Quantum World", "comment": null, "summary": "Quantum computing offers significant speedups for simulating physical, chemical, and biological systems, and for optimization and machine learning. As quantum software grows in complexity, the classical simulation of quantum computers, which has long been essential for quality assurance, becomes infeasible. This shift requires new quality-assurance methods that operate directly on real quantum computers. This paper presents the key challenges in testing large-scale quantum software and offers software engineering perspectives for addressing them."}
{"id": "2601.14034", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.14034", "abs": "https://arxiv.org/abs/2601.14034", "authors": ["Alexandros Tsakpinis", "Alexander Pretschner"], "title": "Analyzing the Availability of E-Mail Addresses for PyPI Libraries", "comment": "6 pages, 4 figures", "summary": "Open Source Software (OSS) libraries form the backbone of modern software systems, yet their long-term sustainability often depends on maintainers being reachable for support, coordination, and security reporting. In this paper, we empirically analyze the availability of contact information - specifically e-mail addresses - across 686,034 Python libraries on the Python Package Index (PyPI) and their associated GitHub repositories. We examine how and where maintainers provide this information, assess its validity, and explore coverage across individual libraries and their dependency chains. Our findings show that 81.6% of libraries include at least one valid e-mail address, with PyPI serving as the primary source (79.5%). When analyzing dependency chains, we observe that up to 97.8% of direct and 97.7% of transitive dependencies provide valid contact information. At the same time, we identify over 698,000 invalid entries, primarily due to missing fields. These results demonstrate strong maintainer reachability across the ecosystem, while highlighting opportunities for improvement - such as offering clearer guidance to maintainers during the packaging process and introducing opt-in validation mechanisms for existing e-mail addresses."}
{"id": "2601.14081", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.14081", "abs": "https://arxiv.org/abs/2601.14081", "authors": ["Xingcheng Chen", "Oliver Weissl", "Andrea Stocco"], "title": "Feature-Aware Test Generation for Deep Learning Models", "comment": null, "summary": "As deep learning models are widely used in software systems, test generation plays a crucial role in assessing the quality of such models before deployment. To date, the most advanced test generators rely on generative AI to synthesize inputs; however, these approaches remain limited in providing semantic insight into the causes of misbehaviours and in offering fine-grained semantic controllability over the generated inputs. In this paper, we introduce Detect, a feature-aware test generation framework for vision-based deep learning (DL) models that systematically generates inputs by perturbing disentangled semantic attributes within the latent space. Detect perturbs individual latent features in a controlled way and observes how these changes affect the model's output. Through this process, it identifies which features lead to behavior shifts and uses a vision-language model for semantic attribution. By distinguishing between task-relevant and irrelevant features, Detect applies feature-aware perturbations targeted for both generalization and robustness. Empirical results across image classification and detection tasks show that Detect generates high-quality test cases with fine-grained control, reveals distinct shortcut behaviors across model architectures (convolutional and transformer-based), and bugs that are not captured by accuracy metrics. Specifically, Detect outperforms a state-of-the-art test generator in decision boundary discovery and a leading spurious feature localization method in identifying robustness failures. Our findings show that fully fine-tuned convolutional models are prone to overfitting on localized cues, such as co-occurring visual traits, while weakly supervised transformers tend to rely on global features, such as environmental variances. These findings highlight the value of interpretable and feature-aware testing in improving DL model reliability."}
{"id": "2601.14131", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.14131", "abs": "https://arxiv.org/abs/2601.14131", "authors": ["Amila Indika", "Rick Kazman", "Anthony Peruma"], "title": "Practitioner Views on Mobile App Accessibility: Practices and Challenges", "comment": "The 48th IEEE/ACM International Conference on Software Engineering - Research Track", "summary": "As mobile applications (apps) become ubiquitous in everyday life, it is crucial for developers to prioritize accessibility for users with diverse abilities. While previous research has identified widespread accessibility issues and raised awareness of developer challenges, there remains a lack of cross-platform, globally representative insights into how practitioners approach accessibility in practice. This paper presents findings from a mixed-methods survey of 110 mobile app developers across 43 countries, examining how platform ecosystems (iOS vs. Android) and developer experience shape accessibility practices. Results show that while developers recognize the importance of accessibility, they often rely on platform-specific guidelines and typically perform compliance testing late in the development process. Developers primarily implement text-focused features while struggling with API limitations and organizational constraints. Through systematic cross-platform comparison, we identify novel platform-specific barriers and demonstrate how accessibility practices differ across developer experience levels. Our findings offer new insights into the challenges of achieving accessibility in practice and provide actionable steps for various stakeholders to promote more consistent and inclusive app development."}
{"id": "2601.14132", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.14132", "abs": "https://arxiv.org/abs/2601.14132", "authors": ["Rodrigo Falcão", "Frank Elberzhager", "Karthik Vaidhyanathan"], "title": "Toward self-coding information systems", "comment": "Accepted for ICSE 2026 Track \"Software Architecture BoF\"", "summary": "In this extended abstract, we propose a novel research topic in the field of agentic AI, which we refer to as self-coding information systems. These systems will be able to dynamically adapt their structure or behavior by evaluating potential adaptation decisions, generate source code, test, and (re)deploy their source code autonomously, at runtime, reducing the time to market of new features. Here we motivate the topic, provide a formal definition of self-coding information systems, discuss some expected impacts of the new technology, and indicate potential research directions."}
{"id": "2601.14163", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2601.14163", "abs": "https://arxiv.org/abs/2601.14163", "authors": ["Mohammed Latif Siddiq", "Tanzim Hossain Romel", "Natalie Sekerak", "Beatrice Casey", "Joanna C. S. Santos"], "title": "An Empirical Study on Remote Code Execution in Machine Learning Model Hosting Ecosystems", "comment": null, "summary": "Model-sharing platforms, such as Hugging Face, ModelScope, and OpenCSG, have become central to modern machine learning development, enabling developers to share, load, and fine-tune pre-trained models with minimal effort. However, the flexibility of these ecosystems introduces a critical security concern: the execution of untrusted code during model loading (i.e., via trust_remote_code or trust_repo). In this work, we conduct the first large-scale empirical study of custom model loading practices across five major model-sharing platforms to assess their prevalence, associated risks, and developer perceptions. We first quantify the frequency with which models require custom code to function and identify those that execute arbitrary Python files during loading. We then apply three complementary static analysis tools: Bandit, CodeQL, and Semgrep, to detect security smells and potential vulnerabilities, categorizing our findings by CWE identifiers to provide a standardized risk taxonomy. We also use YARA to identify malicious patterns and payload signatures. In parallel, we systematically analyze the documentation, API design, and safety mechanisms of each platform to understand their mitigation strategies and enforcement levels. Finally, we conduct a qualitative analysis of over 600 developer discussions from GitHub, Hugging Face, and PyTorch Hub forums, as well as Stack Overflow, to capture community concerns and misconceptions regarding security and usability. Our findings reveal widespread reliance on unsafe defaults, uneven security enforcement across platforms, and persistent confusion among developers about the implications of executing remote code. We conclude with actionable recommendations for designing safer model-sharing infrastructures and striking a balance between usability and security in future AI ecosystems."}
