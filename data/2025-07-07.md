<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 16]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [How do Software Engineering Candidates Prepare for Technical Interviews?](https://arxiv.org/abs/2507.02068)
*Brian Bell,Teresa Thomas,Sang Won Lee,Chris Brown*

Main category: cs.SE

TL;DR: Most software engineering candidates feel unprepared and stressed for technical interviews due to lack of authentic practice and insufficient curricular support, highlighting a need for educational enhancements.


<details>
  <summary>Details</summary>
Motivation: There is a gap between the requirements of technical interviews for software engineering roles and the training provided by computing curricula, making the process challenging and stressful for candidates.

Method: A survey was distributed to 131 candidates actively preparing for technical interviews to gather data about their preparation methods and perceptions regarding the support offered by education.

Result: Candidates typically do not practice interview skills in realistic, authentic contexts, and formal courses provide minimal support, resulting in poor preparation and high anxiety.

Conclusion: Courses and traditional computing curricula do not adequately prepare candidates for the unique challenges of technical interviews, leading to feelings of stress and unpreparedness among job seekers.

Abstract: To obtain employment, aspiring software engineers must complete technical
interviews -- a hiring process which involves candidates writing code while
communicating to an audience. However, the complexities of tech interviews are
difficult to prepare for and seldom faced in computing curricula. To this end,
we seek to understand how candidates prepare for technical interviews,
investigating the effects of preparation methods and the role of education. We
distributed a survey to candidates (n = 131) actively preparing for technical
interviews. Our results suggest candidates rarely train in authentic settings
and courses fail to support preparation efforts -- leading to stress and
unpreparedness. Based on our findings, we provide implications for stakeholders
to enhance tech interview preparation for candidates pursuing software
engineering roles.

</details>


### [2] [Structural Code Search using Natural Language Queries](https://arxiv.org/abs/2507.02107)
*Ben Limpanukorn,Yanjun Wang,Zach Patterson,Pranav Garg,Murali Krishna Ramanathan,Xiaofei Ma,Anoop Deoras,Miryung Kim*

Main category: cs.SE

TL;DR: This paper presents a method for using natural language to search code structurally by translating queries through a large language model. It improves both accessibility and effectiveness in code search, outperforming existing techniques on multiple benchmarks.


<details>
  <summary>Details</summary>
Motivation: Developers often need to search code for understanding APIs, finding patterns, or refactoring. While structural code search is powerful, its reliance on domain-specific languages (DSLs) makes it inaccessible to many. Using natural language would make code search more intuitive and lower barriers to use.

Method: The authors introduce an approach that uses a large language model (LLM) to translate natural language (NL) queries into structural search DSL queries, specifically for Semgrep and GQL tools. They benchmark this method using 400 queries across 10 Java projects, comparing it with traditional semantic code search and direct LLM retrievals.

Result: The proposed method achieves high precision and recall (55%-70%), and it outperforms semantic code search and direct LLM retrievals, with up to 57% and 14% improvements in F1 score, respectively.

Conclusion: Translating natural language code search queries into structural DSL queries via LLMs is both effective and efficient, surpassing existing methods and making structural code search more accessible.

Abstract: Searching code is a common task that developers perform to understand APIs,
learn common code patterns, and navigate code. Currently, developers most
commonly search using keywords and regular expressions that are easy to use and
widely available. Beyond keywords and regular expressions, structural code
search tools allow developers to search for code based on its syntactic
structure. This has numerous applications ranging from bug finding to
systematically refactoring code. However, these structural code search tools
operate on queries expressed in domain-specific languages (DSL) that can be
difficult to learn and write. We propose to allow developers to use natural
language to search for code structurally. Expressing queries in natural
language provides an intuitive way to search for code and lowers the barrier to
entry.
  In this work, we develop a novel general approach that combines the reasoning
capabilities of an LLM to interpret natural language search queries with the
power of structural search tools to efficiently and accurately retrieve
relevant code. We then instantiate this approach for two structural code search
DSLs: Semgrep and GQL. In our evaluation, we construct a new benchmark for
structural code search consisting of 400 queries over 10 Java projects. We show
that our approach for structural code search based on translating NL queries to
DSL queries using an LLM is effective and robust, achieving a high precision
and recall ranging from 55% - 70%. Further, our approach significantly
outperforms baselines based on semantic code search and LLM retrievals by up to
57% and 14% on F1 scores.

</details>


### [3] [Can Internal Software Metrics Predict App Popularity at Launch? Yeas! and Nays!](https://arxiv.org/abs/2507.02110)
*Md Nahidul Islam Opu,Fatima Islam Mouri,Rick Kazman,Yuanfang Cai,Shaiful Chowdhury*

Main category: cs.SE

TL;DR: By applying ML models to code metrics and metadata from pre-release Android apps, the study finds that classification models can reasonably predict app popularity, overturning past doubts about the predictive value of internal metrics.


<details>
  <summary>Details</summary>
Motivation: Predicting mobile app popularity before release can give developers a strategic advantage, but methods to achieve this are not well-established. Previous work generally dismissed internal code metrics as useful predictors.

Method: Collected internal code metrics and metadata from 446 open-source Android apps, augmented with Play Store data. Evaluated various regression and classification models using different feature sets: Size-only, Handpicked, and Voting feature selection.

Result: Regression models using these features performed poorly due to skewed data distribution, but binary classification into Popular vs. Unpopular worked notably better. The best model (Multilayer Perceptron with Voting set features) achieved an F1-score of 0.72, showing internal code metrics have predictive value.

Conclusion: Internal code metrics, despite previous skepticism, can help indicate app popularity in a classification setting, though their explanatory power is limited.

Abstract: Predicting mobile app popularity before release can provide developers with a
strategic advantage in a competitive marketplace, yet it remains a challenging
problem. This study explores whether internal software metrics, measurable from
source code before deployment, can predict an app's popularity, defined by user
ratings (calculated from user reviews) and DownloadsPerYear (yearly downloads).
Using a dataset of 446 open-source Android apps from F-Droid, we extract a wide
array of features, including system-, class-, and method-level code metrics,
code smells, and app metadata. Additional information, such as user reviews,
download counts, and uses-permission, was collected from the Google Play Store.
We evaluate regression and classification models across three feature sets: a
minimal Size-only baseline, a domain-informed Handpicked set, and a Voting set
derived via feature selection algorithms. Regression models perform poorly due
to skewed data, with low $R^2$ scores. However, when reframed as binary
classification (Popular vs. Unpopular), results improve significantly. The best
model, a Multilayer Perceptron using the Voting set, achieves F1-scores of
0.72. These results suggest that internal code metrics, although limited in
their explanatory power, can serve as useful indicators of app popularity. This
challenges earlier findings that dismissed internal metrics as predictors of
software quality.

</details>


### [4] [A Multimodal Approach Combining Biometrics and Self-Report Instruments for Monitoring Stress in Programming: Methodological Insights](https://arxiv.org/abs/2507.02118)
*Cristina Martinez Montes,Daniela Grassi,Nicole Novielli,Birgit Penzenstadle*

Main category: cs.SE

TL;DR: Self-reports, interviews, and biometrics (except for one EDA measure) found little evidence of stress from stricter time limits in programming tasks; future research should refine stress-induction methods and measurement combinations.


<details>
  <summary>Details</summary>
Motivation: Traditional methods for studying well-being and stress rely heavily on self-report instruments, which can have biases despite validation. This has sparked interest in combining these with physiological (biometric) measures for a more objective view.

Method: The authors conducted an experiment where participants completed a pre-survey, performed programming tasks under biometric monitoring, and completed post-task surveys and an exit interview to compare psychometric (self-reported) and biometric (physiological) stress indicators.

Result: Self-reported surveys indicated no stress, interviews revealed mixed experiences (no stress or only time pressure), and biometric data showed a significant difference only in EDA phasic peaks—otherwise no strong biometric indicators of stress found.

Conclusion: The method of stress induction (stricter time limit) was insufficient to elicit measurable stress. The study provides methodological recommendations for future research using stress-induction, psychometric, and biometric approaches.

Abstract: The study of well-being, stress and other human factors has traditionally
relied on self-report instruments to assess key variables. However, concerns
about potential biases in these instruments, even when thoroughly validated and
standardised, have driven growing interest in alternatives in combining these
measures with more objective methods, such as physiological measures.
  We aimed to (i) compare psychometric stress measures and biometric indicators
and (ii) identify stress-related patterns in biometric data during software
engineering tasks.
  We conducted an experiment where participants completed a pre-survey, then
programmed two tasks wearing biometric sensors, answered brief post-surveys for
each, and finally went through a short exit interview.
  Our results showed diverse outcomes; we found no stress in the psychometric
instruments. Participants in the interviews reported a mix of feeling no stress
and experiencing time pressure. Finally, the biometrics showed a significant
difference only in EDA phasic peaks.
  We conclude that our chosen way of inducing stress by imposing a stricter
time limit was insufficient. We offer methodological insights for future
studies working with stress, biometrics, and psychometric instruments.

</details>


### [5] [Towards Trustworthy Sentiment Analysis in Software Engineering: Dataset Characteristics and Tool Selection](https://arxiv.org/abs/2507.02137)
*Martin Obaidi,Marc Herrmann,Jil Klünder,Kurt Schneider*

Main category: cs.SE

TL;DR: The paper finds that sentiment analysis tool performance varies across communication platforms in software engineering due to differences in dataset features. By analyzing 10 datasets and 14 tools, the authors develop a tool recommender based on dataset characteristics, improving sentiment analysis reliability. Transformer models perform well, but context remains crucial, and ongoing evaluation is recommended.


<details>
  <summary>Details</summary>
Motivation: Software development teams communicate mostly via text, making sentiment analysis crucial for understanding team dynamics and ensuring reliable analytics. However, current sentiment analysis tools perform inconsistently on datasets from different platforms due to different communication styles and linguistic features.

Method: The authors analyzed linguistic and statistical features from 10 developer communication datasets spanning five platforms. They then evaluated 14 sentiment analysis tools on these datasets, and developed a mapping approach and accompanying questionnaire to recommend suitable tools for new datasets based on their specific characteristics.

Result: Their findings reveal that differences in platform-specific linguistic and statistical features significantly affect the efficacy of sentiment analysis tools. Transformer-based models like SetFit and RoBERTa performed well overall, but optimal tool choice still depends on the specific context. The proposed approach helps users select appropriate sentiment analysis tools, emphasizing the importance of ongoing tool evaluation.

Conclusion: Dataset characteristics are key to selecting effective sentiment analysis tools for software engineering contexts. A mapping-based recommendation system can guide researchers and practitioners towards more reliable sentiment analysis, but continuous assessment is necessary as communication evolves.

Abstract: Software development relies heavily on text-based communication, making
sentiment analysis a valuable tool for understanding team dynamics and
supporting trustworthy AI-driven analytics in requirements engineering.
However, existing sentiment analysis tools often perform inconsistently across
datasets from different platforms, due to variations in communication style and
content.
  In this study, we analyze linguistic and statistical features of 10 developer
communication datasets from five platforms and evaluate the performance of 14
sentiment analysis tools. Based on these results, we propose a mapping approach
and questionnaire that recommends suitable sentiment analysis tools for new
datasets, using their characteristic features as input.
  Our results show that dataset characteristics can be leveraged to improve
tool selection, as platforms differ substantially in both linguistic and
statistical properties. While transformer-based models such as SetFit and
RoBERTa consistently achieve strong results, tool effectiveness remains
context-dependent. Our approach supports researchers and practitioners in
selecting trustworthy tools for sentiment analysis in software engineering,
while highlighting the need for ongoing evaluation as communication contexts
evolve.

</details>


### [6] [Enhancing COBOL Code Explanations: A Multi-Agents Approach Using Large Language Models](https://arxiv.org/abs/2507.02182)
*Fangjian Lei,Jiawen Liu,Shayan Noei,Ying Zou,Derek Truong,William Alexander*

Main category: cs.SE

TL;DR: A new multi-agent system using LLMs explains COBOL code more effectively, outperforming baselines and aiding maintainability, especially for large or poorly documented codebases.


<details>
  <summary>Details</summary>
Motivation: COBOL remains critical for business, government, and financial systems, but its age, complexity, and the scarcity of COBOL developers pose challenges for maintenance, especially due to poor documentation. Existing code explanation techniques with LLMs are hindered by COBOL's unique syntax and length, exceeding typical LLM token windows.

Method: The authors propose a novel multi-agent system using two LLM-based agents that collaborate to generate explanations at the function, file, and project levels. These agents share contextual information from across the codebase to improve explanation accuracy, specifically tailored to accommodate COBOL's architectural and syntactical challenges.

Result: Tested on 14 open-source COBOL projects, the approach significantly outperforms the baseline in code explanation quality, with notable gains in METEOR, chrF, and SentenceBERT metrics for functions. At the file level, it effectively explains longer COBOL files, surpassing baseline explanations in purpose, functionality, and clarity. At the project level, 82% of projects received comprehensive explanations on functionality and purpose.

Conclusion: The multi-agent LLM-based approach proves to be a superior solution for generating meaningful documentation and explanations for COBOL codebases, facilitating understanding and maintainability despite token window limitations and COBOL-specific challenges.

Abstract: Common Business Oriented Language (COBOL) is a programming language used to
develop business applications that are widely adopted by financial, business,
and government agencies. Due to its age, complexity, and declining number of
COBOL developers, maintaining COBOL codebases is becoming increasingly
challenging. In particular, the lack of documentation makes it difficult for
new developers to effectively understand and maintain COBOL systems. Existing
research utilizes large language models (LLMs) to explain the functionality of
code snippets. However, COBOL presents unique challenges due to its
architectural and syntactical differences, which often cause its code to exceed
the token window size of LLMs. In this work, we propose a multi-agent approach
that leverages two LLM-based agents working collaboratively to generate
explanations for functions, files, and the overall project. These agents
incorporate together by utilizing contextual information from the codebase into
the code explanation prompts. We evaluate the effectiveness of our approach
using 14 open-source, real-world COBOL projects. Our results indicate that our
approach performs significantly better than the baseline in function code
explanation, with improvements of 12.67%, 18.59%, and 0.62% in terms of METEOR,
chrF, and SentenceBERT scores, respectively. At the file level, our approach
effectively explains both short and long COBOL files that exceed the token
window size of LLMs and surpass the baseline by 4.21%, 10.72%, and 14.68% in
explaining the purpose, functionality, and clarity of the generated
explanation. At the project level, our approach generates explanations that
convey the functionality and purpose of 82% of the selected projects.

</details>


### [7] [Precisely Detecting Python Type Errors via LLM-based Unit Test Generation](https://arxiv.org/abs/2507.02318)
*Chen Yang,Ziqi Wang,Yanjie Jiang,Lin Yang,Yuteng Zheng,Jianyi Zhou,Junjie Chen*

Main category: cs.SE

TL;DR: RTED is a new Python type error detector that uses smart test generation and reduces false alarms. It finds more errors and fewer false positives than existing tools, even discovering new bugs in real projects.


<details>
  <summary>Details</summary>
Motivation: Python's dynamic typing often leads to runtime type errors, which hurt software reliability and create productivity challenges for developers. Existing static analysis tools produce many false positives, and test generation approaches lack precise guidance, limiting their effectiveness at finding type errors.

Method: The paper presents RTED, a novel test generation technique that is type-aware. RTED integrates step-by-step type constraint analysis with reflective validation to guide the unit test generation process. This combination helps focus test generation on revealing actual type errors while reducing false positives.

Result: RTED was evaluated on the BugsInPy and TypeBugs benchmarks, showing it can detect 22-29 more type errors than four other state-of-the-art techniques. RTED achieves a 173.9%-245.9% improvement in precision (fewer false positives) and discovered 12 new type errors in real-world open-source Python projects.

Conclusion: RTED effectively improves Python type error detection by integrating type constraint analysis and reflective validation, clearly outperforming previous approaches in both coverage and precision while even uncovering previously unknown real-world type errors.

Abstract: Type errors in Python often lead to runtime failures, posing significant
challenges to software reliability and developer productivity. Existing static
analysis tools aim to detect such errors without execution but frequently
suffer from high false positive rates. Recently, unit test generation
techniques offer great promise in achieving high test coverage, but they often
struggle to produce bug-revealing tests without tailored guidance. To address
these limitations, we present RTED, a novel type-aware test generation
technique for automatically detecting Python type errors. Specifically, RTED
combines step-by-step type constraint analysis with reflective validation to
guide the test generation process and effectively suppress false positives. We
evaluated RTED on two widely-used benchmarks, BugsInPy and TypeBugs.
Experimental results show that RTED can detect 22-29 more benchmarked type
errors than four state-of-the-art techniques. RTED is also capable of producing
fewer false positives, achieving an improvement of 173.9%-245.9% in precision.
Furthermore, RTED successfully discovered 12 previously unknown type errors
from six real-world open-source Python projects.

</details>


### [8] [VeFIA: An Efficient Inference Auditing Framework for Vertical Federated Collaborative Software](https://arxiv.org/abs/2507.02376)
*Chung-ju Huang,Ziqi Zhang,Yinggui Wang,Binghui Wang,Tao Wei,Leye Wang*

Main category: cs.SE

TL;DR: This paper introduces VeFIA, the first framework to audit execution correctness of inference software in VFL, ensuring privacy, zero additional latency, and highly accurate anomaly detection using TEEs and random sampling.


<details>
  <summary>Details</summary>
Motivation: Existing Vertical Federated Learning (VFL) frameworks lack mechanisms to audit whether the inference software of a data party executes correctly, which can jeopardize trust without revealing private data.

Method: The authors design and implement the Vertical Federated Inference Auditing (VeFIA) framework, which allows the task party to audit the correctness of the data party's inference software execution using Trusted Execution Environments (TEE) and a coordinator. The framework uses random sampling validation without revealing data or introducing additional latency.

Result: VeFIA can detect execution anomalies in inference software with a probability of 99.99% if abnormal inference exceeds 5.4%, achieves 100% positive predictive value, negative predictive value, and true positive rate in detecting abnormal inference, and introduces no additional latency to the inference system.

Conclusion: VeFIA is the first framework addressing the correctness of inference software execution in VFL, offering privacy-preserving, latency-free, and highly accurate auditing to foster trustworthy federated inference.

Abstract: Vertical Federated Learning (VFL) is a distributed AI software deployment
mechanism for cross-silo collaboration without accessing participants' data.
However, existing VFL work lacks a mechanism to audit the execution correctness
of the inference software of the data party. To address this problem, we design
a Vertical Federated Inference Auditing (VeFIA) framework. VeFIA helps the task
party to audit whether the data party's inference software is executed as
expected during large-scale inference without leaking the data privacy of the
data party or introducing additional latency to the inference system. The core
of VeFIA is that the task party can use the inference results from a framework
with Trusted Execution Environments (TEE) and the coordinator to validate the
correctness of the data party's computation results. VeFIA guarantees that, as
long as the abnormal inference exceeds 5.4%, the task party can detect
execution anomalies in the inference software with a probability of 99.99%,
without incurring any additional online inference latency. VeFIA's random
sampling validation achieves 100% positive predictive value, negative
predictive value, and true positive rate in detecting abnormal inference. To
the best of our knowledge, this is the first paper to discuss the correctness
of inference software execution in VFL.

</details>


### [9] [Meta-Fair: AI-Assisted Fairness Testing of Large Language Models](https://arxiv.org/abs/2507.02533)
*Miguel Romero-Arjona,José A. Parejo,Juan C. Alonso,Ana B. Sánchez,Aitor Arrieta,Sergio Segura*

Main category: cs.SE

TL;DR: Meta-Fair offers an automated, LLM-driven approach to fairness testing by using metamorphic relations and leveraging LLMs for both input generation and result evaluation. It is effective and scalable, achieving high precision and F1-scores in bias detection, indicating a promising direction for automated fairness assessment in LLMs.


<details>
  <summary>Details</summary>
Motivation: Assessing and enforcing fairness in large language models (LLMs) is essential due to the risk of unjustified bias, but current testing methods are resource-intensive, manual, and difficult to scale across domains.

Method: The paper introduces Meta-Fair, an automated method for fairness testing in LLMs. Meta-Fair uses metamorphic testing, where controlled prompt modifications (metamorphic relations) help unveil bias. It also harnesses LLMs themselves for both generating test cases and evaluating the outputs. Three open-source tools were developed to automate generation, execution, and evaluation of test cases. Experiments involved 12 LLMs, 14 MRs, 5 bias dimensions, and 7,900 automatically generated test cases.

Result: Meta-Fair effectively uncovered bias in LLMs, achieving an average precision of 92% and detecting biased behavior in 29% of executions. LLMs also demonstrated reliability as output evaluators, with top models reaching F1-scores of 0.79. The impact of non-determinism can be minimized through careful MR design.

Conclusion: The proposed Meta-Fair framework automates fairness testing in LLMs, significantly reducing manual labor and domain-specific dependence, while achieving high accuracy in bias detection. Some challenges remain, but this approach holds promise for scalable, robust fairness assessment in LLMs.

Abstract: Fairness--the absence of unjustified bias--is a core principle in the
development of Artificial Intelligence (AI) systems, yet it remains difficult
to assess and enforce. Current approaches to fairness testing in large language
models (LLMs) often rely on manual evaluation, fixed templates, deterministic
heuristics, and curated datasets, making them resource-intensive and difficult
to scale. This work aims to lay the groundwork for a novel, automated method
for testing fairness in LLMs, reducing the dependence on domain-specific
resources and broadening the applicability of current approaches. Our approach,
Meta-Fair, is based on two key ideas. First, we adopt metamorphic testing to
uncover bias by examining how model outputs vary in response to controlled
modifications of input prompts, defined by metamorphic relations (MRs). Second,
we propose exploiting the potential of LLMs for both test case generation and
output evaluation, leveraging their capability to generate diverse inputs and
classify outputs effectively. The proposal is complemented by three open-source
tools supporting LLM-driven generation, execution, and evaluation of test
cases. We report the findings of several experiments involving 12 pre-trained
LLMs, 14 MRs, 5 bias dimensions, and 7.9K automatically generated test cases.
The results show that Meta-Fair is effective in uncovering bias in LLMs,
achieving an average precision of 92% and revealing biased behaviour in 29% of
executions. Additionally, LLMs prove to be reliable and consistent evaluators,
with the best-performing models achieving F1-scores of up to 0.79. Although
non-determinism affects consistency, these effects can be mitigated through
careful MR design. While challenges remain to ensure broader applicability, the
results indicate a promising path towards an unprecedented level of automation
in LLM testing.

</details>


### [10] [LLMREI: Automating Requirements Elicitation Interviews with LLMs](https://arxiv.org/abs/2507.02564)
*Alexander Korn,Samuel Gorsch,Andreas Vogelsang*

Main category: cs.SE

TL;DR: This paper presents LLMREI, a chatbot that automates the requirements elicitation process using advanced prompting techniques. It is as effective as human interviewers at avoiding errors and extracting requirements, and it offers scalable solutions for large-scale interviews.


<details>
  <summary>Details</summary>
Motivation: Requirements elicitation interviews are essential but resource-intensive due to reliance on skilled human analysts. The process is prone to bias and miscommunication, motivating the need for more scalable, automated, and error-resistant solutions. Advances in Large Language Models (LLMs) offer new automation possibilities.

Method: The authors introduce LLMREI, a chatbot for conducting requirements elicitation interviews with minimal human involvement. They explore zero-shot prompting and least-to-most prompting approaches to optimize the chatbot, evaluating its performance through 33 simulated stakeholder interviews. Fine-tuning was also considered but later dropped.

Result: LLMREI performed similarly to humans regarding common interview errors, was effective at extracting a substantial amount of requirements, and showed strong adaptability by generating context-dependent questions. Fine-tuning did not yield satisfactory results.

Conclusion: LLMREI can reduce interviewer errors, improve scalability, and automate requirements elicitation, with notable benefits in scenarios involving large numbers of stakeholders.

Abstract: Requirements elicitation interviews are crucial for gathering system
requirements but heavily depend on skilled analysts, making them
resource-intensive, susceptible to human biases, and prone to miscommunication.
Recent advancements in Large Language Models present new opportunities for
automating parts of this process. This study introduces LLMREI, a chat bot
designed to conduct requirements elicitation interviews with minimal human
intervention, aiming to reduce common interviewer errors and improve the
scalability of requirements elicitation. We explored two main approaches,
zero-shot prompting and least-to-most prompting, to optimize LLMREI for
requirements elicitation and evaluated its performance in 33 simulated
stakeholder interviews. A third approach, fine-tuning, was initially considered
but abandoned due to poor performance in preliminary trials. Our study assesses
the chat bot's effectiveness in three key areas: minimizing common interview
errors, extracting relevant requirements, and adapting its questioning based on
interview context and user responses. Our findings indicate that LLMREI makes a
similar number of errors compared to human interviewers, is capable of
extracting a large portion of requirements, and demonstrates a notable ability
to generate highly context-dependent questions. We envision the greatest
benefit of LLMREI in automating interviews with a large number of stakeholders.

</details>


### [11] [Human-Machine Collaboration and Ethical Considerations in Adaptive Cyber-Physical Systems](https://arxiv.org/abs/2507.02578)
*Zoe Pfister*

Main category: cs.SE

TL;DR: This paper addresses the technical and ethical challenges of integrating advanced human-machine collaboration into adaptive cyber-physical systems by proposing new methods for seamless feedback loop integration and frameworks for embedding ethics and human values throughout system development.


<details>
  <summary>Details</summary>
Motivation: Adaptive Cyber-Physical Systems (CPS) are increasingly incorporating Human-Machine Teaming (HMT) for enhanced collaboration, but current methods struggle to seamlessly integrate humans into adaptive feedback loops due to differing operational speeds and privacy concerns.

Method: The research proposes the development of novel methods and processes for integrating HMT into adaptive CPS, focusing on improved human-machine interaction and adaptation mechanisms. It also aims to create frameworks for ensuring ethics and human values are embedded, verified, and validated across the system lifecycle, beginning with requirements engineering.

Result: The paper develops new approaches for integrating HMT into CPS feedback loops and provides frameworks that systematically include and evaluate ethical and human value considerations during all phases of system development.

Conclusion: Integrating advanced human-machine teaming into adaptive CPS requires both technical advancements in feedback integration and structured methods for respecting privacy and human values. The research delivers methods and frameworks to bridge these gaps and enable effective, ethical human-machine teams.

Abstract: Adaptive Cyber-Physical Systems (CPS) are systems that integrate both
physical and computational capabilities, which can adjust in response to
changing parameters. Furthermore, they increasingly incorporate human-machine
collaboration, allowing them to benefit from the individual strengths of humans
and machines. Human-Machine Teaming (HMT) represents the most advanced paradigm
of human-machine collaboration, envisioning seamless teamwork between humans
and machines. However, achieving effective and seamless HMT in adaptive CPS is
challenging. While adaptive CPS already benefit from feedback loops such as
MAPE-K, there is still a gap in integrating humans into these feedback loops
due to different operational cadences of humans and machines. Further, HMT
requires constant monitoring of human operators, collecting potentially
sensitive information about their actions and behavior. Respecting the privacy
and human values of the actors of the CPS is crucial for the success of
human-machine teams. This research addresses these challenges by: (1)
developing novel methods and processes for integrating HMT into adaptive CPS,
focusing on human-machine interaction principles and their incorporation into
adaptive feedback loops found in CPS, and (2) creating frameworks for
integrating, verifying, and validating ethics and human values throughout the
system lifecycle, starting from requirements engineering.

</details>


### [12] [Do Research Software Engineers and Software Engineering Researchers Speak the Same Language?](https://arxiv.org/abs/2507.02665)
*Timo Kehrer,Robert Haines,Guido Juckeland,Shurui Zhou,David E. Bernholdt*

Main category: cs.SE

TL;DR: The paper explores differences in terminology between RSEs and SERs, introduces a systematic mapping methodology, and finds areas for improved mutual understanding and collaboration, setting the stage for future community-driven enhancement.


<details>
  <summary>Details</summary>
Motivation: There are observed communication challenges between Research Software Engineers (RSEs) and Software Engineering Researchers (SERs) due to the use of different terminologies for similar concepts. The motivation is to understand these differences, identify gaps, and foster better communication and collaboration.

Method: The authors use a systematic methodology for mapping terminologies between the RSE and SER communities, aiming to analyze how SE fundamentals are interpreted and applied across both groups.

Result: The preliminary findings highlight areas of alignment and knowledge gaps between the two communities, suggesting possibilities for mutual learning and collaborative improvement.

Conclusion: This work lays the groundwork for future crowd-sourced efforts to extend and validate the terminology mapping, ultimately aiming to bridge the communication gap and enhance collaboration between RSEs and SERs.

Abstract: Anecdotal evidence suggests that Research Software Engineers (RSEs) and
Software Engineering Researchers (SERs) often use different terminologies for
similar concepts, creating communication challenges. To better understand these
divergences, we have started investigating how SE fundamentals from the SER
community are interpreted within the RSE community, identifying aligned
concepts, knowledge gaps, and areas for potential adaptation. Our preliminary
findings reveal opportunities for mutual learning and collaboration, and our
systematic methodology for terminology mapping provides a foundation for a
crowd-sourced extension and validation in the future.

</details>


### [13] [RLHGNN: Reinforcement Learning-driven Heterogeneous Graph Neural Network for Next Activity Prediction in Business Processes](https://arxiv.org/abs/2507.02690)
*Jiaxing Wang,Yifeng Yu,Jiahan Song,Bin Cao,Jing Fan,Ji Zhang*

Main category: cs.SE

TL;DR: RLHGNN is a new, reinforcement learning-driven framework for next activity prediction in complex business processes. By adapting graph structure per process instance and using relation-specific graph convolution, it outperforms current best methods and runs fast enough for real-time use.


<details>
  <summary>Details</summary>
Motivation: Next activity prediction is critical in optimizing business processes, especially in complex, distributed environments such as microservices and cloud-native platforms. Existing sequence-based and graph-based methods struggle to capture complex, non-sequential, and heterogeneous process relationships.

Method: The authors introduce RLHGNN, a novel framework that transforms event logs into heterogeneous process graphs with three types of edges based on process mining theory. It generates four flexible graph structures to match different process complexities. A reinforcement learning approach, formulated as a Markov Decision Process, is used to automatically select the optimal graph structure for each process instance, followed by heterogeneous graph convolution with relation-specific aggregation for activity prediction.

Result: In experiments on six real-world datasets, RLHGNN outperforms existing state-of-the-art methods and maintains low inference latency (about 1 ms per prediction), showing practical suitability for real-time applications.

Conclusion: RLHGNN successfully addresses the limitations of previous next activity prediction approaches by adaptively modeling process heterogeneity, achieving superior accuracy and real-time inference capabilities. The framework effectively supports proactive resource allocation and dynamic service composition in business processes.

Abstract: Next activity prediction represents a fundamental challenge for optimizing
business processes in service-oriented architectures such as microservices
environments, distributed enterprise systems, and cloud-native platforms, which
enables proactive resource allocation and dynamic service composition. Despite
the prevalence of sequence-based methods, these approaches fail to capture
non-sequential relationships that arise from parallel executions and
conditional dependencies. Even though graph-based approaches address structural
preservation, they suffer from homogeneous representations and static
structures that apply uniform modeling strategies regardless of individual
process complexity characteristics. To address these limitations, we introduce
RLHGNN, a novel framework that transforms event logs into heterogeneous process
graphs with three distinct edge types grounded in established process mining
theory. Our approach creates four flexible graph structures by selectively
combining these edges to accommodate different process complexities, and
employs reinforcement learning formulated as a Markov Decision Process to
automatically determine the optimal graph structure for each specific process
instance. RLHGNN then applies heterogeneous graph convolution with
relation-specific aggregation strategies to effectively predict the next
activity. This adaptive methodology enables precise modeling of both sequential
and non-sequential relationships in service interactions. Comprehensive
evaluation on six real-world datasets demonstrates that RLHGNN consistently
outperforms state-of-the-art approaches. Furthermore, it maintains an inference
latency of approximately 1 ms per prediction, representing a highly practical
solution suitable for real-time business process monitoring applications. The
source code is available at https://github.com/Joker3993/RLHGNN.

</details>


### [14] [Sustainability Flags for the Identification of Sustainability Posts in Q&A Platforms](https://arxiv.org/abs/2507.02695)
*Sahar Ahmadisakha,Lech Bialek,Mohamed Soliman,Vasilios Andrikopoulos*

Main category: cs.SE

TL;DR: The paper introduces 'sustainability flags,' derived from best practices, to better identify sustainability in software discussions. Experiments show these flags improve certainty, performance, and user understanding compared to just using definitions.


<details>
  <summary>Details</summary>
Motivation: Sustainability in software systems has become increasingly important with the adoption of cloud computing, but it's difficult to identify sustainability-related discussions among software practitioners due to a lack of clear guidelines.

Method: The authors conducted a thematic analysis of sustainability best practices from various cloud providers to develop 'sustainability flags'—pointers to help identify relevant topics in practitioners' discussions. These flags were then evaluated through a controlled experiment, comparing their effectiveness to using only definitions.

Result: The use of sustainability flags led to fewer posts being classified as relating to sustainability compared to the control, but those classifications were made with higher certainty and significantly better performance. Users also found the flags more useful and understandable than simple definitions.

Conclusion: Sustainability flags, developed from best practices, are effective tools for more reliably and understandably identifying sustainability in cloud architecture discussions among practitioners compared to solely relying on definitions.

Abstract: In recent years, sustainability in software systems has gained significant
attention, especially with the rise of cloud computing and the shift towards
cloud-based architectures. This shift has intensified the need to identify
sustainability in architectural discussions to take informed architectural
decisions. One source to see these decisions is in online Q&A forums among
practitioners' discussions. However, recognizing sustainability concepts within
software practitioners' discussions remains challenging due to the lack of
clear and distinct guidelines for this task. To address this issue, we
introduce the notion of sustainability flags as pointers in relevant
discussions, developed through thematic analysis of multiple sustainability
best practices from cloud providers. This study further evaluates the
effectiveness of these flags in identifying sustainability within cloud
architecture posts, using a controlled experiment. Preliminary results suggest
that the use of flags results in classifying fewer posts as
sustainability-related compared to a control group, with moderately higher
certainty and significantly improved performance. Moreover, sustainability
flags are perceived as more useful and understandable than relying solely on
definitions for identifying sustainability.

</details>


### [15] [Legal Requirements Translation from Law](https://arxiv.org/abs/2507.02846)
*Anmol Singhal,Travis Breaux*

Main category: cs.SE

TL;DR: The paper presents an automated, Python-based approach to extract legal requirements from regulatory texts using textual entailment and in-context learning, achieving high accuracy and reducing manual work, particularly benefiting small organizations.


<details>
  <summary>Details</summary>
Motivation: Ensuring software compliance with legal regulations is challenging and resource-intensive, especially for small organizations without dedicated legal staff. Extracting legal requirements from regulations is critical but burdensome due to the complexity of legal texts. Existing automated approaches lack consideration of relationships among metadata attributes and do not generalize well to new documents.

Method: The authors propose an automated approach using textual entailment and in-context learning to generate canonical representations of legal text, which can be encoded and executed as Python code. This representation stems from a manually designed Python class structure (a domain-specific metamodel) that captures both structural and semantic metadata and their interrelations, reducing reliance on large, labeled training datasets.

Result: The approach was evaluated using 13 U.S. state data breach notification laws. The generated representations passed about 89.4% of test cases and achieved a precision of 82.2 and recall of 88.7, indicating a high level of accuracy and effectiveness.

Conclusion: The proposed method enhances the automation and accuracy of extracting legal requirements from regulations, with reduced dependence on manual labeling and strong generalization to new legislative texts. This supports software compliance in resource-constrained environments.

Abstract: Software systems must comply with legal regulations, which is a
resource-intensive task, particularly for small organizations and startups
lacking dedicated legal expertise. Extracting metadata from regulations to
elicit legal requirements for software is a critical step to ensure compliance.
However, it is a cumbersome task due to the length and complex nature of legal
text. Although prior work has pursued automated methods for extracting
structural and semantic metadata from legal text, key limitations remain: they
do not consider the interplay and interrelationships among attributes
associated with these metadata types, and they rely on manual labeling or
heuristic-driven machine learning, which does not generalize well to new
documents. In this paper, we introduce an approach based on textual entailment
and in-context learning for automatically generating a canonical representation
of legal text, encodable and executable as Python code. Our representation is
instantiated from a manually designed Python class structure that serves as a
domain-specific metamodel, capturing both structural and semantic legal
metadata and their interrelationships. This design choice reduces the need for
large, manually labeled datasets and enhances applicability to unseen
legislation. We evaluate our approach on 13 U.S. state data breach notification
laws, demonstrating that our generated representations pass approximately 89.4%
of test cases and achieve a precision and recall of 82.2 and 88.7,
respectively.

</details>


### [16] [Requirements Elicitation Follow-Up Question Generation](https://arxiv.org/abs/2507.02858)
*Yuchen Shen,Anmol Singhal,Travis Breaux*

Main category: cs.SE

TL;DR: This paper shows that using large language models (like GPT-4o) to generate interview questions can help interviewers during requirements gathering: the generated questions are as good as or better than those from humans, especially when the LLM is guided to avoid common interviewer mistakes.


<details>
  <summary>Details</summary>
Motivation: Interviewing is crucial for requirements elicitation in software engineering, but interviewers face challenges such as domain unfamiliarity, cognitive overload, and information overload. Large Language Models have shown strong performance in NLP tasks and may be able to assist interviewers in generating effective follow-up questions.

Method: The paper investigates using GPT-4o to generate follow-up interview questions during requirements elicitation. They build upon a framework of common interviewer mistake types and propose methods for automated question generation based on interviewee speech. The study conducts two controlled experiments: one comparing minimally guided LLM- and human-generated questions, and another guiding LLM question generation by mistake types.

Result: The experiments reveal that LLM-generated questions are no worse than human-authored ones in terms of clarity, relevancy, and informativeness. When guided by interviewer mistake types, LLM-generated questions even outperform those authored by humans.

Conclusion: LLMs like GPT-4o can be valuable tools for interviewers during requirements elicitation, improving question quality and reducing cognitive and informational challenges. Guiding LLMs using common interviewer mistakes enhances the effectiveness of generated questions.

Abstract: Interviews are a widely used technique in eliciting requirements to gather
stakeholder needs, preferences, and expectations for a software system.
Effective interviewing requires skilled interviewers to formulate appropriate
interview questions in real time while facing multiple challenges, including
lack of familiarity with the domain, excessive cognitive load, and information
overload that hinders how humans process stakeholders' speech. Recently, large
language models (LLMs) have exhibited state-of-the-art performance in multiple
natural language processing tasks, including text summarization and entailment.
To support interviewers, we investigate the application of GPT-4o to generate
follow-up interview questions during requirements elicitation by building on a
framework of common interviewer mistake types. In addition, we describe methods
to generate questions based on interviewee speech. We report a controlled
experiment to evaluate LLM-generated and human-authored questions with minimal
guidance, and a second controlled experiment to evaluate the LLM-generated
questions when generation is guided by interviewer mistake types. Our findings
demonstrate that, for both experiments, the LLM-generated questions are no
worse than the human-authored questions with respect to clarity, relevancy, and
informativeness. In addition, LLM-generated questions outperform human-authored
questions when guided by common mistakes types. This highlights the potential
of using LLMs to help interviewers improve the quality and ease of requirements
elicitation interviews in real time.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [17] [DecoRTL: A Run-time Decoding Framework for RTL Code Generation with LLMs](https://arxiv.org/abs/2507.02226)
*Mohammad Akyash,Kimia Azar,Hadi Kamali*

Main category: cs.PL

TL;DR: Conventional LLM decoding methods struggle with RTL code generation due to structural and semantic challenges. This paper introduces DecoRTL, a syntax-aware, contrastive decoding strategy that dynamically adapts token sampling. DecoRTL significantly improves correctness and diversity of RTL outputs without fine-tuning or sacrificing performance.


<details>
  <summary>Details</summary>
Motivation: Large language models (LLMs) have shown capability in automating RTL (register transfer level) code generation, but conventional decoding strategies, designed for natural language, frequently produce code that is hallucinated, repetitive, or structurally invalid. The motivation is to address these generation failures and adapt LLM decoding for the unique requirements of RTL code.

Method: The authors conduct empirical analysis of token-level entropy in RTL code generation to identify decoding failures. They then propose DecoRTL, a novel decoding approach that operates during inference. DecoRTL features (i) self-consistency sampling: generating and re-ranking multiple output candidates based on token-level agreement; (ii) syntax-aware temperature adaptation: dynamically adjusting the sampling temperature based on the syntactic and functional role of tokens to ensure determinism for syntax-critical parts and creativity for design-critical parts.

Result: DecoRTL, tested on multiple open-source LLMs with the VerilogEval benchmark, achieves notable improvements in syntactic validity, functional correctness, and diversity of generated RTL code, all with negligible performance overhead and without requiring model fine-tuning.

Conclusion: Adapting decoding strategies for the unique structure and requirements of RTL code is crucial for LLM-based code generation. DecoRTL effectively addresses common failure modes of existing decoding methods and improves both the syntax and function of generated output with minimal cost.

Abstract: As one of their many applications, large language models (LLMs) have recently
shown promise in automating register transfer level (RTL) code generation.
However, conventional LLM decoding strategies, originally designed for natural
language, often fail to meet the structural and semantic demands of RTL,
leading to hallucinated, repetitive, or invalid code outputs. In this paper, we
first investigate the root causes of these decoding failures through an
empirical analysis of token-level entropy during RTL generation. Our findings
reveal that LLMs exhibit low confidence in regions of structural ambiguity or
semantic complexity, showing that standard decoding strategies fail to
differentiate between regions requiring determinism (syntax-critical regions)
and those that benefit from creative exploratory variability (design-critical
regions). Then, to overcome this, we introduce DecoRTL, a novel run-time
decoding strategy, that is both syntax-aware and contrastive for RTL code
generation. DecoRTL integrates two complementary components: (i)
self-consistency sampling, which generates multiple candidates and re-ranks
them based on token-level agreement to promote correctness while maintaining
diversity; and (ii) syntax-aware temperature adaptation, which classifies
tokens by their syntactical and functional roles and adjusts the sampling
temperature accordingly, enforcing low temperature for syntax-critical tokens
and higher temperature for exploratory ones. Our approach operates entirely at
inference time without requiring any additional model fine-tuning. Through
evaluations on multiple open-source LLMs using the VerilogEval benchmark, we
demonstrate significant improvements in syntactic validity, functional
correctness, and output diversity, while the execution overhead (performance
overhead) is imperceptible.

</details>
