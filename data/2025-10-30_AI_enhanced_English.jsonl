{"id": "2510.25112", "categories": ["cs.PL", "cs.DC", "cs.LO", "math.AT", "68Q85, 55P99, 68N30, 55U10", "D.2.4; F.3.1; D.1.3; F.1.2"], "pdf": "https://arxiv.org/pdf/2510.25112", "abs": "https://arxiv.org/abs/2510.25112", "authors": ["Di Zhang"], "title": "The Singularity Theory of Concurrent Programs: A Topological Characterization and Detection of Deadlocks and Livelocks", "comment": "10 pages", "summary": "This paper introduces a novel paradigm for the analysis and verification of\nconcurrent programs -- the Singularity Theory. We model the execution space of\na concurrent program as a branched topological space, where program states are\npoints and state transitions are paths. Within this framework, we characterize\ndeadlocks as attractors and livelocks as non-contractible loops in the\nexecution space. By employing tools from algebraic topology, particularly\nhomotopy and homology groups, we define a series of concurrent topological\ninvariants to systematically detect and classify these concurrent\n\"singularities\" without exhaustively traversing all states. This work aims to\nestablish a geometric and topological foundation for concurrent program\nverification, transcending the limitations of traditional model checking.", "AI": {"tldr": "This paper proposes using algebraic topology to analyze concurrent programs, modeling execution as a branched space. Deadlocks and livelocks are mathematically characterized and can be detected via topological invariants, providing a foundation that avoids exhaustive state traversal and surpasses classical model checking limits.", "motivation": "Traditional model checking for concurrent programs often struggles with state explosion and exhaustive traversal, making it difficult to systematically detect deadlocks and livelocks. The paper seeks a more comprehensive and mathematically grounded approach.", "method": "The authors model program execution as a branched topological space and represent program states and transitions using algebraic topology. Deadlocks are viewed as attractors, and livelocks as non-contractible loops. Tools such as homotopy and homology groups are used to define topological invariants that help to detect and classify problematic states.", "result": "The paper demonstrates that deadlocks and livelocks can be systematically detected and classified using topological invariants, without the need for exhaustive state enumeration.", "conclusion": "A new geometric and topological foundation for concurrent program verification is established, offering systematic and scalable detection of concurrency issues beyond what traditional methods allow."}}
{"id": "2510.25369", "categories": ["cs.PL", "cs.FL", "cs.LO", "math.LO", "F.3.1; F.4.1"], "pdf": "https://arxiv.org/pdf/2510.25369", "abs": "https://arxiv.org/abs/2510.25369", "authors": ["Elliot Bobrow", "Bryan Ford", "Stefan Milenkovi\u0107"], "title": "Have a thing? Reasoning around recursion with dynamic typing in grounded arithmetic", "comment": null, "summary": "Neither the classical nor intuitionistic logic traditions are\nperfectly-aligned with the purpose of reasoning about computation, in that\nneither logical tradition can normally permit the direct expression of\narbitrary general-recursive functions without inconsistency. We introduce\ngrounded arithmetic or GA, a minimalistic but nonetheless powerful foundation\nfor formal reasoning that allows the direct expression of arbitrary recursive\ndefinitions. GA adjusts the traditional inference rules such that terms that\nexpress nonterminating computations harmlessly denote no semantic value (i.e.,\n\"bottom\") instead of leading into logical paradox or inconsistency. Recursive\nfunctions may be proven terminating in GA essentially by \"dynamically typing\"\nterms, or equivalently, symbolically reverse-executing the computations they\ndenote via GA's inference rules. Once recursive functions have been proven\nterminating, logical reasoning about their results reduce to the familiar\nclassical rules. A mechanically-checked consistency proof in Isabelle/HOL\nexists for the basic quantifier-free fragment of GA. Quantifiers may be added\natop this foundation as ordinary computations, whose inference rules are thus\nadmissible and do not introduce new inconsistency risks. While GA is only a\nfirst step towards richly-typed grounded deduction practical for everyday use\nin manual or automated computational reasoning, it shows the promise that the\nexpressive freedom of arbitrary recursive definition can in principle be\nincorporated into formal systems.", "AI": {"tldr": "Grounded Arithmetic (GA) is a novel logic system enabling direct and safe use of arbitrary recursive functions in formal reasoning, by treating non-terminating computations as undefined rather than inconsistent. Its quantifier-free fragment is proven consistent and it paves the way to more practical and expressive computational logics.", "motivation": "Traditional logic systems (classical and intuitionistic) face difficulties handling arbitrary general-recursive functions without risking inconsistency, limiting their usefulness for formal reasoning about computation.", "method": "The paper introduces Grounded Arithmetic (GA), a minimalistic logic system that modifies standard inference rules so that non-terminating recursive functions denote an undefined value (bottom) rather than introducing inconsistency. GA enables 'dynamic typing' or symbolic reverse execution to prove termination of recursive functions, integrating them seamlessly once termination is established. A mechanically-checked consistency proof is provided for the quantifier-free fragment using Isabelle/HOL.", "result": "GA successfully allows direct expression and reasoning with arbitrary recursive definitions without inconsistency, provided non-terminating terms are treated as semantically undefined. The quantifier-free GA system is shown to be consistent, and classical reasoning is recovered for proven terminating functions. Quantifiers can be safely added as computations.", "conclusion": "Grounded Arithmetic presents a promising foundation for formal reasoning about arbitrary recursive functions in a manner that preserves consistency. While an initial step, this approach may enable more practical and expressive reasoning about computation in both manual and automated formal systems."}}
{"id": "2510.24819", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.24819", "abs": "https://arxiv.org/abs/2510.24819", "authors": ["Vincenzo Scotti", "Jan Keim", "Tobias Hey", "Andreas Metzger", "Anne Koziolek", "Raffaela Mirandola"], "title": "A Roadmap for Tamed Interactions with Large Language Models", "comment": null, "summary": "We are witnessing a bloom of AI-powered software driven by Large Language\nModels (LLMs). Although the applications of these LLMs are impressive and\nseemingly countless, their unreliability hinders adoption. In fact, the\ntendency of LLMs to produce faulty or hallucinated content makes them\nunsuitable for automating workflows and pipelines. In this regard, Software\nEngineering (SE) provides valuable support, offering a wide range of formal\ntools to specify, verify, and validate software behaviour. Such SE tools can be\napplied to define constraints over LLM outputs and, consequently, offer\nstronger guarantees on the generated content. In this paper, we argue that the\ndevelopment of a Domain Specific Language (DSL) for scripting interactions with\nLLMs using an LLM Scripting Language (LSL) may be key to improve AI-based\napplications. Currently, LLMs and LLM-based software still lack reliability,\nrobustness, and trustworthiness, and the tools or frameworks to cope with these\nissues suffer from fragmentation. In this paper, we present our vision of LSL.\nWith LSL, we aim to address the limitations above by exploring ways to control\nLLM outputs, enforce structure in interactions, and integrate these aspects\nwith verification, validation, and explainability. Our goal is to make LLM\ninteraction programmable and decoupled from training or implementation.", "AI": {"tldr": "LLMs are widely adopted but unreliable. This paper proposes a scripting language (LSL) to better control, validate, and structure LLM interactions, aiming to increase reliability and trustworthiness in AI-driven software applications.", "motivation": "LLMs are increasingly used in AI-powered software, but their unreliability and tendency to hallucinate limit adoption, especially in automated workflows. Software engineering offers formal tools to specify and validate outputs, but there is a lack of integrated solutions for managing LLM behavior effectively.", "method": "The paper proposes the development of a Domain Specific Language (DSL) called LLM Scripting Language (LSL) to script and control interactions with LLMs. LSL is intended to enforce structure, allow validation/verification, and provide explainability for LLM outputs.", "result": "The paper presents a vision for LSL, highlighting how it could address current challenges by providing programmable, reliable, and trustworthy interactions with LLMs, independent from model training or implementation details.", "conclusion": "Making LLM interaction programmable through a dedicated scripting language can increase reliability, robustness, and trustworthiness of AI applications by integrating specification, verification, and validation techniques."}}
{"id": "2510.24749", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.24749", "abs": "https://arxiv.org/abs/2510.24749", "authors": ["Aofan Liu", "Shiyuan Song", "Haoxuan Li", "Cehao Yang", "Yiyan Qi"], "title": "Beyond Function-Level Search: Repository-Aware Dual-Encoder Code Retrieval with Adversarial Verification", "comment": "Accepted by EMNLP 2025", "summary": "The escalating complexity of modern codebases has intensified the need for\nretrieval systems capable of interpreting cross-component change intents, a\ncapability fundamentally absent in conventional function-level search\nparadigms. While recent studies have improved the alignment between natural\nlanguage queries and code snippets, retrieving contextually relevant code for\nspecific change requests remains largely underexplored. To address this gap, we\nintroduce RepoAlign-Bench, the first benchmark specifically designed to\nevaluate repository-level code retrieval under change request driven scenarios,\nencompassing 52k annotated instances. This benchmark shifts the retrieval\nparadigm from function-centric matching to holistic repository-level reasoning.\nFurthermore, we propose ReflectCode, an adversarial reflection augmented\ndual-tower architecture featuring disentangled code_encoder and doc_encoder\ncomponents. ReflectCode dynamically integrates syntactic patterns, function\ndependencies, and semantic expansion intents through large language model\nguided reflection. Comprehensive experiments demonstrate that ReflectCode\nachieves 12.2% improvement in Top-5 Accuracy and 7.1% in Recall over\nstate-of-the-art baselines, establishing a new direction for context-aware code\nretrieval.", "AI": {"tldr": "This paper tackles the difficulty of finding code relevant to specific change requests in large repositories, introducing a new benchmark and an advanced retrieval model that significantly outperforms current methods.", "motivation": "Existing code search systems mainly focus on matching functions and struggle to understand broader cross-component change intents within large code repositories, especially in response to specific change requests.", "method": "The paper introduces RepoAlign-Bench, a repository-level benchmark with 52,000 annotated instances for code retrieval tasks related to change requests. It also proposes ReflectCode, a dual-tower model enhanced with adversarial reflection, disentangled encoders for code and documentation, and LLM-guided integration of syntactic and semantic patterns.", "result": "ReflectCode achieves a 12.2% improvement in Top-5 Accuracy and a 7.1% improvement in Recall compared to previous state-of-the-art models.", "conclusion": "RepoAlign-Bench benchmarks context-aware repository-level code retrieval, and ReflectCode sets a new standard in addressing change-driven search scenarios, outperforming existing baselines and promoting holistic code understanding."}}
{"id": "2510.24799", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.24799", "abs": "https://arxiv.org/abs/2510.24799", "authors": ["Filipe R. Cogo", "Gustavo A. Oliva", "Ahmed E. Hassan"], "title": "Compiler.next: A Search-Based Compiler to Power the AI-Native Future of Software Engineering", "comment": "31 pages, 5 figures, submitted to ACM Transactions on Software\n  Engineering and Methodology", "summary": "The rapid advancement of AI-assisted software engineering has brought\ntransformative potential to the field of software engineering, but existing\ntools and paradigms remain limited by cognitive overload, inefficient tool\nintegration, and the narrow capabilities of AI copilots. In response, we\npropose Compiler.next, a novel search-based compiler designed to enable the\nseamless evolution of AI-native software systems as part of the emerging\nSoftware Engineering 3.0 era. Unlike traditional static compilers,\nCompiler.next takes human-written intents and automatically generates working\nsoftware by searching for an optimal solution. This process involves dynamic\noptimization of cognitive architectures and their constituents (e.g., prompts,\nfoundation model configurations, and system parameters) while finding the\noptimal trade-off between several objectives, such as accuracy, cost, and\nlatency. This paper outlines the architecture of Compiler.next and positions it\nas a cornerstone in democratizing software development by lowering the\ntechnical barrier for non-experts, enabling scalable, adaptable, and reliable\nAI-powered software. We present a roadmap to address the core challenges in\nintent compilation, including developing quality programming constructs,\neffective search heuristics, reproducibility, and interoperability between\ncompilers. Our vision lays the groundwork for fully automated, search-driven\nsoftware development, fostering faster innovation and more efficient AI-driven\nsystems.", "AI": {"tldr": "Compiler.next is a new compiler that automates software generation from human intent using dynamic optimization and search, aiming to make AI-powered development more accessible, scalable, and efficient.", "motivation": "AI-assisted software engineering has great potential but currently faces major limitations, such as cognitive overload, inefficient tool integration, and limited AI copilot functionality.", "method": "The authors propose Compiler.next, a search-based compiler that dynamically optimizes cognitive architectures and system parameters by automatically generating working software from human-written intents. The approach balances objectives like accuracy, cost, and latency.", "result": "The paper presents the architecture of Compiler.next, showing how it can democratize software development, lower technical barriers, and facilitate scalable, adaptable, reliable AI-powered software. It also discusses challenges and lays out a roadmap for future developments.", "conclusion": "Compiler.next represents a foundational shift towards fully automated, search-driven software development, enabling faster innovation and more efficient, accessible AI-native systems for a broader range of users."}}
{"id": "2510.25015", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25015", "abs": "https://arxiv.org/abs/2510.25015", "authors": ["Chuyue Sun", "Yican Sun", "Daneshvar Amrollahi", "Ethan Zhang", "Shuvendu Lahiri", "Shan Lu", "David Dill", "Clark Barrett"], "title": "VeriStruct: AI-assisted Automated Verification of Data-Structure Modules in Verus", "comment": null, "summary": "We introduce VeriStruct, a novel framework that extends AI-assisted automated\nverification from single functions to more complex data structure modules in\nVerus. VeriStruct employs a planner module to orchestrate the systematic\ngeneration of abstractions, type invariants, specifications, and proof code. To\naddress the challenge that LLMs often misunderstand Verus' annotation syntax\nand verification-specific semantics, VeriStruct embeds syntax guidance within\nprompts and includes a repair stage to automatically correct annotation errors.\nIn an evaluation on eleven Rust data structure modules, VeriStruct succeeds on\nten of the eleven, successfully verifying 128 out of 129 functions (99.2%) in\ntotal. These results represent an important step toward the goal of automatic\nAI-assisted formal verification.", "AI": {"tldr": "VeriStruct is a new framework that lets AI help verify entire Rust data structure modules, not just single functions. By guiding syntax and automatically fixing mistakes, it succeeded in verifying nearly all functions across 11 tested modules, showing important progress in AI-assisted code verification.", "motivation": "Existing AI-assisted verification tools are limited to verifying single functions and struggle with the complexity of real-world data structure modules, particularly due to annotation syntax and semantics challenges in the Verus verification system.", "method": "The authors developed VeriStruct, a framework with a planner module that automates the process of generating abstractions, type invariants, specifications, and proof code. It uses syntax-guidance within prompts and a repair mechanism to correct annotation errors automatically.", "result": "VeriStruct was evaluated on eleven Rust data structure modules, successfully verifying 128 out of 129 functions (99.2%), demonstrating its effectiveness at automating formal verification for more complex code.", "conclusion": "VeriStruct significantly advances AI-assisted formal verification beyond single functions, by enabling reliable verification of complex data structure modules and overcoming syntax and semantic challenges. It brings the field closer to robust, automated formal verification."}}
{"id": "2510.25016", "categories": ["cs.SE", "cs.AI", "cs.HC", "cs.LG", "68T07, 68N30", "D.2.1; I.2.6; I.2.7"], "pdf": "https://arxiv.org/pdf/2510.25016", "abs": "https://arxiv.org/abs/2510.25016", "authors": ["Mateen Ahmed Abbasi", "Petri Ihantola", "Tommi Mikkonen", "Niko M\u00e4kitalo"], "title": "Towards Human-AI Synergy in Requirements Engineering: A Framework and Preliminary Study", "comment": "Accepted at the 2025 Sixth International Conference on Intelligent\n  Data Science Technologies and Applications (IDSTA 2025),8 pages, 4 figures.\n  Published in IEEE", "summary": "The future of Requirements Engineering (RE) is increasingly driven by\nartificial intelligence (AI), reshaping how we elicit, analyze, and validate\nrequirements. Traditional RE is based on labor-intensive manual processes prone\nto errors and complexity. AI-powered approaches, specifically large language\nmodels (LLMs), natural language processing (NLP), and generative AI, offer\ntransformative solutions and reduce inefficiencies. However, the use of AI in\nRE also brings challenges like algorithmic bias, lack of explainability, and\nethical concerns related to automation. To address these issues, this study\nintroduces the Human-AI RE Synergy Model (HARE-SM), a conceptual framework that\nintegrates AI-driven analysis with human oversight to improve requirements\nelicitation, analysis, and validation. The model emphasizes ethical AI use\nthrough transparency, explainability, and bias mitigation. We outline a\nmulti-phase research methodology focused on preparing RE datasets, fine-tuning\nAI models, and designing collaborative human-AI workflows. This preliminary\nstudy presents the conceptual framework and early-stage prototype\nimplementation, establishing a research agenda and practical design direction\nfor applying intelligent data science techniques to semi-structured and\nunstructured RE data in collaborative environments.", "AI": {"tldr": "Manual requirements engineering is being revolutionized by AI, but automation raises issues like bias and ethics. This paper introduces a Human-AI hybrid framework (HARE-SM) that combines automated analysis with human checks, demonstrates a prototype, and sets out a research plan for applying AI to RE in collaborative settings.", "motivation": "Current requirements engineering (RE) depends heavily on manual, error-prone work, but emerging AI technologies offer transformative opportunities to automate and enhance this process. However, using AI introduces risks such as bias, lack of explainability, and ethical challenges.", "method": "The study proposes the Human-AI RE Synergy Model (HARE-SM), a conceptual framework that integrates AI-driven analysis (LLMs, NLP, generative AI) with human oversight. The methodology includes preparing RE datasets, fine-tuning AI models, and creating collaborative human-AI workflows. A preliminary prototype of the framework has been implemented.", "result": "The study presents the conceptual HARE-SM model and a working prototype, demonstrating initial viability for applying intelligent data science techniques to semi-structured and unstructured RE data. It sets a research agenda and practical design direction.", "conclusion": "AI, particularly through frameworks like HARE-SM, can enhance requirements engineering by combining automated analysis with essential human oversight and ethical safeguards. The study provides an early prototype and a roadmap for further research."}}
{"id": "2510.25039", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.25039", "abs": "https://arxiv.org/abs/2510.25039", "authors": ["Amanda Dsouza", "Harit Vishwakarma", "Zhengyang Qi", "Justin Bauer", "Derek Pham", "Thomas Walshe", "Armin Parchami", "Frederic Sala", "Paroma Varma"], "title": "Automating Benchmark Design", "comment": null, "summary": "The rapid progress and widespread deployment of LLMs and LLM-powered agents\nhas outpaced our ability to evaluate them. Hand-crafted, static benchmarks are\nthe primary tool for assessing model capabilities, but these quickly become\nsaturated. In contrast, dynamic benchmarks evolve alongside the models they\nevaluate, but are expensive to create and continuously update. To address these\nchallenges, we develop BeTaL (Benchmark Tuning with an LLM-in-the-loop), a\nframework that leverages environment design principles to automate the process\nof dynamic benchmark design. BeTaL works by parameterizing key design choices\nin base benchmark templates and uses LLMs to reason through the resulting\nparameter space to obtain target properties (such as difficulty and realism) in\na cost-efficient manner. We validate this approach on its ability to create\nbenchmarks with desired difficulty levels. Using BeTaL, we create two new\nbenchmarks and extend a popular agentic benchmark $\\tau$-bench. Extensive\nevaluation on these three tasks and multiple target difficulty levels shows\nthat BeTaL produces benchmarks much closer to the desired difficulty, with\naverage deviations ranging from 5.3% to 13.2% -- a 2-4x improvement over the\nbaselines.", "AI": {"tldr": "Static LLM benchmarks quickly become outdated and dynamic ones are costly. BeTaL uses LLMs to automate and tune benchmark design, making benchmarks with more accurate difficulty levels much more efficiently than previous methods.", "motivation": "Existing evaluation methods for LLMs, primarily static benchmarks, rapidly become obsolete while dynamic benchmarks, although superior, are costly and difficult to maintain. The field needs a better solution for continuously and efficiently assessing evolving LLM capabilities.", "method": "The paper proposes BeTaL (Benchmark Tuning with an LLM-in-the-loop), a framework that automates dynamic benchmark design. It uses environment design principles, parameterizes benchmark templates, and employs LLMs to efficiently explore and generate benchmarks with specific properties (e.g., difficulty, realism).", "result": "BeTaL creates benchmarks with difficulty levels closer to those desired, with average deviations between 5.3% and 13.2%, outperforming baseline methods by 2-4 times. The framework is validated through the creation of two new benchmarks and the extension of an existing one.", "conclusion": "BeTaL provides an efficient, LLM-driven approach to dynamic benchmark creation, helping keep evaluation methods relevant and accurate as LLM capabilities evolve. It significantly reduces the gap between intended and achieved benchmark difficulty."}}
{"id": "2510.25057", "categories": ["cs.SE", "K.3.2; K.6.5; K.4.1"], "pdf": "https://arxiv.org/pdf/2510.25057", "abs": "https://arxiv.org/abs/2510.25057", "authors": ["Robin Maisch", "Larissa Schmid", "Timur Sa\u011flam", "Nils Niehues"], "title": "Same Same But Different: Preventing Refactoring Attacks on Software Plagiarism Detection", "comment": "To be published at ICSE'26. 13 pages, 6 figures", "summary": "Plagiarism detection in programming education faces growing challenges due to\nincreasingly sophisticated obfuscation techniques, particularly automated\nrefactoring-based attacks. While code plagiarism detection systems used in\neducation practice are resilient against basic obfuscation, they struggle\nagainst structural modifications that preserve program behavior, especially\ncaused by refactoring-based obfuscation. This paper presents a novel and\nextensible framework that enhances state-of-the-art detectors by leveraging\ncode property graphs and graph transformations to counteract refactoring-based\nobfuscation. Our comprehensive evaluation of real-world student submissions,\nobfuscated using both algorithmic and AI-based obfuscation attacks,\ndemonstrates a significant improvement in detecting plagiarized code.", "AI": {"tldr": "The paper proposes a code property graph-based framework that greatly improves the ability to detect plagiarism in student code even when advanced refactoring-based obfuscation techniques are used.", "motivation": "Plagiarism detection in programming education is becoming harder due to increasingly advanced obfuscation techniques, especially refactoring-based methods that preserve program behavior while changing code structure.", "method": "The paper introduces a novel framework that uses code property graphs and graph transformations to improve existing plagiarism detectors, making them more robust against refactoring-based obfuscation techniques.", "result": "Comprehensive tests on real-world student code, obfuscated using both algorithmic and AI-based methods, show that the new approach significantly enhances the detection of plagiarized code.", "conclusion": "Leveraging code property graphs and graph transformation techniques offers a substantial advancement in detecting structurally obfuscated (refactored) plagiarized code in educational settings."}}
{"id": "2510.25103", "categories": ["cs.SE", "D.2.4"], "pdf": "https://arxiv.org/pdf/2510.25103", "abs": "https://arxiv.org/abs/2510.25103", "authors": ["Minghai Lu", "Zhe Zhou", "Danning Xie", "Songlin Jia", "Benjamin Delaware", "Tianyi Zhang"], "title": "Adaptive Proof Refinement with LLM-Guided Strategy Selection", "comment": "11 pages, 11 figures", "summary": "Formal verification via theorem proving enables the expressive specification\nand rigorous proof of software correctness, but it is difficult to scale due to\nthe significant manual effort and expertise required. While Large Language\nModels (LLMs) show potential in proof generation, they frequently produce\nincorrect proofs on the first attempt and require additional strategies for\niterative refinement. However, existing approaches employ fixed refinement\nstrategies and cannot dynamically choose an effective strategy based on the\nparticular issues in a generated proof, which limits their performance. To\novercome this limitation, we introduce Adapt, a novel proof refinement\nframework that leverages an LLM-guided decision-maker to dynamically select a\nsuitable refinement strategy according to the state of the proof assistant and\navailable context of an incorrect proof. We evaluate Adapt on two benchmarks\nagainst four existing methods and find that it significantly outperforms the\nbest baseline on both by proving 16.63% and 18.58% more theorems, respectively.\nFurthermore, we demonstrate Adapt's generalizability by evaluating it across\nfive different LLMs. We also conduct ablation studies to measure the\ncontribution of each component and compare the trade-offs of alternative\ndecision-maker designs.", "AI": {"tldr": "Formal verification is hard to scale, even with LLM help, because existing methods use fixed refinement strategies. Adapt proposes a dynamic LLM-guided approach to select better strategies depending on the context, resulting in substantially higher theorem-proving success rates and showing good generalizability across multiple LLMs.", "motivation": "Formal verification via theorem proving is critical for software correctness but is challenging to scale due to manual labor and expertise required. While LLMs offer hope, their proofs often require iterative refinement, and current systems use static strategies that cannot adapt to specific errors, limiting effectiveness.", "method": "This paper introduces Adapt, a framework that uses an LLM-guided decision-maker to dynamically select the most effective proof refinement strategy based on the proof assistant's state and the specific context of an incorrect proof. Adapt is evaluated on benchmarks, compared to existing methods, and tested across multiple LLMs with additional ablation studies.", "result": "Adapt significantly outperforms the best baseline methods, proving 16.63% and 18.58% more theorems on two benchmarks. It generalizes well across five different LLMs. Ablation studies also show the value and trade-offs of various decision-maker components.", "conclusion": "Adapt's dynamic, context-sensitive strategy selection enables more efficient and successful formal verification with LLMs, representing a marked advance over traditional fixed-strategy refinement methods."}}
{"id": "2510.25148", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25148", "abs": "https://arxiv.org/abs/2510.25148", "authors": ["Katsuki Yamagishi", "Norihiro Yoshida", "Erina Makihara", "Katsuro Inoue"], "title": "Automated Program Repair Based on REST API Specifications Using Large Language Models", "comment": null, "summary": "Many cloud services provide REST API accessible to client applications.\nHowever, developers often identify specification violations only during\ntesting, as error messages typically lack the detail necessary for effective\ndiagnosis. Consequently, debugging requires trial and error. This study\nproposes dcFix, a method for detecting and automatically repairing REST API\nmisuses in client programs. In particular, dcFix identifies non-conforming code\nfragments, integrates them with the relevant API specifications into prompts,\nand leverages a Large Language Model (LLM) to produce the corrected code. Our\nevaluation demonstrates that dcFix accurately detects misuse and outperforms\nthe baseline approach, in which prompts to the LLM omit any indication of code\nfragments non conforming to REST API specifications.", "AI": {"tldr": "dcFix is a method that uses LLMs to automatically detect and repair REST API misuses by explicitly incorporating non-conforming code and API specs into prompts. It outperforms simpler approaches and streamlines API debugging.", "motivation": "Developers interacting with cloud service REST APIs often face difficulties diagnosing and correcting API misuse, as error messages are vague and issues are generally discovered only during testing. Diagnosing these issues is inefficient, often involving significant trial and error.", "method": "The paper proposes dcFix, an automated method for detecting and repairing misuses of REST APIs in client code. dcFix identifies code fragments that do not conform to API specifications and creates prompts by combining these fragments with relevant specifications. These prompts are then given to a Large Language Model (LLM), which generates corrected code.", "result": "Evaluations show dcFix can accurately detect REST API misuses in client programs and generate effective repairs. It outperforms a baseline approach where LLM prompts lack information about non-conforming fragments.", "conclusion": "Integrating information about detected non-conforming code with REST API specifications results in significantly improved detection and automated repair of API misuses using LLMs. This can offer more precise and effective debugging for developers."}}
{"id": "2510.25195", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25195", "abs": "https://arxiv.org/abs/2510.25195", "authors": ["Shuochuan Li", "Zan Wang", "Xiaoning Du", "Zhuo Wu", "Jiuqiao Yu", "Junjie Chen"], "title": "Optimizing Knowledge Utilization for Multi-Intent Comment Generation with Large Language Models", "comment": null, "summary": "Code comment generation aims to produce a generic overview of a code snippet,\nhelping developers understand and maintain code. However, generic summaries\nalone are insufficient to meet the diverse needs of practitioners; for example,\ndevelopers expect the implementation insights to be presented in an untangled\nmanner, while users seek clear usage instructions. This highlights the\nnecessity of multi-intent comment generation. With the widespread adoption of\nLarge Language Models (LLMs) for code-related tasks, these models have been\nleveraged to tackle the challenge of multi-intent comment generation. Despite\ntheir successes, state-of-the-art LLM-based approaches often struggle to\nconstruct correct relationships among intents, code, and comments within a\nsmaller number of demonstration examples. To mitigate this issue, we propose a\nframework named KUMIC for multi-intent comment generation. Built upon\nin-context learning, KUMIC leverages Chain-of-Thought (CoT) to optimize\nknowledge utilization for LLMs to generate intent-specific comments.\nSpecifically, KUMIC first designs a retrieval mechanism to obtain similar\ndemonstration examples, which exhibit high code-comment consistency. Then,\nKUMIC leverages CoT to guide LLMs to focus on statements facilitating the\nderivation of code comments aligned with specific intents. In this context,\nKUMIC constructs a mapping knowledge chain, linking code to intent-specific\nstatements to comments, which enables LLMs to follow similar reasoning steps\nwhen generating the desired comments. We conduct extensive experiments to\nevaluate KUMIC, and the results demonstrate that KUMIC outperforms\nstate-of-the-art baselines by 14.49\\%, 22.41\\%, 20.72\\%, and 12.94\\% in terms\nof BLEU, METEOR, ROUGE-L, and SBERT, respectively.", "AI": {"tldr": "KUMIC is a new framework for generating code comments tailored to different user intents using LLMs and Chain-of-Thought reasoning. It significantly outperforms existing methods in generating accurate, purpose-driven comments.", "motivation": "Generic code comments are insufficient to address the varying needs of developers and users, who require comments with distinct implementation insights or clear usage instructions. There is a necessity to generate multi-intent comments that cater to these diverse expectations, a task where existing LLM approaches often fail to correctly relate code, intent, and comments when given limited demonstration examples.", "method": "The authors propose a framework called KUMIC, which utilizes in-context learning and Chain-of-Thought (CoT) prompting with large language models (LLMs). KUMIC retrieves demonstration examples with high code-comment consistency and uses CoT to guide LLMs to generate intent-specific comments. It builds a mapping knowledge chain linking code, intent-specific statements, and comments, improving the reasoning process in multi-intent comment generation.", "result": "Experimental results show that KUMIC outperforms state-of-the-art LLM-based baselines, achieving improvements of 14.49% in BLEU, 22.41% in METEOR, 20.72% in ROUGE-L, and 12.94% in SBERT scores.", "conclusion": "KUMIC effectively addresses the challenges of multi-intent code comment generation, substantially outperforming existing methods in both intent alignment and comment quality."}}
{"id": "2510.25242", "categories": ["cs.SE", "C.3; D.2"], "pdf": "https://arxiv.org/pdf/2510.25242", "abs": "https://arxiv.org/abs/2510.25242", "authors": ["Nao Yoshimura", "Hiroshi Oyama", "Takuya Azumi"], "title": "TECS/Rust-OE: Optimizing Exclusive Control in Rust-based Component Systems for Embedded Devices", "comment": "5 pages (layout expanded from the 4-page IEEE version due to minor\n  lstlisting configuration adjustments for compilation). Originally published\n  as a poster paper at IEEE ISORC 2025", "summary": "The diversification of functionalities and the development of the IoT are\nmaking embedded systems larger and more complex in structure. Ensuring system\nreliability, especially in terms of security, necessitates selecting an\nappropriate programming language. As part of existing research, TECS/Rust has\nbeen proposed as a framework that combines Rust and component-based development\n(CBD) to enable scalable system design and enhanced reliability. This framework\nrepresents system structures using static mutable variables, but excessive\nexclusive controls applied to ensure thread safety have led to performance\ndegradation. This paper proposes TECS/Rust-OE, a memory-safe CBD framework\nutilizing call flows to address these limitations. The proposed Rust code\nleverages real-time OS exclusive control mechanisms, optimizing performance\nwithout compromising reusability. Rust code is automatically generated based on\ncomponent descriptions. Evaluations demonstrate reduced overhead due to\noptimized exclusion control and high reusability of the generated code.", "AI": {"tldr": "To support complex embedded and IoT systems, TECS/Rust-OE offers memory safety and efficient exclusive control in Rust via call flows and OS mechanisms, automatically generating reusable, high-performance code.", "motivation": "The increasing complexity of embedded systems, especially with IoT growth, requires reliable, secure programming frameworks. Previous approaches using Rust and component-based development have suffered from performance issues due to thread safety mechanisms.", "method": "The paper introduces TECS/Rust-OE, a new memory-safe component-based development framework. It uses call flows and real-time OS exclusive control mechanisms to optimize Rust code for embedded systems. Rust code is auto-generated from component descriptions to enhance scalability and reliability.", "result": "Experimental evaluations show that TECS/Rust-OE reduces overhead from exclusion controls and retains high code reusability.", "conclusion": "TECS/Rust-OE effectively balances memory safety, performance, and code reusability for scalable embedded system design, outperforming previous Rust-CBD approaches."}}
{"id": "2510.25270", "categories": ["cs.SE", "C.3; D.2"], "pdf": "https://arxiv.org/pdf/2510.25270", "abs": "https://arxiv.org/abs/2510.25270", "authors": ["Nao Yoshimura", "Hiroshi Oyama", "Takuya Azumi"], "title": "TECS/Rust: Memory-safe Component Framework for Embedded Systems", "comment": "10 pages. This version includes minor lstlisting configuration\n  adjustments for successful compilation. No changes to content or layout.\n  Originally published at IEEE ISORC 2024", "summary": "As embedded systems grow in complexity and scale due to increased functional\ndiversity, component-based development (CBD) emerges as a solution to\nstreamline their architecture and enhance functionality reuse. CBD typically\nutilizes the C programming language for its direct hardware access and\nlow-level operations, despite its susceptibility to memory-related issues. To\naddress these concerns, this paper proposes TECS/Rust, a Rust-based framework\nspecifically designed for TECS, which is a component framework for embedded\nsystems. It leverages Rust's compile-time memory-safe features, such as\nlifetime and borrowing, to mitigate memory vulnerabilities common with C. The\nproposed framework not only ensures memory safety but also maintains the\nflexibility of CBD, automates Rust code generation for CBD components, and\nsupports efficient integration with real-time operating systems. An evaluation\nof the amount of generated code indicates that the code generated by this paper\nframework accounts for a large percentage of the actual code. Compared to code\ndeveloped without the proposed framework, the difference in execution time is\nminimal, indicating that the overhead introduced by the proposed framework is\nnegligible.", "AI": {"tldr": "Switching from C to Rust for embedded component frameworks increases memory safety with little performance cost, while automating much of the code generation.", "motivation": "Embedded systems are becoming more complex, making memory safety an increasing concern, especially when using C in component-based development. The motivation is to find a safer, yet flexible, solution for developing embedded system components.", "method": "The paper proposes TECS/Rust, a Rust-based framework for TECS component systems. It leverages Rust's compile-time memory-safety features and automates Rust code generation for CBD components. It also benchmarks code amount and execution time to validate efficiency.", "result": "TECS/Rust generates a large portion of the code automatically, significantly aiding development. The framework introduces negligible overhead compared to manually developed code, preserving runtime efficiency.", "conclusion": "TECS/Rust successfully enhances memory safety while maintaining flexibility and efficiency in component-based development for embedded systems, making it a promising alternative to C."}}
{"id": "2510.25297", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25297", "abs": "https://arxiv.org/abs/2510.25297", "authors": ["Hidetake Tanaka", "Haruto Tanaka", "Kazumasa Shimari", "Kenichi Matsumoto"], "title": "Understanding the Characteristics of LLM-Generated Property-Based Tests in Exploring Edge Cases", "comment": "Accepted for publication in 2nd IEEE/ACM international conference on\n  AI-powered Software (AIware 2025) : 8 pages, 1 table, 8 figures", "summary": "As Large Language Models (LLMs) increasingly generate code in software\ndevelopment, ensuring the quality of LLM-generated code has become important.\nTraditional testing approaches using Example-based Testing (EBT) often miss\nedge cases -- defects that occur at boundary values, special input patterns, or\nextreme conditions. This research investigates the characteristics of\nLLM-generated Property-based Testing (PBT) compared to EBT for exploring edge\ncases. We analyze 16 HumanEval problems where standard solutions failed on\nextended test cases, generating both PBT and EBT test codes using\nClaude-4-sonnet. Our experimental results reveal that while each method\nindividually achieved a 68.75\\% bug detection rate, combining both approaches\nimproved detection to 81.25\\%. The analysis demonstrates complementary\ncharacteristics: PBT effectively detects performance issues and edge cases\nthrough extensive input space exploration, while EBT effectively detects\nspecific boundary conditions and special patterns. These findings suggest that\na hybrid approach leveraging both testing methods can improve the reliability\nof LLM-generated code, providing guidance for test generation strategies in\nLLM-based code generation.", "AI": {"tldr": "Traditional example-based testing often misses edge cases in LLM-generated code. Property-based testing and example-based testing, when combined, detect more bugs (81.25%) compared to using either alone (68.75%). Each method finds different types of issues, so a hybrid approach improves code reliability.", "motivation": "The motivation is to improve the reliability of code generated by large language models, addressing the problem that traditional example-based testing often misses edge cases and defects relevant to boundary conditions or input extremes.", "method": "The study analyzed 16 HumanEval problems where standard solutions failed on extended test cases, and generated both property-based testing (PBT) and example-based testing (EBT) code using Claude-4-sonnet. The authors compared the bug detection rates of the two methods both individually and in combination.", "result": "Both PBT and EBT individually detected 68.75% of bugs, but combining them increased bug detection to 81.25%. PBT was more effective for performance and extensive input exploration, while EBT excelled at finding issues related to boundary conditions and special patterns.", "conclusion": "A hybrid approach that leverages both PBT and EBT improves the reliability of LLM-generated code. The complementary nature of these methods provides valuable guidance for testing strategies in LLM-based software development."}}
{"id": "2510.25406", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25406", "abs": "https://arxiv.org/abs/2510.25406", "authors": ["Changjie Wang", "Mariano Scazzariello", "Anoud Alshnaka", "Roberto Guanciale", "Dejan Kosti\u0107", "Marco Chiesa"], "title": "Dissect-and-Restore: AI-based Code Verification with Transient Refactoring", "comment": null, "summary": "Formal verification is increasingly recognized as a critical foundation for\nbuilding reliable software systems. However, the need for specialized expertise\nto write precise specifications, navigate complex proof obligations, and learn\nannotations often makes verification an order of magnitude more expensive than\nimplementation. While modern AI systems can recognize patterns in mathematical\nproofs and interpret natural language, effectively integrating them into the\nformal verification process remains an open challenge. We present Prometheus, a\nnovel AI-assisted system that facilitates automated code verification with\ncurrent AI capabilities in conjunction with modular software engineering\nprinciples (e.g., modular refactoring). Our approach begins by decomposing\ncomplex program logic, such as nested loops, into smaller, verifiable\ncomponents. Once verified, these components are recomposed to construct a proof\nof the original program. This decomposition-recomposition workflow is\nnon-trivial. Prometheus addresses this by guiding the proof search through\nstructured decomposition of complex lemmas into smaller, verifiable sub-lemmas.\nWhen automated tools are insufficient, users can provide lightweight natural\nlanguage guidance to steer the proof process effectively. Our evaluation\ndemonstrates that transiently applying modular restructuring to the code\nsubstantially improves the AI's effectiveness in verifying individual\ncomponents. This approach successfully verifies 86% of tasks in our curated\ndataset, compared to 68% for the baseline. Gains are more pronounced with\nincreasing specification complexity, improving from 30% to 69%, and when\nintegrating proof outlines for complex programs, from 25% to 87%.", "AI": {"tldr": "Prometheus is a new AI-assisted tool for formal code verification that uses modular decomposition and allows natural language guidance. It boosts verification rates dramatically over standard methods, making formal verification more practical and accessible, especially for complex programs.", "motivation": "Formal verification of software is essential for reliability but requires significant expertise and cost, making it less accessible. Current AI systems have potential but are not yet effectively integrated into verification workflows.", "method": "The paper introduces Prometheus, an AI-assisted verification system that uses modular software engineering principles. It works by decomposing complex program logic into smaller components, verifying them individually, and then recomposing them to prove the original program. When automation fails, users can give natural language input to aid the process.", "result": "Prometheus outperforms the baseline, successfully verifying 86% of tasks (versus 68%). Improvements are even more substantial for complex specifications (from 30% to 69%) and when adding proof outlines for complex programs (from 25% to 87%).", "conclusion": "AI-assisted modular decomposition and user-guided proof workflows, as embodied in Prometheus, significantly improve both the effectiveness and accessibility of formal verification, especially in challenging or complex cases."}}
{"id": "2510.25423", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25423", "abs": "https://arxiv.org/abs/2510.25423", "authors": ["Ali Asgari", "Annibale Panichella", "Pouria Derakhshanfar", "Mitchell Olsthoorn"], "title": "What Challenges Do Developers Face in AI Agent Systems? An Empirical Study on Stack Overflow", "comment": "12 pages, 4 Figures", "summary": "AI agents have rapidly gained popularity across research and industry as\nsystems that extend large language models with additional capabilities to plan,\nuse tools, remember, and act toward specific goals. Yet despite their promise,\ndevelopers face persistent and often underexplored challenges when building,\ndeploying, and maintaining these emerging systems. To identify these\nchallenges, we study developer discussions on Stack Overflow, the world's\nlargest developer-focused Q and A platform with about 60 million questions and\nanswers and 30 million users. We construct a taxonomy of developer challenges\nthrough tag expansion and filtering, apply LDA-MALLET for topic modeling, and\nmanually validate and label the resulting themes. Our analysis reveals seven\nmajor areas of recurring issues encompassing 77 distinct technical challenges\nrelated to runtime integration, dependency management, orchestration\ncomplexity, and evaluation reliability. We further quantify topic popularity\nand difficulty to identify which issues are most common and hardest to resolve,\nmap the tools and programming languages used in agent development, and track\ntheir evolution from 2021 to 2025 in relation to major AI model and framework\nreleases. Finally, we present the implications of our results, offering\nconcrete guidance for practitioners, researchers, and educators on agent\nreliability and developer support.", "AI": {"tldr": "This paper analyzes Stack Overflow discussions to systematically identify and categorize persistent challenges developers face when working with AI agents, revealing key technical issues and providing guidance to improve agent development and support.", "motivation": "AI agents, which extend large language models with capabilities such as planning and tool usage, are increasingly popular, but developers face significant, often insufficiently explored challenges in building, deploying, and maintaining these systems.", "method": "The authors analyzed developer discussions on Stack Overflow by constructing a taxonomy of developer challenges using tag expansion/filtering, applying LDA-MALLET for topic modeling, and manually validating the identified themes.", "result": "The analysis identified seven major areas of recurring issues, describing 77 specific technical challenges such as runtime integration, dependency management, orchestration complexity, and evaluation reliability. The study also quantified the popularity and difficulty of topics, mapped development tools/languages, and tracked trends from 2021-2025.", "conclusion": "The paper highlights widespread technical challenges in developing AI agents, and offers actionable guidance to improve agent reliability and developer support for practitioners, researchers, and educators."}}
{"id": "2510.25506", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.25506", "abs": "https://arxiv.org/abs/2510.25506", "authors": ["Florian Angermeir", "Maximilian Amougou", "Mark Kreitz", "Andreas Bauer", "Matthias Linhuber", "Davide Fucci", "Fabiola Moy\u00f3n C.", "Daniel Mendez", "Tony Gorschek"], "title": "Reflections on the Reproducibility of Commercial LLM Performance in Empirical Software Engineering Studies", "comment": null, "summary": "Large Language Models have gained remarkable interest in industry and\nacademia. The increasing interest in LLMs in academia is also reflected in the\nnumber of publications on this topic over the last years. For instance, alone\n78 of the around 425 publications at ICSE 2024 performed experiments with LLMs.\nConducting empirical studies with LLMs remains challenging and raises questions\non how to achieve reproducible results, for both other researchers and\npractitioners. One important step towards excelling in empirical research on\nLLMs and their application is to first understand to what extent current\nresearch results are eventually reproducible and what factors may impede\nreproducibility. This investigation is within the scope of our work. We\ncontribute an analysis of the reproducibility of LLM-centric studies, provide\ninsights into the factors impeding reproducibility, and discuss suggestions on\nhow to improve the current state. In particular, we studied the 86 articles\ndescribing LLM-centric studies, published at ICSE 2024 and ASE 2024. Of the 86\narticles, 18 provided research artefacts and used OpenAI models. We attempted\nto replicate those 18 studies. Of the 18 studies, only five were fit for\nreproduction. For none of the five studies, we were able to fully reproduce the\nresults. Two studies seemed to be partially reproducible, and three studies did\nnot seem to be reproducible. Our results highlight not only the need for\nstricter research artefact evaluations but also for more robust study designs\nto ensure the reproducible value of future publications.", "AI": {"tldr": "This paper analyzes the reproducibility of LLM-centric studies at major conferences and finds that most research cannot be reliably reproduced, underlining the urgent need for better documentation and study design in the field.", "motivation": "The paper addresses the growing academic interest in Large Language Models (LLMs) and the need to understand and improve the reproducibility of empirical studies involving these models.", "method": "The authors reviewed 86 LLM-related studies from ICSE 2024 and ASE 2024, focusing on 18 studies that provided artefacts and used OpenAI models, and attempted to replicate their results.", "result": "Out of the 18 studies attempted for replication, only five were sufficiently well-documented for reproduction. However, none could be fully reproduced: two were partially reproducible and three were not reproducible at all.", "conclusion": "There are significant reproducibility issues in current LLM-related research, highlighting the need for stricter artefact evaluation and stronger study design to enable reproducible results."}}
{"id": "2510.25665", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25665", "abs": "https://arxiv.org/abs/2510.25665", "authors": ["Ayse Irmak Ercevik", "Aidan Dakhama", "Melane Navaratnarajah", "Yazhuo Cao", "Leo Fernandes"], "title": "Fuzz Smarter, Not Harder: Towards Greener Fuzzing with GreenAFL", "comment": null, "summary": "Fuzzing has become a key search-based technique for software testing, but\ncontinuous fuzzing campaigns consume substantial computational resources and\ngenerate significant carbon footprints. Existing grey-box fuzzing approaches\nlike AFL++ focus primarily on coverage maximisation, without considering the\nenergy costs of exploring different execution paths. This paper presents\nGreenAFL, an energy-aware framework that incorporates power consumption into\nthe fuzzing heuristics to reduce the environmental impact of automated testing\nwhilst maintaining coverage. GreenAFL introduces two key modifications to\ntraditional fuzzing workflows: energy-aware corpus minimisation considering\npower consumption when reducing initial corpora, and energy-guided heuristics\nthat direct mutation towards high-coverage, low-energy inputs. We conduct an\nablation study comparing vanilla AFL++, energy-based corpus minimisation, and\nenergy-based heuristics to evaluate the individual contributions of each\ncomponent. Results show that highest coverage, and lowest energy usage is\nachieved whenever at least one of our modifications is used.", "AI": {"tldr": "GreenAFL makes fuzzing more eco-friendly by reducing energy use and maintaining high coverage, through energy-aware corpus management and mutation strategies; experiments validate its effectiveness.", "motivation": "Continuous fuzzing requires heavy computational resources, resulting in considerable energy consumption and environmental impact. Classical fuzzers focus solely on coverage and neglect energy efficiency.", "method": "The paper introduces GreenAFL, an energy-aware fuzzing framework that modifies traditional fuzzing by (1) minimizing the corpus using energy consumption as a factor and (2) applying energy-guided heuristics to direct mutations towards low-energy yet high-coverage inputs. An ablation study is performed to separately analyze the effect of each component.", "result": "Using GreenAFL, experimental results showed that either energy-aware corpus minimisation or energy-guided heuristics (or both) led to both higher code coverage and reduced energy usage compared to standard approaches.", "conclusion": "Incorporating power consumption into fuzzing heuristics (as in GreenAFL) is effective for reducing energy footprint while maintaining or improving test coverage, suggesting that energy-aware fuzzing should be adopted for sustainable software testing."}}
{"id": "2510.25692", "categories": ["cs.SE", "cs.LG", "D.2.6; I.2.6"], "pdf": "https://arxiv.org/pdf/2510.25692", "abs": "https://arxiv.org/abs/2510.25692", "authors": ["Tim Strnad", "Bla\u017e Bertalani\u010d", "Carolina Fortuna"], "title": "A Configuration-First Framework for Reproducible, Low-Code Localization", "comment": "20 pages, 7 figures. Preprint submitted to ACM Transactions on\n  Software Engineering and Methodology (TOSEM), 2025", "summary": "Machine learning is increasingly permeating radio-based localization\nservices. To keep results credible and comparable, everyday workflows should\nmake rigorous experiment specification and exact repeatability the default,\nwithout blocking advanced experimentation. However, in practice, researchers\nface a three-way gap that could be filled by a framework that offers (i) low\ncoding effort for end-to-end studies, (ii) reproducibility by default including\nversioned code, data, and configurations, controlled randomness, isolated runs,\nand recorded artifacts, and (iii) built-in extensibility so new models,\nmetrics, and stages can be added with minimal integration effort. Existing\ntools rarely deliver all three for machine learning in general and localization\nworkflows in particular. In this paper we introduce LOCALIZE, a low-code,\nconfiguration-first framework for radio localization in which experiments are\ndeclared in human-readable configuration, a workflow orchestrator runs\nstandardized pipelines from data preparation to reporting, and all artifacts,\nsuch as datasets, models, metrics, and reports, are versioned. The\npreconfigured, versioned datasets reduce initial setup and boilerplate,\nspeeding up model development and evaluation. The design, with clear extension\npoints, allows experts to add components without reworking the infrastructure.\nIn a qualitative comparison and a head-to-head study against a plain Jupyter\nnotebook baseline, we show that the framework reduces authoring effort while\nmaintaining comparable runtime and memory behavior. Furthermore, using a\nBluetooth Low Energy dataset, we show that scaling across training data (1x to\n10x) keeps orchestration overheads bounded as data grows. Overall, the\nframework makes reproducible machine-learning-based localization\nexperimentation practical, accessible, and extensible.", "AI": {"tldr": "LOCALIZE is a low-code framework for radio-based localization that simplifies experiment setup, ensures reproducibility, and allows easy integration of new components. It outperforms traditional workflows in ease of use and scalability without sacrificing performance.", "motivation": "There is a gap in existing machine learning tools for radio-based localization: researchers require low coding effort, default reproducibility, and extensibility, but current solutions rarely deliver all these features.", "method": "The paper introduces LOCALIZE, a low-code, configuration-first framework that enables reproducible and extensible experimentation in radio localization. Experiments are declared through human-readable configurations, and the framework orchestrates standardized pipelines from data preparation to reporting, with versioning for all artifacts.", "result": "LOCALIZE is shown to reduce authoring effort compared to standard Jupyter notebook workflows, while maintaining comparable runtime and memory usage. The design allows for scaling with increasing training data with bounded overhead. Extension points let experts add new functionalities efficiently.", "conclusion": "LOCALIZE makes rigorous, reproducible, and extensible machine-learning-based localization experimentation practical and accessible, filling a key gap in the current research workflow."}}
{"id": "2510.25694", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.25694", "abs": "https://arxiv.org/abs/2510.25694", "authors": ["Jiayi Kuang", "Yinghui Li", "Xin Zhang", "Yangning Li", "Di Yin", "Xing Sun", "Ying Shen", "Philip S. Yu"], "title": "Process-Level Trajectory Evaluation for Environment Configuration in Software Engineering Agents", "comment": null, "summary": "Large language model-based agents show promise for software engineering, but\nenvironment configuration remains a bottleneck due to heavy manual effort and\nscarce large-scale, high-quality datasets. Existing benchmarks assess only\nend-to-end build/test success, obscuring where and why agents succeed or fail.\nWe introduce the Environment Configuration Diagnosis Benchmark, Enconda-bench,\nwhich provides process-level trajectory assessment of fine-grained agent\ncapabilities during environment setup-planning, perception-driven error\ndiagnosis, feedback-driven repair, and action to execute final environment\nconfiguration. Our task instances are automatically constructed by injecting\nrealistic README errors and are validated in Docker for scalable, high-quality\nevaluation. Enconda-bench combines process-level analysis with end-to-end\nexecutability to enable capability assessments beyond aggregate success rates.\nEvaluations across state-of-the-art LLMs and agent frameworks show that while\nagents can localize errors, they struggle to translate feedback into effective\ncorrections, limiting end-to-end performance. To our knowledge, Enconda-bench\nis the first framework to provide process-level internal capability assessment\nfor environment configuration, offering actionable insights for improving\nsoftware engineering agents.", "AI": {"tldr": "Enconda-bench is a new benchmark that evaluates software engineering agents at the process-level for environment configuration. Unlike previous benchmarks that only measure end results, Enconda-bench examines specific capabilities like error localization and repair. Findings show agents can find errors but struggle to fix them using feedback, highlighting a key area for improvement.", "motivation": "While large language model-based agents have made progress in automating software engineering tasks, configuring software environments still requires substantial manual work, largely due to the lack of quality, large-scale datasets and effective evaluation methods.", "method": "The authors introduce 'Enconda-bench,' a benchmark that assesses agents' ability to configure software environments at a granular, process-level. The benchmark operates by automatically injecting realistic errors into README files, validating scenarios in Docker, and analyzing the agent's actions during setup, error diagnosis, repair, and final configuration.", "result": "Experiments on state-of-the-art LLMs and agent frameworks reveal that these agents are capable of detecting and localizing errors, but often struggle to effectively interpret feedback and make successful corrections, which limits their overall performance in environment configuration tasks.", "conclusion": "Enconda-bench provides a unique and detailed framework for internal capability assessment of software engineering agents in environment configuration, offering actionable feedback for future improvements. It advances evaluation beyond simple success rates by opening the 'black box' of the agent's decision-making processes."}}
