{"id": "2510.26016", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.26016", "abs": "https://arxiv.org/abs/2510.26016", "authors": ["Michael Arntzenius"], "title": "Fair intersection of seekable iterators", "comment": "8 pages, 2 figures, published in miniKanren 2025", "summary": "miniKanren's key semantic advance over Prolog is to implement a complete yet\nefficient search strategy, fairly interleaving execution between disjuncts.\nThis fairness is accomplished by bounding how much work is done exploring one\ndisjunct before switching to the next. We show that the same idea -- fairness\nvia bounded work -- underlies an elegant compositional approach to implementing\nworst-case optimal joins using a seekable iterator interface, suitable for\nshallow embedding in functional languages.", "AI": {"tldr": "The paper demonstrates how the fair search strategy of miniKanren, based on bounding work, can be directly adapted to achieve worst-case optimal joins using seekable iterators in functional programming contexts.", "motivation": "The motivation is to provide a fair and efficient search strategy that improves upon Prolog's approach, and to extend this fairness paradigm to implement worst-case optimal joins in a way suited for functional programming environments.", "method": "The method is to use bounded work to achieve fairness in both search strategies and join algorithms, specifically by employing a seekable iterator interface that allows efficient compositional implementation.", "result": "The result is an elegant, compositional, and worst-case optimal join implementation using the principles of bounded work and fairness, which is well-suited for shallow embedding in functional languages.", "conclusion": "Bounding the amount of work before switching tasks enables fairness and efficiency, and this principle can be applied to both logic programming search strategies and database join implementations in functional languages."}}
{"id": "2510.26431", "categories": ["cs.SE", "cs.LO", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.26431", "abs": "https://arxiv.org/abs/2510.26431", "authors": ["Mih\u00e1ly Dobos-Kov\u00e1cs", "Levente Bajczi", "Andr\u00e1s V\u00f6r\u00f6s"], "title": "CHCVerif: A Portfolio-Based Solver for Constrained Horn Clauses", "comment": "In Proceedings HCVS 2025, arXiv:2510.25468", "summary": "Constrained Horn Clauses (CHCs) are widely adopted as intermediate\nrepresentations for a variety of verification tasks, including safety checking,\ninvariant synthesis, and interprocedural analysis. This paper introduces\nCHCVERIF, a portfolio-based CHC solver that adopts a software verification\napproach for solving CHCs. This approach enables us to reuse mature software\nverification tools to tackle CHC benchmarks, particularly those involving\nbitvectors and low-level semantics. Our evaluation shows that while the method\nenjoys only moderate success with linear integer arithmetic, it achieves modest\nsuccess on bitvector benchmarks. Moreover, our results demonstrate the\nviability and potential of using software verification tools as backends for\nCHC solving, particularly when supported by a carefully constructed portfolio.", "AI": {"tldr": "CHCs are key for software verification, but hard to solve for bitvectors/low-level semantics. CHCVERIF uses established verification tools in a portfolio to tackle these cases, with moderate success for integers and modest bitvector results. Portfolio-based tool reuse is promising for CHC solvers, especially on complex benchmarks.", "motivation": "Constrained Horn Clauses (CHCs) are extensively used for many verification tasks, but solving challenging instances (especially those involving bitvectors and low-level semantics) remains difficult. Existing CHC solvers have their limitations.", "method": "The authors introduce CHCVERIF, a solver that employs a portfolio-based approach using mature software verification tools to solve CHC problems. This method leverages the strengths of existing tools by incorporating them into a portfolio to address a broad range of CHC benchmarks.", "result": "CHCVERIF demonstrates moderate success with linear integer arithmetic and modest success on bitvector benchmarks. The evaluation shows that using software verification tools as backends in a portfolio is a viable strategy for CHC solving, especially for benchmarks with complex semantics.", "conclusion": "Software verification tools, when used in a portfolio and carefully integrated, can be effective backends for solving CHCs, showing particular promise for benchmarks involving bitvectors and low-level semantics. This approach expands the toolbox for CHC solving."}}
{"id": "2510.25882", "categories": ["cs.SE", "D.2.9"], "pdf": "https://arxiv.org/pdf/2510.25882", "abs": "https://arxiv.org/abs/2510.25882", "authors": ["Wenhao Yang", "Minghui Zhou", "Daniel Izquierdo Cort\u00e1zar", "Yehui Wang"], "title": "Internal Vulnerabilities, External Threats: A Grounded Framework for Enterprise Open Source Risk Governance", "comment": null, "summary": "Enterprise engagement with open source has evolved from tactical adoption to\nstrategic deep integration, exposing them to a complex risk landscape far\nbeyond mere code. However, traditional risk management, narrowly focused on\ntechnical tools, is structurally inadequate for systemic threats like upstream\n\"silent fixes\", community conflicts, or sudden license changes, creating a\ndangerous governance blind spot. To address this governance vacuum and enable\nthe necessary shift from tactical risk management to holistic risk governance,\nwe conducted a grounded theory study with 15 practitioners to develop a\nholistic risk governance framework. Our study formalizes an analytical\nframework built on a foundational risk principle: an uncontrollable External\nThreat (e.g., a sudden license change in a key dependency) only becomes a\ncritical risk when it exploits a controllable Internal Vulnerability (e.g., an\nundefined risk appetite for single-vendor projects), which then amplifies the\nimpact.The framework operationalizes this principle through a clear logical\nchain: \"Objectives -> Threats -> Vulnerabilities -> Mitigation\" (OTVM). This\nprovides a holistic decision model that transcends mere technical checklists.\nBased on this logic, our contributions are: (1) a \"Strategic Objectives Matrix\"\nto clarify goals; (2) a systematic dual taxonomy of External Threats (Ex-Tech,\nEx-Comm, Ex-Eco) and Internal Vulnerabilities (In-Strat, In-Ops, In-Tech); and\n(3) an actionable mitigation framework mapping capability-building to these\nvulnerabilities. The framework's analytical utility was validated by three\nindustry experts through retrospective case studies on real-world incidents.\nThis work provides a novel diagnostic lens and a systematic path for\nenterprises to shift from reactive \"firefighting\" to proactively building an\norganizational \"immune system\".", "AI": {"tldr": "Enterprises face complex risks from deep open source integration that traditional risk management can't address. This paper proposes and validates a holistic framework\u2014connecting objectives, threats, vulnerabilities, and mitigations\u2014to proactively govern these risks, providing practical tools for organizations to build resilience.", "motivation": "Traditional enterprise risk management for open source activities is narrowly focused on technical aspects and fails to address broader systemic and governance risks associated with deeper integration into open source ecosystems. The motivation is to fill this gap by developing a holistic risk governance framework.", "method": "The method involved a grounded theory study with 15 practitioners. Based on their insights and experiences, the authors developed a formal analytical framework and validated its utility through retrospective case studies with three industry experts.", "result": "The result is a holistic risk governance framework for enterprises engaging with open source. It features an 'Objectives -> Threats -> Vulnerabilities -> Mitigation' logical chain (OTVM), a Strategic Objectives Matrix, a dual taxonomy of external threats and internal vulnerabilities, and an actionable mitigation framework. The framework was validated as analytically useful in real-world scenarios by external experts.", "conclusion": "The study introduces a novel framework that enables enterprises to move from tactical and reactive risk management to proactive and strategic risk governance in the context of open source engagement. This framework offers a practical decision model and tools to build an organizational 'immune system' against complex open source-related risks, moving beyond traditional technical checklists."}}
{"id": "2510.25890", "categories": ["cs.SE", "cs.AI", "D.2.4; I.2.2"], "pdf": "https://arxiv.org/pdf/2510.25890", "abs": "https://arxiv.org/abs/2510.25890", "authors": ["Tong Ma", "Hui Lai", "Hui Wang", "Zhenhu Tian", "Jizhou Wang", "Haichao Wu", "Yongfan Gao", "Chaochao Li", "Fengjie Xu", "Ling Fang"], "title": "PRISM: Proof-Carrying Artifact Generation through LLM x MDE Synergy and Stratified Constraints", "comment": "45 pages, 9 figures", "summary": "PRISM unifies Large Language Models with Model-Driven Engineering to generate\nregulator-ready artifacts and machine-checkable evidence for safety- and\ncompliance-critical domains. PRISM integrates three pillars: a Unified\nMeta-Model (UMM) reconciles heterogeneous schemas and regulatory text into a\nsingle semantic space; an Integrated Constraint Model (ICM) compiles structural\nand semantic requirements into enforcement artifacts including generation-time\nautomata (GBNF, DFA) and post-generation validators (e.g., SHACL, SMT); and\nConstraint-Guided Verifiable Generation (CVG) applies these through two-layer\nenforcement - structural constraints drive prefix-safe decoding while\nsemantic/logical validation produces machine-checkable certificates. When\nviolations occur, PRISM performs audit-guided repair and records generation\ntraces for compliance review. We evaluate PRISM in automotive software\nengineering (AUTOSAR) and cross-border legal jurisdiction (Brussels I bis).\nPRISM produces structurally valid, auditable artifacts that integrate with\nexisting tooling and substantially reduce manual remediation effort, providing\na practical path toward automated artifact generation with built-in assurance.", "AI": {"tldr": "PRISM combines LLMs and model-driven engineering to automatically generate compliance-ready artifacts. It ensures structural and semantic validity, supports auditing, and reduces manual work in safety- and compliance-critical domains.", "motivation": "There is a growing need for generating compliance-ready and safety-critical artifacts in domains such as automotive engineering and cross-border legal systems, but existing methods require significant manual effort and lack built-in verification and assurance.", "method": "PRISM is introduced as a framework that combines Large Language Models (LLMs) with Model-Driven Engineering (MDE). Its architecture involves a Unified Meta-Model (UMM) to reconcile different schemas and regulatory texts, an Integrated Constraint Model (ICM) to formalize requirements into enforcement tools, and a Constraint-Guided Verifiable Generation (CVG) mechanism for structural and semantic validation, including audit and repair mechanisms.", "result": "The evaluation of PRISM in domains such as automotive software engineering (AUTOSAR) and legal jurisdiction (Brussels I bis) demonstrates that it can generate structurally valid, auditable, and regulator-ready artifacts. The generated outputs are integrable with existing tooling and reduce the need for manual remediation.", "conclusion": "PRISM presents a practical solution for automated generation of compliance- and safety-critical artifacts with built-in assurance, reducing manual intervention and enhancing verifiability."}}
{"id": "2510.25935", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.25935", "abs": "https://arxiv.org/abs/2510.25935", "authors": ["Ant\u00eda Dorado", "Iv\u00e1n Folgueira", "Sof\u00eda Mart\u00edn", "Gonzalo Mart\u00edn", "\u00c1lvaro Porto", "Alejandro Ramos", "John Wallace"], "title": "A Process Mining-Based System For The Analysis and Prediction of Software Development Workflows", "comment": "16 pages, 7 figures, 4 tables", "summary": "CodeSight is an end-to-end system designed to anticipate deadline compliance\nin software development workflows. It captures development and deployment data\ndirectly from GitHub, transforming it into process mining logs for detailed\nanalysis. From these logs, the system generates metrics and dashboards that\nprovide actionable insights into PR activity patterns and workflow efficiency.\nBuilding on this structured representation, CodeSight employs an LSTM model\nthat predicts remaining PR resolution times based on sequential activity traces\nand static features, enabling early identification of potential deadline\nbreaches. In tests, the system demonstrates high precision and F1 scores in\npredicting deadline compliance, illustrating the value of integrating process\nmining with machine learning for proactive software project management.", "AI": {"tldr": "CodeSight uses process mining and LSTM-based machine learning on GitHub workflow data to predict whether pull requests will meet deadlines, delivering accurate forecasts and useful dashboard insights for better software project management.", "motivation": "Deadline compliance is a critical challenge in software development, and teams need better tools to proactively manage deadlines and workflow efficiency.", "method": "CodeSight collects development and deployment data from GitHub, converts it into process mining logs, extracts actionable metrics, and uses an LSTM model to predict remaining PR resolution times based on sequential traces and static features.", "result": "CodeSight achieves high precision and F1 scores in predicting deadline compliance for pull requests, providing actionable insights to manage workflows.", "conclusion": "Integrating process mining with machine learning through CodeSight significantly enhances the ability to anticipate and manage deadline breaches in software development."}}
{"id": "2510.26130", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.26130", "abs": "https://arxiv.org/abs/2510.26130", "authors": ["Musfiqur Rahman", "SayedHassan Khatoonabadi", "Emad Shihab"], "title": "Beyond Synthetic Benchmarks: Evaluating LLM Performance on Real-World Class-Level Code Generation", "comment": "Pre-print prepared for journal submission", "summary": "Large language models (LLMs) have advanced code generation at the function\nlevel, yet their ability to produce correct class-level implementations in\nauthentic software projects remains poorly understood. This work introduces a\nnovel benchmark derived from open-source repositories, comprising real-world\nclasses divided into seen and unseen partitions to evaluate generalization\nunder practical conditions. The evaluation examines multiple LLMs under varied\ninput specifications, retrieval-augmented configurations, and documentation\ncompleteness levels.\n  Results reveal a stark performance disparity: LLMs achieve 84% to 89%\ncorrectness on established synthetic benchmarks but only 25% to 34% on\nreal-world class tasks, with negligible differences between familiar and novel\ncodebases. Comprehensive docstrings yield modest gains of 1% to 3% in\nfunctional accuracy, though statistical significance is rare.\nRetrieval-augmented generation proves most effective with partial\ndocumentation, improving correctness by 4% to 7% by supplying concrete\nimplementation patterns absent from specifications. Error profiling identifies\nAttributeError, TypeError, and AssertionError as dominant failure modes (84% of\ncases), with synthetic tests overemphasizing assertion issues and real-world\nscenarios highlighting type and attribute mismatches. Retrieval augmentation\nreduces logical flaws but can introduce dependency conflicts.\n  The benchmark and analysis expose critical limitations in current LLM\ncapabilities for class-level engineering, offering actionable insights for\nenhancing context modelling, documentation strategies, and retrieval\nintegration in production code assistance tools.", "AI": {"tldr": "This paper introduces a benchmark using real-world software classes to assess LLMs on class-level code generation. While LLMs excel on synthetic tasks, their real-world performance is much worse. Input completeness helps only slightly, and retrieval-based augmentation is most beneficial when documentation is limited but can bring new issues. The analysis reveals key shortcomings in LLMs for practical code engineering and suggests future improvements.", "motivation": "LLMs have excelled at code generation for small, function-level tasks, but their ability to handle larger, class-level implementations in realistic settings is poorly understood. The paper aims to address this gap.", "method": "The authors introduce a benchmark based on real-world open-source classes, split into 'seen' and 'unseen' partitions. They evaluate several LLMs using different input specifications, retrieval-augmented setups, and documentation levels.", "result": "LLMs perform well (84%-89%) on synthetic benchmarks but poorly (25%-34%) on real-world class-level tasks, with little difference for familiar vs novel code. Complete docstrings provide minor improvements. Retrieval augmentation helps most when documentation is incomplete, but it introduces new dependency issues.", "conclusion": "Current LLMs have substantial limitations in class-level code synthesis, especially in genuine software settings. Their weaknesses, mainly type and attribute errors, are not addressed by synthetic testing alone. Improving context modelling, documentation, and retrieval mechanisms is needed for practical production use."}}
{"id": "2510.26171", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26171", "abs": "https://arxiv.org/abs/2510.26171", "authors": ["Hasnain Iqbal", "Zerina Begum", "Kazi Sakib"], "title": "Reduction of Test Re-runs by Prioritizing Potential Order Dependent Flaky Tests", "comment": null, "summary": "Flaky tests can make automated software testing unreliable due to their\nunpredictable behavior. These tests can pass or fail on the same code base on\nmultiple runs. However, flaky tests often do not refer to any fault, even\nthough they can cause the continuous integration (CI) pipeline to fail. A\ncommon type of flaky test is the order-dependent (OD) test. The outcome of an\nOD test depends on the order in which it is run with respect to other test\ncases. Several studies have explored the detection and repair of OD tests.\nHowever, their methods require re-runs of tests multiple times, that are not\nrelated to the order dependence. Hence, prioritizing potential OD tests is\nnecessary to reduce the re-runs. In this paper, we propose a method to\nprioritize potential order-dependent tests. By analyzing shared static fields\nin test classes, we identify tests that are more likely to be order-dependent.\nIn our experiment on 27 project modules, our method successfully prioritized\nall OD tests in 23 cases, reducing test executions by an average of 65.92% and\nunnecessary re-runs by 72.19%. These results demonstrate that our approach\nsignificantly improves the efficiency of OD test detection by lowering\nexecution costs.", "AI": {"tldr": "The paper presents a static analysis method for prioritizing order-dependent flaky tests, dramatically decreasing the number of required test re-runs and improving continuous integration efficiency.", "motivation": "Flaky tests, particularly order-dependent (OD) tests, hinder the reliability of automated software testing and CI pipelines. Current OD test detection methods require repeated test re-runs, causing inefficiency.", "method": "The proposed method analyzes shared static fields in test classes to identify and prioritize tests likely to be order-dependent, aiming to focus re-runs only on relevant tests.", "result": "On 27 project modules, the method prioritized all OD tests in 23 cases, reducing test executions by 65.92% and unnecessary re-runs by 72.19%, improving detection efficiency.", "conclusion": "The approach efficiently detects OD tests, significantly reducing execution and re-run costs in CI pipelines."}}
{"id": "2510.26174", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26174", "abs": "https://arxiv.org/abs/2510.26174", "authors": ["Liming Dong", "Sung Une Lee", "Zhenchang Xing", "Muhammad Ejaz Ahmed", "Stefan Avgoustakis"], "title": "The \"4W+1H\" of Software Supply Chain Security Checklist for Critical Infrastructure", "comment": "18 pages, 4 figures", "summary": "The increasing frequency and sophistication of software supply chain attacks\npose severe risks to critical infrastructure sectors, threatening national\nsecurity, economic stability, and public safety. Despite growing awareness,\nexisting security practices remain fragmented and insufficient, with most\nframeworks narrowly focused on isolated life cycle stages or lacking alignment\nwith the specific needs of critical infrastructure (CI) sectors. In this paper,\nwe conducted a multivocal literature review across international frameworks,\nAustralian regulatory sources, and academic studies to identify and analyze\nsecurity practices across the software supply chain, especially specific CI\nsector. Our analysis found that few existing frameworks are explicitly tailored\nto CI domains. We systematically leveraged identified software supply chain\nsecurity frameworks, using a \"4W+1H\" analytical approach, we synthesized ten\ncore categories (what) of software supply chain security practices, mapped them\nacross life-cycle phases (when), stakeholder roles (who), and implementation\nlevels (how), and examined their coverage across existing frameworks (where).\nBuilding on these insights, the paper culminates in structured, multi-layered\nchecklist of 80 questions designed to relevant stakeholders evaluate and\nenhance their software supply chain security. Our findings reveal gaps between\nframework guidance and sector-specific needs, highlight the need for\nintegrated, context-aware approaches to safeguard critical infrastructure from\nevolving software supply chain risks.", "AI": {"tldr": "Current software supply chain security frameworks lack sufficient coverage for critical infrastructure needs. This paper analyzes existing approaches, synthesizes core practices, and presents an 80-question checklist to help stakeholders assess and improve security. Significant gaps and the need for tailored, integrated solutions are highlighted.", "motivation": "The motivation stems from the increasing risk posed by software supply chain attacks to critical infrastructure sectors, and the inadequacy of current security frameworks that don't address the specific needs of these sectors.", "method": "The authors performed a multivocal literature review, analyzing international frameworks, Australian regulations, and academic studies. They applied a '4W+1H' analytical technique to identify and categorize security practices, mapping them across various dimensions such as lifecycle phases and stakeholder roles.", "result": "The research synthesized ten key categories of security practices, revealed that few frameworks are tailored for critical infrastructure, and produced an 80-question multi-layered checklist for stakeholders. Gaps between current framework guidance and sector-specific needs were identified.", "conclusion": "To effectively counter software supply chain threats in critical infrastructure, there is a pressing need for integrated, context-sensitive security approaches. Existing frameworks must evolve to better address the unique challenges faced by these vital sectors."}}
{"id": "2510.26275", "categories": ["cs.SE", "cs.AI", "cs.ET", "cs.LG", "cs.MA"], "pdf": "https://arxiv.org/pdf/2510.26275", "abs": "https://arxiv.org/abs/2510.26275", "authors": ["Domenico Amalfitano", "Andreas Metzger", "Marco Autili", "Tommaso Fulcini", "Tobias Hey", "Jan Keim", "Patrizio Pelliccione", "Vincenzo Scotti", "Anne Koziolek", "Raffaela Mirandola", "Andreas Vogelsang"], "title": "A Research Roadmap for Augmenting Software Engineering Processes and Software Products with Generative AI", "comment": null, "summary": "Generative AI (GenAI) is rapidly transforming software engineering (SE)\npractices, influencing how SE processes are executed, as well as how software\nsystems are developed, operated, and evolved. This paper applies design science\nresearch to build a roadmap for GenAI-augmented SE. The process consists of\nthree cycles that incrementally integrate multiple sources of evidence,\nincluding collaborative discussions from the FSE 2025 \"Software Engineering\n2030\" workshop, rapid literature reviews, and external feedback sessions\ninvolving peers. McLuhan's tetrads were used as a conceptual instrument to\nsystematically capture the transforming effects of GenAI on SE processes and\nsoftware products.The resulting roadmap identifies four fundamental forms of\nGenAI augmentation in SE and systematically characterizes their related\nresearch challenges and opportunities. These insights are then consolidated\ninto a set of future research directions. By grounding the roadmap in a\nrigorous multi-cycle process and cross-validating it among independent author\nteams and peers, the study provides a transparent and reproducible foundation\nfor analyzing how GenAI affects SE processes, methods and tools, and for\nframing future research within this rapidly evolving area. Based on these\nfindings, the article finally makes ten predictions for SE in the year 2030.", "AI": {"tldr": "The paper provides a rigorously developed, evidence-based roadmap on how generative AI will shape software engineering practices up to 2030, mapping challenges, opportunities, and future research directions while making ten predictions for the field.", "motivation": "Generative AI (GenAI) is rapidly changing software engineering (SE), creating a need for a clear understanding and roadmap of how SE practices and products will be affected and evolve.", "method": "The paper applies a design science research approach across three iterative cycles, integrating evidence from peer discussions, workshop interactions, literature reviews, and external feedback. McLuhan's tetrads serve as the conceptual tool to systematically explore GenAI's transformative impact.", "result": "A comprehensive roadmap illustrating four fundamental ways GenAI augments SE is created, mapping associated research challenges and opportunities. The study presents consolidated research directions and makes ten predictions for software engineering in 2030.", "conclusion": "This work offers a transparent, reproducible roadmap for GenAI-augmented software engineering, grounded in multi-source evidence and rigorous methodology, helping guide future research and development."}}
{"id": "2510.26287", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26287", "abs": "https://arxiv.org/abs/2510.26287", "authors": ["Guochang Li", "Yuchen Liu", "Zhen Qin", "Yunkun Wang", "Jianping Zhong", "Chen Zhi", "Binhua Li", "Fei Huang", "Yongbin Li", "Shuiguang Deng"], "title": "Empowering RepoQA-Agent based on Reinforcement Learning Driven by Monte-carlo Tree Search", "comment": null, "summary": "Repository-level software engineering tasks require large language models\n(LLMs) to efficiently navigate and extract information from complex codebases\nthrough multi-turn tool interactions. Existing approaches face significant\nlimitations: training-free, in-context learning methods struggle to guide\nagents effectively in tool utilization and decision-making based on\nenvironmental feedback, while training-based approaches typically rely on\ncostly distillation from larger LLMs, introducing data compliance concerns in\nenterprise environments. To address these challenges, we introduce\nRepoSearch-R1, a novel agentic reinforcement learning framework driven by\nMonte-carlo Tree Search (MCTS). This approach allows agents to generate\ndiverse, high-quality reasoning trajectories via self-training without\nrequiring model distillation or external supervision. Based on RepoSearch-R1,\nwe construct a RepoQA-Agent specifically designed for repository\nquestion-answering tasks. Comprehensive evaluation on repository\nquestion-answering tasks demonstrates that RepoSearch-R1 achieves substantial\nimprovements of answer completeness: 16.0% enhancement over no-retrieval\nmethods, 19.5% improvement over iterative retrieval methods, and 33% increase\nin training efficiency compared to general agentic reinforcement learning\napproaches. Our cold-start training methodology eliminates data compliance\nconcerns while maintaining robust exploration diversity and answer completeness\nacross repository-level reasoning tasks.", "AI": {"tldr": "RepoSearch-R1 leverages MCTS-driven self-training to create efficient LLM agents for code repository reasoning and question-answering, outperforming existing no-retrieval and iterative methods in answer completeness and training speed, without requiring risky data distillation.", "motivation": "Existing methods (both training-free and training-based) for LLM-driven repository-level software tasks face major limitations: weak agent guidance and costly, compliance-risk distillation processes.", "method": "The authors introduce RepoSearch-R1, an agentic reinforcement learning framework based on Monte Carlo Tree Search (MCTS). This enables agents to self-train, generating diverse and high-quality reasoning paths without external supervision or model distillation. A specialized agent, RepoQA-Agent, is built for repository question-answering using this framework.", "result": "RepoSearch-R1 significantly boosts answer completeness: 16% vs no-retrieval, 19.5% vs iterative retrieval, and achieves 33% higher training efficiency compared to general agentic RL methods. The proposed cold-start training method also addresses data compliance while sustaining strong exploration and answering ability.", "conclusion": "RepoSearch-R1 presents a novel, effective, and compliant agentic RL methodology for software engineering tasks over complex codebases, improving answer accuracy and training efficiency."}}
{"id": "2510.26413", "categories": ["cs.SE", "cs.DC"], "pdf": "https://arxiv.org/pdf/2510.26413", "abs": "https://arxiv.org/abs/2510.26413", "authors": ["Nuno Saavedra", "Alexandra Mendes", "Jo\u00e3o F. Ferreira"], "title": "Environmental Impact of CI/CD Pipelines", "comment": "This work has been submitted to the IEEE for possible publication", "summary": "CI/CD pipelines are widely used in software development, yet their\nenvironmental impact, particularly carbon and water footprints (CWF), remains\nlargely unknown to developers, as CI service providers typically do not\ndisclose such information. With the growing environmental impact of cloud\ncomputing, understanding the CWF of CI/CD services has become increasingly\nimportant.\n  This work investigates the CWF of using GitHub Actions, focusing on\nopen-source repositories where usage is free and unlimited for standard\nrunners. We build upon a methodology from the Cloud Carbon Footprint framework\nand we use the largest dataset of workflow runs reported in the literature to\ndate, comprising over 2.2 million workflow runs from more than 18,000\nrepositories.\n  Our analysis reveals that the GitHub Actions ecosystem results in a\nsubstantial CWF. Our estimates for the carbon footprint in 2024 range from\n150.5 MTCO2e in the most optimistic scenario to 994.9 MTCO2e in the most\npessimistic scenario, while the water footprint ranges from 1,989.6 to 37,664.5\nkiloliters. The most likely scenario estimates are 456.9 MTCO2e for carbon\nfootprint and 5,738.2 kiloliters for water footprint. To provide perspective,\nthe carbon footprint in the most likely scenario is equivalent to the carbon\ncaptured by 7,615 urban trees in a year, and the water footprint is comparable\nto the water consumed by an average American family over 5,053 years.\n  We explore strategies to mitigate this impact, primarily by reducing wasted\ncomputational resources. Key recommendations include deploying runners in\nregions whose energy production has a low environmental impact such as France\nand the United Kingdom, implementing stricter deactivation policies for\nscheduled runs and aligning their execution with periods when the regional\nenergy mix is more environmentally favorable, and reducing the size of\nrepositories.", "AI": {"tldr": "GitHub Actions, widely used for free CI/CD in open-source projects, generates considerable carbon and water footprints, yet this impact has been understudied. Analyzing over 2.2 million workflow runs, this work finds the yearly impact is comparable to thousands of urban trees or centuries of human water use. The paper recommends targeted strategies, such as geographical optimization and stricter resource management, to reduce this hidden environmental cost.", "motivation": "With the increasing environmental impact of cloud computing, there's a critical need for developers to understand the carbon and water footprints (CWF) of CI/CD pipelines. However, CI service providers typically do not disclose such data, leaving developers in the dark about the true environmental impact of the tools they use.", "method": "The authors built upon the Cloud Carbon Footprint framework and analyzed an extensive dataset\u2014over 2.2 million workflow runs from more than 18,000 open-source repositories using GitHub Actions. They estimated the CWF for 2024 under different scenarios and explored mitigation strategies.", "result": "GitHub Actions' usage has a significant environmental impact. Estimated 2024 carbon footprints range from 150.5 to 994.9 metric tons of CO2 equivalent; water footprints range from 1,989.6 to 37,664.5 kiloliters. The most likely scenario is 456.9 MTCO2e and 5,738.2 kiloliters, respectively. The study also identifies and recommends practical strategies to significantly reduce these impacts.", "conclusion": "CI/CD pipelines, specifically GitHub Actions, have a substantial environmental footprint, which can and should be mitigated. Developers, platforms, and policy makers have a responsibility to prioritize greener practices. Key approaches include optimal placement of runners and improved resource management."}}
{"id": "2510.26423", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.26423", "abs": "https://arxiv.org/abs/2510.26423", "authors": ["Dong Huang", "Mingzhe Du", "Jie M. Zhang", "Zheng Lin", "Meng Luo", "Qianru Zhang", "See-Kiong Ng"], "title": "Nexus: Execution-Grounded Multi-Agent Test Oracle Synthesis", "comment": "Under Review", "summary": "Test oracle generation in non-regression testing is a longstanding challenge\nin software engineering, where the goal is to produce oracles that can\naccurately determine whether a function under test (FUT) behaves as intended\nfor a given input. In this paper, we introduce Nexus, a novel multi-agent\nframework to address this challenge. Nexus generates test oracles by leveraging\na diverse set of specialized agents that synthesize test oracles through a\nstructured process of deliberation, validation, and iterative self-refinement.\nDuring the deliberation phase, a panel of four specialist agents, each\nembodying a distinct testing philosophy, collaboratively critiques and refines\nan initial set of test oracles. Then, in the validation phase, Nexus generates\na plausible candidate implementation of the FUT and executes the proposed\noracles against it in a secure sandbox. For any oracle that fails this\nexecution-based check, Nexus activates an automated selfrefinement loop, using\nthe specific runtime error to debug and correct the oracle before\nre-validation. Our extensive evaluation on seven diverse benchmarks\ndemonstrates that Nexus consistently and substantially outperforms\nstate-of-theart baselines. For instance, Nexus improves the test-level oracle\naccuracy on the LiveCodeBench from 46.30% to 57.73% for GPT-4.1-Mini. The\nimproved accuracy also significantly enhances downstream tasks: the bug\ndetection rate of GPT4.1-Mini generated test oracles on HumanEval increases\nfrom 90.91% to 95.45% for Nexus compared to baselines, and the success rate of\nautomated program repair improves from 35.23% to 69.32%.", "AI": {"tldr": "Nexus, a multi-agent framework for test oracle generation, uses specialist agents, collaborative deliberation, and iterative validation. It significantly boosts accuracy and effectiveness in software testing tasks compared to previous methods, as evidenced across diverse benchmarks.", "motivation": "Generating accurate test oracles for non-regression testing remains a core and unsolved problem in software engineering, hindering reliable automated testing and program repair.", "method": "The authors propose Nexus, a multi-agent framework comprised of specialist agents, each adopting different testing philosophies. Nexus performs test oracle synthesis through collaborative deliberation, validation against plausible candidate implementations, and iterative self-refinement based on runtime errors, all within a secure sandbox.", "result": "Nexus substantially outperforms leading baselines in oracle accuracy, bug detection, and program repair across seven benchmarks. For example, GPT-4.1-Mini's oracle accuracy on LiveCodeBench increased from 46.30% to 57.73%, bug detection on HumanEval from 90.91% to 95.45%, and program repair success from 35.23% to 69.32%.", "conclusion": "Nexus provides a robust and effective solution to test oracle generation challenges in software engineering, leveraging multi-agent collaboration and self-refinement to deliver significant improvements over existing approaches."}}
{"id": "2510.26457", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.26457", "abs": "https://arxiv.org/abs/2510.26457", "authors": ["Fang Liu", "Simiao Liu", "Yinghao Zhu", "Xiaoli Lian", "Li Zhang"], "title": "SecureReviewer: Enhancing Large Language Models for Secure Code Review through Secure-aware Fine-tuning", "comment": "Accepted by ICSE 2026. Code and data:\n  https://github.com/SIMIAO515/SecureReviewer", "summary": "Identifying and addressing security issues during the early phase of the\ndevelopment lifecycle is critical for mitigating the long-term negative impacts\non software systems. Code review serves as an effective practice that enables\ndevelopers to check their teammates' code before integration into the codebase.\nTo streamline the generation of review comments, various automated code review\napproaches have been proposed, where LLM-based methods have significantly\nadvanced the capabilities of automated review generation. However, existing\nmodels primarily focus on general-purpose code review, their effectiveness in\nidentifying and addressing security-related issues remains underexplored.\nMoreover, adapting existing code review approaches to target security issues\nfaces substantial challenges, including data scarcity and inadequate evaluation\nmetrics. To address these limitations, we propose SecureReviewer, a new\napproach designed for enhancing LLMs' ability to identify and resolve\nsecurity-related issues during code review. Specifically, we first construct a\ndataset tailored for training and evaluating secure code review capabilities.\nLeveraging this dataset, we fine-tune LLMs to generate code review comments\nthat can effectively identify security issues and provide fix suggestions with\nour proposed secure-aware fine-tuning strategy. To mitigate hallucination in\nLLMs and enhance the reliability of their outputs, we integrate the RAG\ntechnique, which grounds the generated comments in domain-specific security\nknowledge. Additionally, we introduce SecureBLEU, a new evaluation metric\ndesigned to assess the effectiveness of review comments in addressing security\nissues. Experimental results demonstrate that SecureReviewer outperforms\nstate-of-the-art baselines in both security issue detection accuracy and the\noverall quality and practical utility of generated review comments.", "AI": {"tldr": "This paper presents SecureReviewer, a framework to train and evaluate LLMs for security-focused code reviews, incorporating a custom dataset, secure-aware fine-tuning, RAG technology, and a new evaluation metric. Experiments confirm SecureReviewer outperforms existing solutions in identifying and fixing security vulnerabilities in code.", "motivation": "Most automated code review systems, including those using large language models (LLMs), do not specifically address security-related code issues and face challenges such as limited data and poor evaluation metrics for secure review.", "method": "The paper introduces SecureReviewer, which involves constructing a security-focused dataset, fine-tuning LLMs with a secure-aware strategy, and incorporating Retrieval-Augmented Generation (RAG) for more accurate and reliable code review comments. It also proposes SecureBLEU, a metric to objectively evaluate security-centered review comments.", "result": "SecureReviewer, with its tailored dataset, secure-aware fine-tuning, RAG integration, and SecureBLEU metric, achieves superior performance in detecting and resolving security issues compared to current state-of-the-art automated review systems.", "conclusion": "SecureReviewer improves the detection and resolution of security-related code issues during automated code review, leveraging specialized datasets, fine-tuning strategies, and metrics to advance the reliability and utility of LLM-driven security review."}}
{"id": "2510.26480", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26480", "abs": "https://arxiv.org/abs/2510.26480", "authors": ["Sivajeet Chand", "Melih Kilic", "Roland W\u00fcrsching", "Sushant Kumar Pandey", "Alexander Pretschner"], "title": "Automated Extract Method Refactoring with Open-Source LLMs: A Comparative Study", "comment": "Accepted at AIware'25 - Main Track", "summary": "Automating the Extract Method refactoring (EMR) remains challenging and\nlargely manual despite its importance in improving code readability and\nmaintainability. Recent advances in open-source, resource-efficient Large\nLanguage Models (LLMs) offer promising new approaches for automating such\nhigh-level tasks. In this work, we critically evaluate five state-of-the-art\nopen-source LLMs, spanning 3B to 8B parameter sizes, on the EMR task for Python\ncode. We systematically assess functional correctness and code quality using\nautomated metrics and investigate the impact of prompting strategies by\ncomparing one-shot prompting to a Recursive criticism and improvement (RCI)\napproach. RCI-based prompting consistently outperforms one-shot prompting in\ntest pass rates and refactoring quality. The best-performing models,\nDeepseek-Coder-RCI and Qwen2.5-Coder-RCI, achieve test pass percentage (TPP)\nscores of 0.829 and 0.808, while reducing lines of code (LOC) per method from\n12.103 to 6.192 and 5.577, and cyclomatic complexity (CC) from 4.602 to 3.453\nand 3.294, respectively. A developer survey on RCI-generated refactorings shows\nover 70% acceptance, with Qwen2.5-Coder rated highest across all evaluation\ncriteria. In contrast, the original code scored below neutral, particularly in\nreadability and maintainability, underscoring the benefits of automated\nrefactoring guided by quality prompts. While traditional metrics like CC and\nLOC provide useful signals, they often diverge from human judgments,\nemphasizing the need for human-in-the-loop evaluation. Our open-source\nbenchmark offers a foundation for future research on automated refactoring with\nLLMs.", "AI": {"tldr": "This paper evaluates five open-source LLMs for automating Python code refactoring via the Extract Method. Recursive Criticism and Improvement (RCI) prompting leads to better functional correctness and code quality than one-shot prompting, with results validated by developer surveys and automated benchmarks. The study demonstrates the potential of LLMs for EMR, highlights gaps in automated metrics versus human judgment, and provides an open source benchmark for future research.", "motivation": "Extract Method Refactoring (EMR) is essential for improving code readability and maintainability, but current automation solutions are weak and mainly manual. The emergence of resource-efficient LLMs provides a new opportunity to automate such complex code refactoring tasks.", "method": "The authors systematically evaluate five open-source LLMs (3B-8B parameters) on their ability to perform EMR on Python code, assessing functional correctness and code quality through automated metrics. They compare one-shot prompting with a Recursive Criticism and Improvement (RCI) prompting strategy.", "result": "RCI-based prompting consistently outperforms one-shot prompting, with best-performing models (Deepseek-Coder-RCI and Qwen2.5-Coder-RCI) achieving high test pass percentages (0.829 and 0.808), and significantly improving lines of code (LOC) and cyclomatic complexity (CC). RCI-generated refactorings were accepted by developers over 70% of the time, with Qwen2.5-Coder rated highest overall. Traditional metrics diverge from human judgment, showing need for human-in-the-loop evaluation.", "conclusion": "Automating EMR using advanced prompting strategies with open-source LLMs is feasible and leads to substantial improvements in code quality, readability, and maintainability compared to manual or traditional approaches. Human feedback remains crucial for robust evaluation of automated refactorings."}}
{"id": "2510.26516", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26516", "abs": "https://arxiv.org/abs/2510.26516", "authors": ["Truong Hai Dang", "Jingyu Xiao", "Yintong Huo"], "title": "Envisioning Future Interactive Web Development: Editing Webpage with Natural Language", "comment": "accepted by AIWare'25", "summary": "The evolution of web applications relies on iterative code modifications, a\nprocess that is traditionally manual and time-consuming. While Large Language\nModels (LLMs) can generate UI code, their ability to edit existing code from\nnew design requirements (e.g., \"center the logo\") remains a challenge. This is\nlargely due to the absence of large-scale, high-quality tuning data to align\nmodel performance with human expectations. In this paper, we introduce a novel,\nautomated data generation pipeline that uses LLMs to synthesize a high-quality\nfine-tuning dataset for web editing, named Instruct4Edit. Our approach\ngenerates diverse instructions, applies the corresponding code modifications,\nand performs visual verification to ensure correctness. By fine-tuning models\non Instruct4Edit, we demonstrate consistent improvement in translating human\nintent into precise, structurally coherent, and visually accurate code changes.\nThis work provides a scalable and transparent foundation for natural language\nbased web editing, demonstrating that fine-tuning smaller open-source models\ncan achieve competitive performance with proprietary systems. We release all\ndata, code implementations, and model checkpoints for reproduction.", "AI": {"tldr": "This paper introduces Instruct4Edit, an automated pipeline that uses LLMs to create high-quality datasets for web code editing tasks, enabling smaller open-source models to match commercial systems in turning natural language instructions into accurate code edits. All data and code are released for the community.", "motivation": "The motivation is to streamline and automate the process of editing web application code based on new design requirements, which is traditionally manual, slow, and challenging for current Large Language Models (LLMs) due to a lack of high-quality, task-specific training data.", "method": "The paper introduces an automated pipeline (Instruct4Edit) that uses LLMs to create a fine-tuning dataset for web code editing tasks. This involves generating diverse editing instructions, applying corresponding code changes, and visually verifying the results. The pipeline aims to produce high-quality, diverse data for fine-tuning LLMs.", "result": "Fine-tuning smaller open-source models on the Instruct4Edit dataset consistently improved their ability to make structurally and visually accurate code edits from human instructions. These tuned models achieve performance levels competitive with commercial/proprietary systems.", "conclusion": "The study demonstrates that automated, LLM-driven data generation pipelines can create effective datasets for instruction-based code editing. As a result, smaller, open-source models can be efficiently trained to perform web code editing based on natural language instructions, rivaling commercial solutions. All resources are made publicly available, supporting transparency and reproducibility."}}
{"id": "2510.26538", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26538", "abs": "https://arxiv.org/abs/2510.26538", "authors": ["David Williams", "Max Hort", "Maria Kechagia", "Aldeida Aleti", "Justyna Petke", "Federica Sarro"], "title": "Reflecting on Empirical and Sustainability Aspects of Software Engineering Research in the Era of Large Language Models", "comment": "5 pages", "summary": "Software Engineering (SE) research involving the use of Large Language Models\n(LLMs) has introduced several new challenges related to rigour in benchmarking,\ncontamination, replicability, and sustainability. In this paper, we invite the\nresearch community to reflect on how these challenges are addressed in SE. Our\nresults provide a structured overview of current LLM-based SE research at ICSE,\nhighlighting both encouraging practices and persistent shortcomings. We\nconclude with recommendations to strengthen benchmarking rigour, improve\nreplicability, and address the financial and environmental costs of LLM-based\nSE.", "AI": {"tldr": "This paper reviews SE research using LLMs at ICSE, identifies current challenges in benchmarking, replicability, and sustainability, and offers recommendations for improvement.", "motivation": "LLMs in Software Engineering bring new challenges, particularly around rigorous benchmarking, contamination, replicability, and sustainability. The paper aims to raise awareness and address these emerging issues.", "method": "The authors review and analyze current LLM-based Software Engineering research presented at the ICSE conference. They systematically discuss practices and shortcomings.", "result": "The paper identifies both good practices and ongoing problems in how the SE community handles benchmarking, replicability, and costs of LLM-based research.", "conclusion": "Authors recommend steps to improve benchmarking rigor, replicability, and tackle financial and environmental impacts in LLM-based Software Engineering research."}}
{"id": "2510.26576", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26576", "abs": "https://arxiv.org/abs/2510.26576", "authors": ["Filippo Scaramuzza", "Renato Cordeiro Ferreira", "Tomaz Maia Suller", "Giovanni Quattrocchi", "Damian Andrew Tamburri", "Willem-Jan van den Heuvel"], "title": "\"Show Me You Comply... Without Showing Me Anything\": Zero-Knowledge Software Auditing for AI-Enabled Systems", "comment": "This work has been submitted to the ACM Transactions on Software\n  Engineering and Methodology for possible publication", "summary": "The increasing exploitation of Artificial Intelligence (AI) enabled systems\nin critical domains has made trustworthiness concerns a paramount showstopper,\nrequiring verifiable accountability, often by regulation (e.g., the EU AI Act).\nClassical software verification and validation techniques, such as procedural\naudits, formal methods, or model documentation, are the mechanisms used to\nachieve this. However, these methods are either expensive or heavily manual and\nill-suited for the opaque, \"black box\" nature of most AI models. An intractable\nconflict emerges: high auditability and verifiability are required by law, but\nsuch transparency conflicts with the need to protect assets being audited-e.g.,\nconfidential data and proprietary models-leading to weakened accountability. To\naddress this challenge, this paper introduces ZKMLOps, a novel MLOps\nverification framework that operationalizes Zero-Knowledge Proofs\n(ZKPs)-cryptographic protocols allowing a prover to convince a verifier that a\nstatement is true without revealing additional information-within\nMachine-Learning Operations lifecycles. By integrating ZKPs with established\nsoftware engineering patterns, ZKMLOps provides a modular and repeatable\nprocess for generating verifiable cryptographic proof of compliance. We\nevaluate the framework's practicality through a study of regulatory compliance\nin financial risk auditing and assess feasibility through an empirical\nevaluation of top ZKP protocols, analyzing performance trade-offs for ML models\nof increasing complexity.", "AI": {"tldr": "Traditional AI verification methods struggle with auditability versus privacy. This paper proposes ZKMLOps, a framework using Zero-Knowledge Proofs to enable verifiable, cryptographic compliance for AI systems, demonstrated through financial regulatory case studies and empirical performance analysis.", "motivation": "AI systems are increasingly used in critical fields, but ensuring their trustworthiness, transparency, and regulatory compliance (like with the EU AI Act) is extremely challenging due to the opaque nature of modern AI methods. Traditional verification approaches are often inadequate, costly, or impractical for AI's 'black box' models.", "method": "The paper introduces ZKMLOps, a framework that integrates Zero-Knowledge Proofs (ZKPs)\u2014cryptographic tools that can validate a statement's truth without revealing the underlying data\u2014into the machine learning operations lifecycle. The approach combines these cryptographic proofs with established software engineering practices to provide verifiable, modular, and repeatable compliance evidence.", "result": "The authors evaluate ZKMLOps by applying it to financial risk auditing regulatory compliance scenarios and empirically study the performance and feasibility of top ZKP protocols with machine learning models of varying complexity, discussing the trade-offs between privacy and auditability.", "conclusion": "ZKMLOps offers a practical way to bridge the gap between high auditability demands and asset protection, making regulatory compliance more feasible for AI systems without exposing confidential data or proprietary models."}}
{"id": "2510.26579", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26579", "abs": "https://arxiv.org/abs/2510.26579", "authors": ["Nathanael Nussbaumer", "Markus B\u00f6ck", "J\u00fcrgen Cito"], "title": "Online and Interactive Bayesian Inference Debugging", "comment": "Accepted by ICSE 2026", "summary": "Probabilistic programming is a rapidly developing programming paradigm which\nenables the formulation of Bayesian models as programs and the automation of\nposterior inference. It facilitates the development of models and conducting\nBayesian inference, which makes these techniques available to practitioners\nfrom multiple fields. Nevertheless, probabilistic programming is notoriously\ndifficult as identifying and repairing issues with inference requires a lot of\ntime and deep knowledge. Through this work, we introduce a novel approach to\ndebugging Bayesian inference that reduces time and required knowledge\nsignificantly. We discuss several requirements a Bayesian inference debugging\nframework has to fulfill, and propose a new tool that meets these key\nrequirements directly within the development environment. We evaluate our\nresults in a study with 18 experienced participants and show that our approach\nto online and interactive debugging of Bayesian inference significantly reduces\ntime and difficulty on inference debugging tasks.", "AI": {"tldr": "Probabilistic programming makes Bayesian inference accessible but hard to debug. This paper presents a new, developer-friendly tool for interactive, online debugging that was empirically shown to save time and effort, making debugging easier.", "motivation": "Probabilistic programming is powerful for expressing Bayesian models and automating inference, but debugging inference is difficult and time-consuming, requiring significant expertise.", "method": "The paper introduces a novel debugging approach for Bayesian inference, outlines essential requirements for such frameworks, and presents a new tool integrated into the development environment. This is evaluated through a user study with 18 experienced participants.", "result": "The proposed online and interactive debugging tool significantly reduces both the time and difficulty required for inference debugging tasks.", "conclusion": "An integrated debugging tool for Bayesian inference in probabilistic programming helps practitioners debug more efficiently and with less domain knowledge."}}
{"id": "2510.26634", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26634", "abs": "https://arxiv.org/abs/2510.26634", "authors": ["Yuan Si", "Kyle Qi", "Daming Li", "Hanyuan Shi", "Jialu Zhang"], "title": "Stitch: Step-by-step LLM Guided Tutoring for Scratch", "comment": null, "summary": "Block-based environments such as Scratch are increasingly popular in\nprogramming education. While block syntax reduces surface errors, semantic bugs\nremain common and challenging for novices to resolve. Existing debugging\nworkflows typically show the correct program directly to learners, a strategy\nthat may fix errors but undermines the development of problem-solving skills.\n  We present Stitch, an interactive tutoring system that replaces \"showing the\nanswer\" with step-by-step scaffolding. The system's Diff-Analyze module\ncontrasts a student's project with a reference implementation, identifies the\nmost critical differences, and uses a large language model to explain why these\nchanges matter. Learners inspect highlighted blocks through a custom rendering\nengine, understand the explanations, and selectively apply partial fixes. This\niterative process continues until the intended functionality is achieved.\n  We evaluate Stitch in an empirical study, comparing it against a\nstate-of-the-art automated feedback generation tool for Scratch. Our key\ninsight is that simply presenting the correct program is pedagogically\nineffective. In contrast, our interactive, step-by-step guided system promotes\na more effective learning experience. More broadly, what constitutes effective\nfeedback in block-based programming remains an open question. Our evaluation\nprovides new evidence that step-by-step tutoring significantly enhances\nlearning outcomes, outperforming both direct-answer approaches and current\nautomated feedback generation tools.", "AI": {"tldr": "This paper introduces Stitch, an interactive tutoring system for block-based programming like Scratch, which guides students through debugging projects with step-by-step scaffolding and explanations, rather than giving direct answers. Empirical results show this approach improves learning more than current automated feedback or direct-answer methods, highlighting the value of iterative, explanatory feedback for novice programmers.", "motivation": "Block-based programming environments like Scratch are widely used for teaching coding to beginners, but while blocks reduce surface syntax errors, novices still encounter challenging semantic bugs. Existing debugging tools typically show the correct answer directly, which can hinder the development of problem-solving skills.", "method": "The paper presents Stitch, an interactive tutoring system featuring a Diff-Analyze module that compares students\u2019 projects with reference solutions, highlights critical differences, and uses a large language model to explain their significance. Students iteratively inspect, understand, and selectively fix blocks based on step-by-step guidance, rather than simply being shown the correct program.", "result": "In an empirical study, Stitch was compared to a leading automated feedback tool for Scratch. The results demonstrated that step-by-step, interactive tutoring in Stitch led to significantly improved learning outcomes, surpassing both direct-answer approaches and existing automated feedback systems.", "conclusion": "Directly presenting correct answers in debugging workflows is pedagogically ineffective. Instead, iterative, guided feedback as implemented in Stitch supports stronger learning outcomes and skill development in block-based programming environments."}}
{"id": "2510.26676", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26676", "abs": "https://arxiv.org/abs/2510.26676", "authors": ["Samiha Shimmi", "Nicholas M. Synovic", "Mona Rahimi", "George K. Thiruvathukal"], "title": "Process-based Indicators of Vulnerability Re-Introducing Code Changes: An Exploratory Case Study", "comment": "9 pages, 6 figures; Samiha Shimmi and Nicholas M. Synovic contributed\n  equally to this work (co-first authors); Mona Rahimi and George K.\n  Thiruvathukal contributed equally to this work (co-supervisors)", "summary": "Software vulnerabilities often persist or re-emerge even after being fixed,\nrevealing the complex interplay between code evolution and socio-technical\nfactors. While source code metrics provide useful indicators of\nvulnerabilities, software engineering process metrics can uncover patterns that\nlead to their introduction. Yet few studies have explored whether process\nmetrics can reveal risky development activities over time -- insights that are\nessential for anticipating and mitigating software vulnerabilities. This work\nhighlights the critical role of process metrics along with code changes in\nunderstanding and mitigating vulnerability reintroduction. We move beyond\nfile-level prediction and instead analyze security fixes at the commit level,\nfocusing not only on whether a single fix introduces a vulnerability but also\non the longer sequences of changes through which vulnerabilities evolve and\nre-emerge. Our approach emphasizes that reintroduction is rarely the result of\none isolated action, but emerges from cumulative development activities and\nsocio-technical conditions. To support this analysis, we conducted a case study\non the ImageMagick project by correlating longitudinal process metrics such as\nbus factor, issue density, and issue spoilage with vulnerability reintroduction\nactivities, encompassing 76 instances of reintroduced vulnerabilities. Our\nfindings show that reintroductions often align with increased issue spoilage\nand fluctuating issue density, reflecting short-term inefficiencies in issue\nmanagement and team responsiveness. These observations provide a foundation for\nbroader studies that combine process and code metrics to predict risky fixes\nand strengthen software security.", "AI": {"tldr": "Process metrics, such as issue management and team dynamics, play an essential role in understanding and predicting the recurrence of software vulnerabilities. By analyzing commit-level security fixes and longitudinal metrics in the ImageMagick project, the paper finds that vulnerability reintroductions stem from cumulative development activities and inefficiencies rather than isolated mistakes. This approach informs better strategies for anticipating and preventing risky software changes.", "motivation": "Software vulnerabilities continue to recur despite being previously fixed, due to a complex interplay of code changes and socio-technical factors. This motivates a deeper analysis of the development process, beyond just code metrics, to understand how vulnerabilities are reintroduced.", "method": "This work uses a commit-level analysis of security fixes, moving beyond the file-level, and correlates longitudinal process metrics (such as bus factor, issue density, and issue spoilage) with vulnerability reintroduction activities. A case study on the ImageMagick project is conducted, analyzing 76 instances of reintroduced vulnerabilities.", "result": "Reintroduced vulnerabilities are commonly associated with periods of increased issue spoilage and unstable issue density, indicating short-term inefficiencies in issue management and team responsiveness. Vulnerability reintroduction is shown to result from cumulative development activities and socio-technical conditions rather than isolated events.", "conclusion": "The study highlights the critical role of process metrics, in conjunction with code changes, for predicting and mitigating vulnerability reintroduction. The integration of process and code metrics lays the groundwork for broader predictive models to enhance software security."}}
{"id": "2510.26699", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26699", "abs": "https://arxiv.org/abs/2510.26699", "authors": ["Aylton Almeida", "Laerte Xavier", "Marco Tulio Valente"], "title": "Using Copilot Agent Mode to Automate Library Migration: A Quantitative Assessment", "comment": null, "summary": "Keeping software systems up to date is essential to avoid technical debt,\nsecurity vulnerabilities, and the rigidity typical of legacy systems. However,\nupdating libraries and frameworks remains a time consuming and error-prone\nprocess. Recent advances in Large Language Models (LLMs) and agentic coding\nsystems offer new opportunities for automating such maintenance tasks. In this\npaper, we evaluate the update of a well-known Python library, SQLAlchemy,\nacross a dataset of ten client applications. For this task, we use the Github's\nCopilot Agent Mode, an autonomous AI systema capable of planning and executing\nmulti-step migration workflows. To assess the effectiveness of the automated\nmigration, we also introduce Migration Coverage, a metric that quantifies the\nproportion of API usage points correctly migrated. The results of our study\nshow that the LLM agent was capable of migrating functionalities and API usages\nbetween SQLAlchemy versions (migration coverage: 100%, median), but failed to\nmaintain the application functionality, leading to a low test-pass rate\n(39.75%, median).", "AI": {"tldr": "Automated migration with LLM agents works well for code updates but doesn't reliably keep applications working as intended.", "motivation": "Software needs regular updating to prevent issues like technical debt, security problems, and inflexibility. Despite this necessity, updating code libraries is labor-intensive and prone to mistakes. Recent LLM and agent coding tech could automate these tasks, potentially saving time and reducing errors.", "method": "The authors evaluate the use of Github's Copilot Agent Mode, an autonomous AI agent, to migrate a well-known Python library (SQLAlchemy) across ten different client applications. Effectiveness is assessed using a new metric, Migration Coverage, which measures API usage points correctly migrated.", "result": "The AI agent achieved a high rate of code migration for API usages (100% migration coverage, median) but struggled to maintain overall application functionality, as shown by a low median test-pass rate of 39.75%.", "conclusion": "While LLM-based agents can automate library code migration effectively, maintaining application-level functionality remains a major challenge, limiting practical utility."}}
{"id": "2510.26793", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26793", "abs": "https://arxiv.org/abs/2510.26793", "authors": ["Nafid Enan", "Gias Uddin"], "title": "Optimized Log Parsing with Syntactic Modifications", "comment": null, "summary": "Logs provide valuable insights into system runtime and assist in software\ndevelopment and maintenance. Log parsing, which converts semi-structured log\ndata into structured log data, is often the first step in automated log\nanalysis. Given the wide range of log parsers utilizing diverse techniques, it\nis essential to evaluate them to understand their characteristics and\nperformance. In this paper, we conduct a comprehensive empirical study\ncomparing syntax- and semantic-based log parsers, as well as single-phase and\ntwo-phase parsing architectures. Our experiments reveal that semantic-based\nmethods perform better at identifying the correct templates and syntax-based\nlog parsers are 10 to 1,000 times more efficient and provide better grouping\naccuracy although they fall short in accurate template identification.\nMoreover, two-phase architecture consistently improves accuracy compared to\nsingle-phase architecture. Based on the findings of this study, we propose\nSynLog+, a template identification module that acts as the second phase in a\ntwo-phase log parsing architecture. SynLog+ improves the parsing accuracy of\nsyntax-based and semantic-based log parsers by 236\\% and 20\\% on average,\nrespectively, with virtually no additional runtime cost.", "AI": {"tldr": "This paper empirically compares log parsing techniques, showing semantic methods best at template identification, syntax methods vastly more efficient, and two-phase setups most accurate. Their new SynLog+ module significantly improves accuracy for both approaches with no added cost.", "motivation": "Logs are important for understanding the runtime behavior of systems and aid in software development and maintenance. Automated log analysis relies on effective log parsing, but existing methods vary greatly, making comparative evaluation necessary for optimal tool selection.", "method": "The authors conducted a comprehensive empirical study to compare different log parsing techniques: syntax-based vs. semantic-based, and single-phase vs. two-phase architectures. They measured the effectiveness and efficiency of each.", "result": "Semantic-based log parsers excel at correct template identification. Syntax-based parsers are 10\u20131,000 times faster and group logs more accurately but identify templates less accurately. Two-phase architectures consistently yield higher accuracy. SynLog+, a new template identification module, further improves parsing accuracy by 236% (syntax-based) and 20% (semantic-based) with no runtime penalty.", "conclusion": "Evaluating log parsers reveals trade-offs between template identification and grouping accuracy, and highlights the efficiency of syntax-based methods. Two-phase architectures are superior in accuracy, and the SynLog+ module dramatically boosts parsing performance without affecting runtime."}}
