<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 18]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [From Craft to Constitution: A Governance-First Paradigm for Principled Agent Engineering](https://arxiv.org/abs/2510.13857)
*Qiang Xu,Xiangyu Wen,Changran Xu,Zeju Li,Jianyuan Zhong*

Main category: cs.SE

TL;DR: LLMs empower autonomous agents, but existing engineering approaches lead to unreliable systems. This paper proposes the ArbiterOS architecture, emphasizing governance as the key to building robust, trustworthy AI agents.


<details>
  <summary>Details</summary>
Motivation: LLMs have enabled autonomous agents with complex capabilities, but current engineering practices fail to create robust and trustworthy systems for critical tasks.

Method: Proposal of a 'governance-first' paradigm and the formal architecture ArbiterOS to address agent brittleness and unpredictability.

Result: Introduction of ArbiterOS, a novel governance framework aimed at principled agent engineering for reliable deployment.

Conclusion: Resolving the mismatch between probabilistic AI and deterministic software design requires new paradigms like ArbiterOS for creating trustworthy agents.

Abstract: The advent of powerful Large Language Models (LLMs) has ushered in an ``Age
of the Agent,'' enabling autonomous systems to tackle complex goals. However,
the transition from prototype to production is hindered by a pervasive ``crisis
of craft,'' resulting in agents that are brittle, unpredictable, and ultimately
untrustworthy in mission-critical applications. This paper argues this crisis
stems from a fundamental paradigm mismatch -- attempting to command inherently
probabilistic processors with the deterministic mental models of traditional
software engineering. To solve this crisis, we introduce a governance-first
paradigm for principled agent engineering, embodied in a formal architecture we
call ArbiterOS.

</details>


### [2] [Benchmarking Correctness and Security in Multi-Turn Code Generation](https://arxiv.org/abs/2510.13859)
*Ruchit Rawal,Jeffrey Yang Fan Chiang,Chihao Shen,Jeffery Siyuan Tian,Aastha Mahajan,Tom Goldstein,Yizheng Chen*

Main category: cs.SE

TL;DR: Current benchmarks overlook the iterative, multi-turn nature of actual coding, leading to inflated assessments of LLM-assisted development. MT-Sec reveals that coding assistants have significantly reduced performance and security in realistic, multi-turn scenarios, emphasizing an urgent need for improved, context-aware evaluation methods.


<details>
  <summary>Details</summary>
Motivation: Current benchmarks for evaluating AI coding assistants largely focus on single-turn tasks, which fail to mirror the iterative nature of genuine software development and neglect multi-step interactions crucial for real-world coding.

Method: The authors introduce MT-Sec, a novel benchmark that systematically assesses both correctness and security in multi-turn coding scenarios using a synthetic data pipeline. This pipeline adapts single-turn tasks into multi-turn sequences, enabling more realistic evaluation without discarding established test suites. Furthermore, the study benchmarks 32 diverse models and assesses agent-scaffolding techniques in these scenarios.

Result: There is a consistent 20-27% decrease in 'correct and secure' outputs when moving from single-turn to multi-turn coding tasks, even for state-of-the-art models. Models also perform worse in multi-turn code-diff generation, a relevant real-world setting, with higher rates of incorrect and insecure outputs. Agent scaffoldings, although beneficial in single-turn code generation, are less effective in multi-turn scenarios.

Conclusion: Multi-turn, joint correctness and security evaluation is crucial, as current benchmarks and agent techniques do not sufficiently capture the challenges of real-world iterative coding workflows. The introduction of MT-Sec reveals notable shortcomings of AI coding assistants and points to a need for further benchmark development.

Abstract: AI coding assistants powered by large language models (LLMs) have transformed
software development, significantly boosting productivity. While existing
benchmarks evaluate the correctness and security of LLM-generated code, they
are typically limited to single-turn tasks that do not reflect the iterative
nature of real-world development. We introduce MT-Sec, the first benchmark to
systematically evaluate both correctness and security in multi-turn coding
scenarios. We construct this using a synthetic data pipeline that transforms
existing single-turn tasks into semantically aligned multi-turn interaction
sequences, allowing reuse of original test suites while modeling the complexity
of real-world coding processes. We evaluate 32 open- and closed-source models,
and three agent-scaffolding on MT-Sec and observe a consistent 20-27% drop in
"correct and secure" outputs from single-turn to multi-turn settings -- even
among state-of-the-art models. Beyond full-program generation, we also evaluate
models on multi-turn code-diff generation -- an unexplored yet practically
relevant setting -- and find that models perform worse here, with increased
rates of functionally incorrect and insecure outputs. Finally, we find that
while agent scaffoldings boost single-turn code generation performance, they
are not quite as effective in multi-turn evaluations. Together, these findings
highlight the need for benchmarks that jointly evaluate correctness and
security in multi-turn, real-world coding workflows.

</details>


### [3] [A11YN: aligning LLMs for accessible web UI code generation](https://arxiv.org/abs/2510.13914)
*Janghan Yoon,Jaegwan Cho,Junhyeok Kim,Jiwan Chung,Jaehyun Jeon,Youngjae Yu*

Main category: cs.SE

TL;DR: A11yn introduces a novel reward-based approach for training LLMs to generate web UIs that comply with accessibility standards (WCAG), achieves a 60% reduction in accessibility issues, and shows that LLMs can be systematically improved for accessibility without sacrificing UI quality.


<details>
  <summary>Details</summary>
Motivation: The motivation is to address the problem of large language models (LLMs) generating web interfaces that carry forward accessibility flaws found in their training data, making web UIs less inclusive for users with diverse needs.

Method: The paper introduces A11yn, a method that aligns code-generating LLMs to produce accessibility-compliant web UIs. This is done by optimizing a reward function that penalizes violations of the Web Content Accessibility Guidelines (WCAG), with penalties scaled according to the severity identified by an accessibility testing engine. The authors also create the UIReq-6.8K dataset for training, and the RealUIReq-300 benchmark for evaluation.

Result: A11yn significantly reduces the Inaccessibility Rate by 60% compared to the base model, while maintaining the semantic fidelity and visual quality of generated web UIs.

Conclusion: The study demonstrates that accessibility can be systematically optimized in LLMs, proving the feasibility of aligning code generation processes for increased web accessibility.

Abstract: Large language models (LLMs) have recently demonstrated strong capabilities
in generating functional and aesthetic web interfaces directly from
instructions. However, these models often replicate accessibility flaws from
their training data, resulting in interfaces that exclude users with diverse
needs and contexts. To address this gap, we introduce A11yn, the first method
that aligns code-generating LLMs to reliably produce accessibility-compliant
web UIs. A11yn optimizes a novel reward function that penalizes violations of
the Web Content Accessibility Guidelines (WCAG), with penalties scaled to the
severity of each violation as identified by an accessibility testing engine. To
support training, we construct UIReq-6.8K, a dataset of 6,800 diverse
instructions for web UI generation. For evaluation, we introduce RealUIReq-300,
a benchmark of 300 real-world web UI requests grounded and manually curated
from public web pages, spanning a broad range of use cases. Empirical results
show that A11yn significantly outperforms strong baselines, lowering the
Inaccessibility Rate by 60% over the base model while preserving semantic
fidelity and visual quality of generated UIs. These findings demonstrate that
accessibility can be systematically optimized within LLMs, showing the
feasibility of aligning code generation for accessibility.

</details>


### [4] [Signature in Code Backdoor Detection, how far are we?](https://arxiv.org/abs/2510.13992)
*Quoc Hung Le,Thanh Le-Cong,Bach Le,Bowen Xu*

Main category: cs.SE

TL;DR: Standard settings for Spectral Signature defenses are often inadequate for detecting backdoors in code models. This paper finds better configurations and introduces a new technique for evaluating defense effectiveness without retraining, improving LLM security in development environments.


<details>
  <summary>Details</summary>
Motivation: Large Language Models (LLMs), especially those used in software development, are vulnerable to backdoor attacks via adversarial manipulation of training data. Current detection methods, like Spectral Signature, are promising but may not perform optimally on code models, necessitating a closer evaluation.

Method: The paper systematically evaluates the effectiveness of Spectral Signature-based defenses against backdoor attacks in code models, examining various attack scenarios and defense configurations. The study also explores different settings of key Spectral Signature parameters to identify their impacts.

Result: The authors found that the commonly used configurations for Spectral Signature in code backdoor detection are often not optimal. By testing alternative settings, they identified a new proxy metric that more accurately estimates the defenseâ€™s performance without requiring model retraining.

Conclusion: Spectral Signature-based defenses require careful tuning for effective use in code model backdoor detection. The proposed proxy metric offers a practical improvement, enabling more accurate performance estimation and potentially more robust defenses.

Abstract: As Large Language Models (LLMs) become increasingly integrated into software
development workflows, they also become prime targets for adversarial attacks.
Among these, backdoor attacks are a significant threat, allowing attackers to
manipulate model outputs through hidden triggers embedded in training data.
Detecting such backdoors remains a challenge, and one promising approach is the
use of Spectral Signature defense methods that identify poisoned data by
analyzing feature representations through eigenvectors. While some prior works
have explored Spectral Signatures for backdoor detection in neural networks,
recent studies suggest that these methods may not be optimally effective for
code models. In this paper, we revisit the applicability of Spectral
Signature-based defenses in the context of backdoor attacks on code models. We
systematically evaluate their effectiveness under various attack scenarios and
defense configurations, analyzing their strengths and limitations. We found
that the widely used setting of Spectral Signature in code backdoor detection
is often suboptimal. Hence, we explored the impact of different settings of the
key factors. We discovered a new proxy metric that can more accurately estimate
the actual performance of Spectral Signature without model retraining after the
defense.

</details>


### [5] [One Bug, Hundreds Behind: LLMs for Large-Scale Bug Discovery](https://arxiv.org/abs/2510.14036)
*Qiushi Wu,Yue Xiao,Dhilung Kirat,Kevin Eykholt,Jiyong Jang,Douglas Lee Schales*

Main category: cs.SE

TL;DR: The paper presents BugStone, a system that uses LLVM and a Large Language Model to automatically detect recurring pattern bugs (RPBs) in programs, revealing thousands of previously unnoticed issues in the Linux kernel and demonstrating high precision and accuracy.


<details>
  <summary>Details</summary>
Motivation: Fixing bugs individually is laborious and incomplete, as similar vulnerabilities can persist elsewhere. Public bug reports may inadvertently reveal exploitable patterns to attackers. There is a need for scalable techniques to discover and address recurring bugs across large codebases.

Method: The method involves leveraging patched instances of bugs to extract recurring patterns, which are then used to scan codebases for similar vulnerabilities using BugStone, built on LLVM and a Large Language Model. Manual validation and dataset creation support empirical results.

Result: BugStone identified over 22,000 potential issues in the Linux kernel from 135 RPBs, with manual review confirming 246 of 400 sampled findings. A further dataset of 1,900+ bugs and 850 fixes was compiled, with BugStone achieving 92.2% precision and 79.1% pairwise accuracy.

Conclusion: BugStone successfully identifies RPBs at scale, significantly improving bug detection efficiency and potentially enhancing software security. Its combination of program analysis and LLM demonstrates strong results with high precision and accuracy.

Abstract: Fixing bugs in large programs is a challenging task that demands substantial
time and effort. Once a bug is found, it is reported to the project
maintainers, who work with the reporter to fix it and eventually close the
issue. However, across the program, there are often similar code segments,
which may also contain the bug, but were missed during discovery. Finding and
fixing each recurring bug instance individually is labor intensive. Even more
concerning, bug reports can inadvertently widen the attack surface as they
provide attackers with an exploitable pattern that may be unresolved in other
parts of the program.
  In this paper, we explore these Recurring Pattern Bugs (RPBs) that appear
repeatedly across various code segments of a program or even in different
programs, stemming from a same root cause, but are unresolved. Our
investigation reveals that RPBs are widespread and can significantly compromise
the security of software programs. This paper introduces BugStone, a program
analysis system empowered by LLVM and a Large Language Model (LLM). The key
observation is that many RPBs have one patched instance, which can be leveraged
to identify a consistent error pattern, such as a specific API misuse. By
examining the entire program for this pattern, it is possible to identify
similar sections of code that may be vulnerable. Starting with 135 unique RPBs,
BugStone identified more than 22K new potential issues in the Linux kernel.
Manual analysis of 400 of these findings confirmed that 246 were valid. We also
created a dataset from over 1.9K security bugs reported by 23 recent top-tier
conference works. We manually annotate the dataset, identify 80 recurring
patterns and 850 corresponding fixes. Even with a cost-efficient model choice,
BugStone achieved 92.2% precision and 79.1% pairwise accuracy on the dataset.

</details>


### [6] [Caruca: Effective and Efficient Specification Mining for Opaque Software Components](https://arxiv.org/abs/2510.14279)
*Evangelos Lamprou,Seong-Heon Jung,Mayank Keoliya,Lukas Lazarek,Konstantinos Kallas,Michael Greenberg,Nikos Vasilakis*

Main category: cs.SE

TL;DR: Caruca uses a language model and dynamic analysis to automatically generate formal specifications for command-line tools, replacing manual effort and supporting advanced systems with accurate specs for nearly all tested commands.


<details>
  <summary>Details</summary>
Motivation: Modern systems use powerful tools to improve software quality, but require partial specifications of command-line utilities. Manually creating these specifications is difficult, time-consuming, and prone to error, which limits the adoption and scalability of these advanced systems.

Method: The authors introduce Caruca, a system that automatically mines specifications for opaque commands. Caruca uses a large language model to translate user documentation into a structured syntax for command invocation. It then synthesizes and executes possible invocations in varied environments, monitoring system calls and filesystem access to infer command properties such as parallelizability and file dependencies. It exports these as formal specifications.

Result: Caruca was tested on 60 commands (GNU Coreutils, POSIX, and third-party), and successfully generated correct specifications for all but one command. These specifications were immediately usable by various systems and enabled complete automation of the formerly manual process.

Conclusion: Caruca automates and accelerates the generation of command specifications, previously a laborious manual step, and demonstrably improves the practicality of systems relying on these specifications by eliminating human effort and errors.

Abstract: A wealth of state-of-the-art systems demonstrate impressive improvements in
performance, security, and reliability on programs composed of opaque
components, such as Unix shell commands. To reason about commands, these
systems require partial specifications. However, creating such specifications
is a manual, laborious, and error-prone process, limiting the practicality of
these systems. This paper presents Caruca, a system for automatic specification
mining for opaque commands. To overcome the challenge of language diversity
across commands, Caruca first instruments a large language model to translate a
command's user-facing documentation into a structured invocation syntax. Using
this representation, Caruca explores the space of syntactically valid command
invocations and execution environments. Caruca concretely executes each
command-environment pair, interposing at the system-call and filesystem level
to extract key command properties such as parallelizability and filesystem pre-
and post-conditions. These properties can be exported in multiple specification
formats and are immediately usable by existing systems. Applying Caruca across
60 GNU Coreutils, POSIX, and third-party commands across several
specification-dependent systems shows that Caruca generates correct
specifications for all but one case, completely eliminating manual effort from
the process and currently powering the full specifications for a
state-of-the-art static analysis tool.

</details>


### [7] [David vs. Goliath: A comparative study of different-sized LLMs for code generation in the domain of automotive scenario generation](https://arxiv.org/abs/2510.14115)
*Philipp Bauerfeind,Amir Salarpour,David Fernandez,Pedram MohajerAnsari,Johannes Reschke,Mert D. PesÃ©*

Main category: cs.SE

TL;DR: The paper introduces NL2Scenic, a new dataset and framework for generating test scenarios for autonomous driving from natural language using LLMs. They benchmark 13 models, finding that some open-source, mid-size models are nearly as effective as proprietary leaders, especially with retrieval-augmented prompting. A new evaluation metric, EDIT-COMP, reliably proxies human judgment. The work advances standardized, reproducible, and practical evaluation for scenario programming in autonomous driving.


<details>
  <summary>Details</summary>
Motivation: Testing autonomous driving systems requires precise, reproducible scenario simulations. Existing methods for generating scenario code (in Scenic DSL for CARLA) from natural language using large language models are hampered by a lack of high-quality data, inconsistent metrics, and limited reproducibility.

Method: The authors introduce NL2Scenic, an open dataset with 146 NL/Scenic code pairs, a stratified test split, a retrieval-augmented prompting framework, and 14 prompt variants. They evaluate 13 large language models (both proprietary and open-source) using a range of text and execution metrics, and validate scoring against human expert judgments. They further propose EDIT-COMP, a new metric combining similarity and compilation success.

Result: GPT-4o achieved the best results overall, but the open-source Qwen2.5Coder-14B model reaches about 88% of the expert-level score when run locally. Retrieval-augmented prompting, especially Few-Shot with Example Retriever, consistently helps smaller models. Scaling up model size showed diminishing returns after a certain point. Qwen2.5Coder outperforms CodeLlama at similar sizes. The EDIT-SIM metric best aligns with human evaluation, and their new EDIT-COMP metric provides a reliable automated proxy.

Conclusion: NL2Scenic and the EDIT-COMP metric offer a standardized, reproducible basis for evaluating LLMs on Scenic code generation, and show that mid-size, open-source models are practical and cost-effective for programming autonomous driving scenarios.

Abstract: Scenario simulation is central to testing autonomous driving systems. Scenic,
a domain-specific language (DSL) for CARLA, enables precise and reproducible
scenarios, but NL-to-Scenic generation with large language models (LLMs)
suffers from scarce data, limited reproducibility, and inconsistent metrics. We
introduce NL2Scenic, an open dataset and framework with 146 NL/Scenic pairs, a
difficulty-stratified 30-case test split, an Example Retriever, and 14
prompting variants (ZS, FS, CoT, SP, MoT). We evaluate 13 models: four
proprietary (GPT-4o, GPT-5, Claude-Sonnet-4, Gemini-2.5-pro) and nine
open-source code models (Qwen2.5Coder 0.5B-32B; CodeLlama 7B/13B/34B), using
text metrics (BLEU, ChrF, EDIT-SIM, CrystalBLEU) and execution metrics
(compilation and generation), and compare them with an expert study (n=11).
EDIT-SIM correlates best with human judgments; we also propose EDIT-COMP (F1 of
EDIT-SIM and compilation) as a robust dataset-level proxy that improves ranking
fidelity. GPT-4o performs best overall, while Qwen2.5Coder-14B reaches about 88
percent of its expert score on local hardware. Retrieval-augmented prompting,
Few-Shot with Example Retriever (FSER), consistently boosts smaller models, and
scaling shows diminishing returns beyond mid-size, with Qwen2.5Coder
outperforming CodeLlama at comparable scales. NL2Scenic and EDIT-COMP offer a
standardized, reproducible basis for evaluating Scenic code generation and
indicate that mid-size open-source models are practical, cost-effective options
for autonomous-driving scenario programming.

</details>


### [8] [A Hybrid, Knowledge-Guided Evolutionary Framework for Personalized Compiler Auto-Tuning](https://arxiv.org/abs/2510.14292)
*Haolin Pan,Hongbin Zhang,Mingjie Xing,Yanjun Wu*

Main category: cs.SE

TL;DR: This paper introduces a novel framework that uses large-scale offline analysis and a knowledge-driven evolutionary algorithm to personalize compiler pass tuning. It outperforms traditional optimization flags, achieving an average 11% reduction in LLVM IR instructions over opt -Oz on seven datasets.


<details>
  <summary>Details</summary>
Motivation: Optimizing compiler pass sequences for individual programs can yield significant performance benefits, but the search for optimal sequences is an NP-hard problem. Traditional compiler flags such as -O3 and -Oz are generic and do not provide personalized optimizations.

Method: The authors proposed a Hybrid, Knowledge-Guided Evolutionary Framework. It uses an offline phase to build a comprehensive compilation knowledge base with: Pass Behavioral Vectors, Pass Groups (via clustering), a Synergy Pass Graph, and a library of Prototype Pass Sequences. In the online phase, a bespoke genetic algorithm uses this knowledge base, employing knowledge-infused genetic operators for semantically-aware recombination and targeted mutations.

Result: On seven public datasets, their framework achieves 11.0% additional LLVM IR instruction reduction on average compared to the opt -Oz baseline, suggesting improved personalized, high-performance optimization sequences.

Conclusion: The proposed approach offers a state-of-the-art solution for personalized compiler optimization, surpassing traditional methods with a significant improvement in instruction reduction, thanks to its knowledge-guided, hybrid evolutionary process.

Abstract: Compiler pass auto-tuning is critical for enhancing software performance, yet
finding the optimal pass sequence for a specific program is an NP-hard problem.
Traditional, general-purpose optimization flags like -O3 and -Oz adopt a
one-size-fits-all approach, often failing to unlock a program's full
performance potential. To address this challenge, we propose a novel Hybrid,
Knowledge-Guided Evolutionary Framework. This framework intelligently guides
online, personalized optimization using knowledge extracted from a large-scale
offline analysis phase. During the offline stage, we construct a comprehensive
compilation knowledge base composed of four key components: (1) Pass Behavioral
Vectors to quantitatively capture the effectiveness of each optimization; (2)
Pass Groups derived from clustering these vectors based on behavior similarity;
(3) a Synergy Pass Graph to model beneficial sequential interactions; and (4) a
library of Prototype Pass Sequences evolved for distinct program types. In the
online stage, a bespoke genetic algorithm leverages this rich knowledge base
through specially designed, knowledge-infused genetic operators. These
operators transform the search by performing semantically-aware recombination
and targeted, restorative mutations. On a suite of seven public datasets, our
framework achieves an average of 11.0% additional LLVM IR instruction reduction
over the highly-optimized opt -Oz baseline, demonstrating its state-of-the-art
capability in discovering personalized, high-performance optimization
sequences.

</details>


### [9] [A Systematic Study of Time Limit Exceeded Errors in Online Programming Assignments](https://arxiv.org/abs/2510.14339)
*Jialu Zhang,Jialiang Gu,Wangmeiyu Zhang,JosÃ© Pablo Cambronero,John Kolesar,Ruzica Piskac,Daming Li,Hanyuan Shi*

Main category: cs.SE

TL;DR: TLE errors on platforms like Codeforces/LeetCode stem from various code issues, not just algorithm efficiency. This paper analyzes real TLE cases and introduces Nettle, an automated tool that fixes almost all TLEs using LLMs and smart feedback. Nettle outperforms alternatives and reliably resolves TLEs, improving programming practice.


<details>
  <summary>Details</summary>
Motivation: Millions of users on online programming platforms suffer from Time Limit Exceeded (TLE) errors, which are hard to diagnose and resolve due to vague error messages and limited support tools.

Method: The authors manually analyzed 1000 Codeforces submissions with TLE errors to classify root causes and user repair strategies. They then created Nettleâ€”an automated repair tool using LLMs and compiler-generated feedback, along with Nettle-Eval, a dedicated evaluation framework.

Result: TLE errors arise from various causes beyond inefficient algorithms, such as infinite loops, poor data structures, and bad I/O handling. The Nettle tool fixes TLEs in 98.5% of cases, outperforming current LLM solutions; all fixes pass rigorous functional checks.

Conclusion: TLE errors are more nuanced than previously thought, with multiple root causes. The Nettle tool and Nettle-Eval framework offer effective, reliable automated repair for TLE errors, significantly improving user outcomes on programming platforms.

Abstract: Online programming platforms such as Codeforces and LeetCode attract millions
of users seeking to learn to program or refine their skills for industry
interviews. A major challenge for these users is the Time Limit Exceeded (TLE)
error, triggered when a program exceeds the execution time bound. Although
designed as a performance safeguard, TLE errors are difficult to resolve: error
messages provide no diagnostic insight, platform support is minimal, and
existing debugging tools offer little help. As a result, many users abandon
their submissions after repeated TLE failures.
  This paper presents the first large-scale empirical study of TLE errors in
online programming. We manually analyzed 1000 Codeforces submissions with TLE
errors, classified their root causes, and traced how users attempted to fix
them. Our analysis shows that TLE errors often arise not only from inefficient
algorithms but also from infinite loops, improper data structure use, and
inefficient I/O, challenging the conventional view that TLEs are purely
performance issues.
  Guided by these findings, we introduce Nettle, the first automated repair
tool specifically designed for TLE errors, and Nettle-Eval, the first framework
for evaluating TLE repairs. Integrating LLMs with targeted automated feedback
generated by the compiler and test cases, Nettle produces small, correct code
edits that eliminate TLEs while preserving functionality. Evaluated on the same
1000 real-world cases, Nettle achieves a 98.5% fix rate, far exceeding the
strongest LLM baseline, and all of its repairs pass both Nettle-Eval and the
platform's official checker, confirming the reliability of our framework.

</details>


### [10] [PathFix: Automated Program Repair with Expected Path](https://arxiv.org/abs/2510.14341)
*Xu He,Shu Wang,Kun Sun*

Main category: cs.SE

TL;DR: PathFix is a new automated program repair method that uses path-sensitive constraints and a large language model, outperforming existing approaches, especially with complex code.


<details>
  <summary>Details</summary>
Motivation: Existing automated program repair (APR) techniques struggle due to the difficulty in generating precise specifications, resulting in too many plausible patches and overfitting on partial test cases.

Method: PathFix is proposed, which uses path-sensitive constraints from correct execution paths to generate program repair patches. The method involves tracing faulty paths, deriving expected paths using control flow analysis, generating/evaluating patches via constraint solving, validating patches, and integrating a large language model (LLM) to improve repair performance and scalability.

Result: Experimental results demonstrate that PathFix surpasses existing APR methods, especially for complex program structures like loops and recursion.

Conclusion: PathFix provides an effective solution for automated program repair by addressing candidate patch overgeneration and overfitting, aided by path-sensitive analysis and LLM integration.

Abstract: Automated program repair (APR) techniques are effective in fixing inevitable
defects in software, enhancing development efficiency and software robustness.
However, due to the difficulty of generating precise specifications, existing
APR methods face two main challenges: generating too many plausible patch
candidates and overfitting them to partial test cases. To tackle these
challenges, we introduce a new APR method named PathFix, which leverages
path-sensitive constraints extracted from correct execution paths to generate
patches for repairing buggy code. It is based on one observation: if a buggy
program is repairable, at least one expected path is supposed to replace the
fault path in the patched program. PathFix operates in four main steps. First,
it traces fault paths reaching the fault output in the buggy program. Second,
it derives expected paths by analyzing the desired correct output on the
control flow graph, where an expected path defines how a feasible patch leads
to the correct execution. Third, PathFix generates and evaluates patches by
solving state constraints along the expected path. Fourth, we validate the
correctness of the generated patch. To further enhance repair performance and
mitigate scalability issues introduced by path-sensitive analysis, we integrate
a large language model (LLM) into our framework. Experimental results show that
PathFix outperforms existing solutions, particularly in handling complex
program structures such as loops and recursion.

</details>


### [11] [Towards Automated Governance: A DSL for Human-Agent Collaboration in Software Projects](https://arxiv.org/abs/2510.14465)
*Adem Ait,Gwendal Jouneaux,Javier Luis CÃ¡novas Izquierdo,Jordi Cabot*

Main category: cs.SE

TL;DR: The paper proposes a new Domain-Specific Language to manage governance among diverse human and AI stakeholders in OSS projects, aiming for better collaboration and automated policy enforcement.


<details>
  <summary>Details</summary>
Motivation: The increasing diversity of stakeholders in software developmentâ€”including human contributors from various backgrounds and AI-powered agentsâ€”creates governance challenges, especially within open-source software (OSS) projects where policies are often missing or unclear.

Method: The paper introduces foundational concepts for a Domain-Specific Language (DSL) specifically designed to define and enforce governance policies in collaborative systems.

Result: The proposed DSL enables more robust, adaptable, and potentially automated governance mechanisms, facilitating effective collaboration among varied stakeholders including AI agents in OSS projects.

Conclusion: By leveraging a tailored DSL, software projects can achieve clearer and more effective governance, addressing the complexities brought by stakeholders' diversity and the inclusion of AI agents.

Abstract: The stakeholders involved in software development are becoming increasingly
diverse, with both human contributors from varied backgrounds and AI-powered
agents collaborating together in the process. This situation presents unique
governance challenges, particularly in Open-Source Software (OSS) projects,
where explicit policies are often lacking or unclear. This paper presents the
vision and foundational concepts for a novel Domain-Specific Language (DSL)
designed to define and enforce rich governance policies in systems involving
diverse stakeholders, including agents. This DSL offers a pathway towards more
robust, adaptable, and ultimately automated governance, paving the way for more
effective collaboration in software projects, especially OSS ones.

</details>


### [12] [E2Edev: Benchmarking Large Language Models in End-to-End Software Development Task](https://arxiv.org/abs/2510.14509)
*Jingyao Liu,Chen Huang,Zhizhao Guan,Wenqiang Lei,Yang Deng*

Main category: cs.SE

TL;DR: E2EDev is a new benchmark with automated testing and reduced annotation for end-to-end software development. Existing frameworks and LLMs still struggle, showing the need for improved solutions.


<details>
  <summary>Details</summary>
Motivation: The motivation is to improve the effectiveness and efficiency of End-to-End Software Development (E2ESD) solutions, especially by reducing manual annotation effort while maintaining high quality.

Method: The authors introduce E2EDev, which includes detailed user requirements, multiple Behavior-Driven Development (BDD) test scenarios with Python implementations, and an automated testing pipeline using the Behave framework. Additionally, a novel Human-in-the-Loop Multi-Agent Annotation Framework (HITL-MAA) is leveraged to enhance quality and reduce annotation workload.

Result: Analysis of various E2ESD frameworks and Large Language Model (LLM) backbones on E2EDev shows them struggling to solve these tasks effectively. This highlights the need for better, more cost-effective solutions.

Conclusion: Current state-of-the-art E2ESD and LLM frameworks are insufficient for fully addressing end-to-end software development tasks, emphasizing a pressing demand for more advanced approaches.

Abstract: E2EDev comprises (i) a fine-grained set of user requirements, (ii) {multiple
BDD test scenarios with corresponding Python step implementations for each
requirement}, and (iii) a fully automated testing pipeline built on the Behave
framework. To ensure its quality while reducing the annotation effort, E2EDev
leverages our proposed Human-in-the-Loop Multi-Agent Annotation Framework
(HITL-MAA). {By evaluating various E2ESD frameworks and LLM backbones with
E2EDev}, our analysis reveals a persistent struggle to effectively solve these
tasks, underscoring the critical need for more effective and cost-efficient
E2ESD solutions. Our codebase and benchmark are publicly available at
https://github.com/SCUNLP/E2EDev.

</details>


### [13] [Software Testing Education and Industry Needs - Report from the ENACTEST EU Project](https://arxiv.org/abs/2510.14625)
*Mehrdad Saadatmand,Abbas Khan,Beatriz Marin,Ana C. R Paiva,Nele Van Asch,Graham Moran,Felix Cammaerts,Monique Snoeck,Alexandra Mendes*

Main category: cs.SE

TL;DR: This paper explores the mismatch between current software testing educational offerings and what industry requires, identifying major gaps, especially in AI testing, security, and soft skills. Through focus groups, interviews, and a review, it calls for better alignment and modernized training.


<details>
  <summary>Details</summary>
Motivation: The motivation of the paper is to address the rapidly changing landscape of software development, which necessitates that software testers constantly update their skills and knowledge. There is a need to identify the current competency requirements in the industry and understand the disconnects between what is taught in education and what is needed in practice.

Method: The study uses two key qualitative research methods: focus group sessions and interviews with professionals from several industries (railway, healthcare, software consulting). Additionally, the authors conducted a curated small-scale scoping review. The study instrument was collaboratively designed and iteratively refined with industry and academic partners to ensure relevance. Thematic qualitative analysis was used for data analysis.

Result: The study identified significant knowledge gaps between academic software testing education and industry needs. Specific gaps were noted in areas like AI testing, security testing, and soft skills. The research also offers insights into current professional training methods, challenges in training delivery, various ways of evaluating training quality, as well as methods for transferring knowledge within companies.

Conclusion: There are crucial gaps between academic software testing education and the competencies required in industry, particularly in AI testing, security testing, and soft skills. Ongoing collaboration between industry and academia is necessary to ensure that educational programs remain relevant. The findings underline the importance of evolving training methods, evaluation practices, and effective knowledge transfer to keep up with industry demands.

Abstract: The evolving landscape of software development demands that software testers
continuously adapt to new tools, practices, and acquire new skills. This study
investigates software testing competency needs in industry, identifies
knowledge gaps in current testing education, and highlights competencies and
gaps not addressed in academic literature. This is done by conducting two focus
group sessions and interviews with professionals across diverse domains,
including railway industry, healthcare, and software consulting and performing
a curated small-scale scoping review. The study instrument, co-designed by
members of the ENACTEST project consortium, was developed collaboratively and
refined through multiple iterations to ensure comprehensive coverage of
industry needs and educational gaps. In particular, by performing a thematic
qualitative analysis, we report our findings and observations regarding:
professional training methods, challenges in offering training in industry,
different ways of evaluating the quality of training, identified knowledge gaps
with respect to academic education and industry needs, future needs and trends
in testing education, and knowledge transfer methods within companies. Finally,
the scoping review results confirm knowledge gaps in areas such as AI testing,
security testing and soft skills.

</details>


### [14] [ATGen: Adversarial Reinforcement Learning for Test Case Generation](https://arxiv.org/abs/2510.14635)
*Qingyao Li,Xinyi Dai,Weiwen Liu,Xiangyang Li,Yasheng Wang,Ruiming Tang,Yong Yu,Weinan Zhang*

Main category: cs.SE

TL;DR: ATGen uses adversarial RL to dynamically train test generators for LLM-generated code, outperforming existing methods and enhancing reliability by breaking through previous limitations of static datasets.


<details>
  <summary>Details</summary>
Motivation: Existing automatic test generation methods for LLM-generated code rely on static datasets, inherently limiting their ability to find new or complex bugs outside their training data. There is a need for a dynamic approach that can adapt and challenge LLMs beyond this fixed-difficulty ceiling.

Method: The paper introduces ATGen, a framework based on adversarial reinforcement learning. In ATGen, a test case generator is pitted against an adversarial code generator that tries to evade existing tests by generating harder bugs. The test generator is trained with reinforcement learning to both increase output accuracy and attack success, progressively learning to find more challenging bugs.

Result: Experiments show ATGen significantly outperforms state-of-the-art baselines in test case generation for code produced by LLMs. ATGen also proves valuable as an effective filter for Best-of-N inference and as a superior reward source for training code generation models.

Conclusion: ATGen provides a dynamic, adversarial curriculum for improving LLM code reliability, surpassing static training approaches and establishing a new paradigm for more effective test case generation for LLM-generated code.

Abstract: Large Language Models (LLMs) excel at code generation, yet their outputs
often contain subtle bugs, for which effective test cases are a critical
bottleneck. Existing test generation methods, whether based on prompting or
supervised fine-tuning, rely on static datasets. This imposes a
``fixed-difficulty ceiling'', fundamentally limiting their ability to uncover
novel or more complex bugs beyond their training scope. To overcome this, we
introduce ATGen, a framework that trains a test case generator via adversarial
reinforcement learning. ATGen pits a test generator against an adversarial code
generator that continuously crafts harder bugs to evade the current policy.
This dynamic loop creates a curriculum of increasing difficulty challenging
current policy. The test generator is optimized via Reinforcement Learning (RL)
to jointly maximize ``Output Accuracy'' and ``Attack Success'', enabling it to
learn a progressively stronger policy that breaks the fixed-difficulty ceiling
of static training. Extensive experiments demonstrate that ATGen significantly
outperforms state-of-the-art baselines. We further validate its practical
utility, showing it serves as both a more effective filter for Best-of-N
inference and a higher-quality reward source for training code generation
models. Our work establishes a new, dynamic paradigm for improving the
reliability of LLM-generated code.

</details>


### [15] [Requirement Identification for Traffic Simulations in Driving Simulators](https://arxiv.org/abs/2510.14653)
*Sven Tarlowski,Lutz Eckstein*

Main category: cs.SE

TL;DR: The paper introduces a systematic methodology to make traffic simulations more realistic and closely tied to study goals, improving both the quality of experimental results and the development process in automotive testing.


<details>
  <summary>Details</summary>
Motivation: There is a challenge in ensuring realistic traffic conditions for simulation studies, which impacts the validity and engagement of experiments in automotive development.

Method: The paper proposes a structured methodology that systematically identifies traffic simulation requirements by using sub-goals in each study phase. This allows derivation of specific technical needs for microscopic levels, agent models, and visual representation.

Result: The methodology maintains high fidelity in traffic simulations, which in turn enhances the validity of experimental outcomes and participant engagement.

Conclusion: The approach enables a clear link between study objectives and traffic simulation design, thus supporting robust automotive development and testing.

Abstract: This paper addresses the challenge of ensuring realistic traffic conditions
by proposing a methodology that systematically identifies traffic simulation
requirements. Using a structured approach based on sub-goals in each study
phase, specific technical needs are derived for microscopic levels, agent
models, and visual representation. The methodology aims to maintain a high
degree of fidelity, enhancing both the validity of experimental outcomes and
participant engagement. By providing a clear link between study objectives and
traffic simulation design, this approach supports robust automotive development
and testing.

</details>


### [16] [LLM Agents for Automated Web Vulnerability Reproduction: Are We There Yet?](https://arxiv.org/abs/2510.14700)
*Bin Liu,Yanjie Zhao,Guoai Xu,Haoyu Wang*

Main category: cs.SE

TL;DR: This paper comprehensively evaluates LLM agents for automated web vulnerability reproduction, finding they handle simple cases reasonably but struggle with complex, multi-component environments. Missing authentication and sophisticated setup lead to frequent failures, highlighting a big gap between current agent abilities and real-world needs.


<details>
  <summary>Details</summary>
Motivation: While LLM agents have shown promise in software engineering and security tasks, their effectiveness at turning vulnerability reports into working web exploitsâ€”a critical step in automating security researchâ€”remains underexplored and challenging. Addressing this knowledge gap is important for understanding and improving automated vulnerability reproduction.

Method: The paper systematically evaluates 20 state-of-the-art LLM agents across 16 dimensions (technical capability, adaptability, user experience, etc.) on 3 typical web vulnerabilities. The best 3 agents are then tested in-depth on 80 real-world CVEs covering 7 vulnerability types and 6 web technologies, assessing their practical abilities in realistic scenarios.

Result: LLM agents perform reasonably well in reproducing simple, library-based web vulnerabilities but consistently underperform on complex, service-based vulnerabilities that require advanced environmental setup and authentication steps. Performance is also significantly affected when input guidance, like authentication info, is incomplete, with over a 33% drop observed. Currently, agents can execute exploit code but often fail to fully trigger real vulnerabilities in complex scenarios.

Conclusion: There is a significant performance gap between the capabilities of current LLM agents and the requirements for thorough and reliable automated web vulnerability reproduction, especially in complex, real-world situations. Advances in environment adaptation and autonomous problem-solving are necessary to close this gap.

Abstract: Large language model (LLM) agents have demonstrated remarkable capabilities
in software engineering and cybersecurity tasks, including code generation,
vulnerability discovery, and automated testing. One critical but underexplored
application is automated web vulnerability reproduction, which transforms
vulnerability reports into working exploits. Although recent advances suggest
promising potential, challenges remain in applying LLM agents to real-world web
vulnerability reproduction scenarios. In this paper, we present the first
comprehensive evaluation of state-of-the-art LLM agents for automated web
vulnerability reproduction. We systematically assess 20 agents from software
engineering, cybersecurity, and general domains across 16 dimensions, including
technical capabilities, environment adaptability, and user experience factors,
on 3 representative web vulnerabilities. Based on the results, we select three
top-performing agents (OpenHands, SWE-agent, and CAI) for in-depth evaluation
on our benchmark dataset of 80 real-world CVEs spanning 7 vulnerability types
and 6 web technologies. Our results reveal that while LLM agents achieve
reasonable success on simple library-based vulnerabilities, they consistently
fail on complex service-based vulnerabilities requiring multi-component
environments. Complex environment configurations and authentication barriers
create a gap where agents can execute exploit code but fail to trigger actual
vulnerabilities. We observe high sensitivity to input guidance, with
performance degrading by over 33% under incomplete authentication information.
Our findings highlight the significant gap between current LLM agent
capabilities and the demands of reliable automated vulnerability reproduction,
emphasizing the need for advances in environmental adaptation and autonomous
problem-solving capabilities.

</details>


### [17] [Leveraging Code Cohesion Analysis to Identify Source Code Supply Chain Attacks](https://arxiv.org/abs/2510.14778)
*Maor Reuben,Ido Mendel,Or Feldman,Moshe Kravchik,Mordehai Guri,Rami Puzis*

Main category: cs.SE

TL;DR: This paper introduces an unsupervised metric that detects malicious code injections by highlighting disruptions in code cohesion and naming patterns, showing promising results on large open-source datasets despite attack rarity and data imbalance.


<details>
  <summary>Details</summary>
Motivation: Supply chain attacks via code injection are rare but highly damaging, and current automated tools struggle due to the complexity of interpreting injected code's intention and context.

Method: Unsupervised detection of spurious code injections based on quantifying cohesion disruptions using a name-prediction-based cohesion (NPC) metric.

Result: Analysis of over 54,000 functions in open-source C++ projects shows that code injection decreases cohesion and leads to shorter, less meaningful function names. The NPC metric effectively highlights injected code, achieving a Precision@100 of 36.41% (1:1,000 ratio) and 12.47% (1:10,000 ratio), even in highly imbalanced test sets.

Conclusion: Automated cohesion measures, especially name-prediction-based cohesion, provide a practical way to detect supply chain attacks and enhance software code integrity.

Abstract: Supply chain attacks significantly threaten software security with malicious
code injections within legitimate projects. Such attacks are very rare but may
have a devastating impact. Detecting spurious code injections using automated
tools is further complicated as it often requires deciphering the intention of
both the inserted code and its context. In this study, we propose an
unsupervised approach for highlighting spurious code injections by quantifying
cohesion disruptions in the source code. Using a name-prediction-based cohesion
(NPC) metric, we analyze how function cohesion changes when malicious code is
introduced compared to natural cohesion fluctuations. An analysis of 54,707
functions over 369 open-source C++ repositories reveals that code injection
reduces cohesion and shifts naming patterns toward shorter, less descriptive
names compared to genuine function updates. Considering the sporadic nature of
real supply-chain attacks, we evaluate the proposed method with extreme
test-set imbalance and show that monitoring high-cohesion functions with NPC
can effectively detect functions with injected code, achieving a Precision@100
of 36.41% at a 1:1,000 ratio and 12.47% at 1:10,000. These results suggest that
automated cohesion measurements, in general, and name-prediction-based
cohesion, in particular, may help identify supply chain attacks, improving
source code integrity.

</details>


### [18] [Instruction Set Migration at Warehouse Scale](https://arxiv.org/abs/2510.14928)
*Eric Christopher,Kevin Crossan,Wolff Dobson,Chris Kennelly,Drew Lewis,Kun Lin,Martin Maas,Parthasarathy Ranganathan,Emma Rapati,Brian Yang*

Main category: cs.SE

TL;DR: Migrating codebases between ISAs (e.g., x86 to Arm) is evolving beyond binary translation due to open-source tools allowing recompilation. A Google study on large-scale migration reveals new challenges, the usefulness of AI/automation, and unresolved issues needing future research.


<details>
  <summary>Details</summary>
Motivation: Codebase migration from one ISA (e.g., x86 to Arm) is a complex and pressing issue, especially with cloud providers increasingly adopting Arm in addition to x86. Despite its importance, academic research has mainly focused on binary translation and not on broader migration challenges.

Method: The authors analyze a large-scale migration from x86 to Arm at Google, examining around 40,000 code commits. They derive a taxonomy of migration tasks, investigate how automation and AI assist with the process, and identify remaining challenges.

Result: Google was able to automate many of the migration steps, with AI playing a significant role in handling tasks. The authors categorize tasks involved in ISA migration and point out which steps remain difficult, proposing areas for further research.

Conclusion: Modern ISA migration is no longer primarily about binary translation, thanks to open-source ecosystems and recompilation opportunities. However, it introduces diverse new challenges that require automation, AI, and ongoing research to fully address.

Abstract: Migrating codebases from one instruction set architecture (ISA) to another is
a major engineering challenge. A recent example is the adoption of Arm (in
addition to x86) across the major Cloud hyperscalers. Yet, this problem has
seen limited attention by the academic community. Most work has focused on
static and dynamic binary translation, and the traditional conventional wisdom
has been that this is the primary challenge.
  In this paper, we show that this is no longer the case. Modern ISA migrations
can often build on a robust open-source ecosystem, making it possible to
recompile all relevant software from scratch. This introduces a new and
multifaceted set of challenges, which are different from binary translation.
  By analyzing a large-scale migration from x86 to Arm at Google, spanning
almost 40,000 code commits, we derive a taxonomy of tasks involved in ISA
migration. We show how Google automated many of the steps involved, and
demonstrate how AI can play a major role in automatically addressing these
tasks. We identify tasks that remain challenging and highlight research
challenges that warrant further attention.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [19] [HITrees: Higher-Order Interaction Trees](https://arxiv.org/abs/2510.14558)
*Amir Mohammad Fadaei Ayyam,Michael Sammler*

Main category: cs.PL

TL;DR: HITrees extend interaction trees to support higher-order effects, enabling sophisticated semantic modeling (e.g., concurrency, call/cc) inside a non-guarded type theory and implemented in Lean. This increases the compositional power of formal verification tools.


<details>
  <summary>Details</summary>
Motivation: Compositional semantics are important for formally verifying complex systems, and interaction trees are popular in this domain due to their reuse and modularity. However, traditional interaction trees do not support higher-order effects (effects that yield or consume monadic computations), which are critical for modeling advanced features like parallelism and control flow (call/cc).

Method: The authors introduce 'Higher-Order Interaction Trees' (HITrees), a new type of interaction tree that supports higher-order effects within a non-guarded type theory. They achieve this through (1) designing effects such that higher-order input fixpoints can be inductive types, and (2) using defunctionalization to encode higher-order outputs as first-order representations. The HITree framework is implemented in the Lean proof assistant, including a comprehensive library of effects (e.g., concurrency, call/cc).

Result: The authors demonstrate two interpretations of HITrees: as state transition systems and as monadic programs. They show that HITrees can express the semantics of languages with features like parallel composition and call/cc, showcasing their greater expressiveness over previous approaches.

Conclusion: HITrees provide the first support for higher-order effects in interaction trees within non-guarded type theory, enabling formalization and verification of more complex system semantics. Their Lean implementation and comprehensive effect library further bolster the practical utility of the approach.

Abstract: Recent years have witnessed the rise of compositional semantics as a
foundation for formal verification of complex systems. In particular,
interaction trees have emerged as a popular denotational semantics. Interaction
trees achieve compositionality by providing a reusable library of effects.
However, their notion of effects does not support higher-order effects, i.e.,
effects that take or return monadic computations. Such effects are essential to
model complex semantic features like parallel composition and call/cc.
  We introduce Higher-Order Interaction Trees (HITrees), the first variant of
interaction trees to support higher-order effects in a non-guarded type theory.
HITrees accomplish this through two key techniques: first, by designing the
notion of effects such that the fixpoints of effects with higher-order input
can be expressed as inductive types inside the type theory; and second, using
defunctionalization to encode higher-order outputs into a first-order
representation. We implement HITrees in the Lean proof assistant, accompanied
by a comprehensive library of effects including concurrency, recursion, and
call/cc. Furthermore, we provide two interpretations of HITrees, as state
transition systems and as monadic programs. To demonstrate the expressiveness
of HITrees, we apply them to define the semantics of a language with parallel
composition and call/cc.

</details>
