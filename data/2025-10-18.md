<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 18]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Caruca: Effective and Efficient Specification Mining for Opaque Software Components](https://arxiv.org/abs/2510.14279)
*Evangelos Lamprou,Seong-Heon Jung,Mayank Keoliya,Lukas Lazarek,Konstantinos Kallas,Michael Greenberg,Nikos Vasilakis*

Main category: cs.SE

TL;DR: Manual specification creation for opaque system commands is a major bottleneck for advanced analysis tools. Caruca automates this process using large language models and dynamic execution, producing highly accurate specifications and significantly reducing manual effort.


<details>
  <summary>Details</summary>
Motivation: State-of-the-art systems can improve performance, security, and reliability for programs using opaque commands (like Unix shell commands), but they require partial specifications, which are hard and tedious to create manually.

Method: Caruca leverages a large language model to translate user documentation into a structured syntax. It systematically generates and executes command invocations in various environments, then monitors system calls and filesystem changes to extract command properties, automating specification mining.

Result: Caruca was applied to 60 different commands (including GNU Coreutils, POSIX, and third-party ones). It generated correct specifications for all but one case, fully automating specification extraction and supporting a state-of-the-art static analysis tool.

Conclusion: Caruca effectively eliminates manual specification mining for opaque commands by automatically generating usable specifications with high accuracy, enhancing the practicality of specification-dependent system tools.

Abstract: A wealth of state-of-the-art systems demonstrate impressive improvements in
performance, security, and reliability on programs composed of opaque
components, such as Unix shell commands. To reason about commands, these
systems require partial specifications. However, creating such specifications
is a manual, laborious, and error-prone process, limiting the practicality of
these systems. This paper presents Caruca, a system for automatic specification
mining for opaque commands. To overcome the challenge of language diversity
across commands, Caruca first instruments a large language model to translate a
command's user-facing documentation into a structured invocation syntax. Using
this representation, Caruca explores the space of syntactically valid command
invocations and execution environments. Caruca concretely executes each
command-environment pair, interposing at the system-call and filesystem level
to extract key command properties such as parallelizability and filesystem pre-
and post-conditions. These properties can be exported in multiple specification
formats and are immediately usable by existing systems. Applying Caruca across
60 GNU Coreutils, POSIX, and third-party commands across several
specification-dependent systems shows that Caruca generates correct
specifications for all but one case, completely eliminating manual effort from
the process and currently powering the full specifications for a
state-of-the-art static analysis tool.

</details>


### [2] [From Craft to Constitution: A Governance-First Paradigm for Principled Agent Engineering](https://arxiv.org/abs/2510.13857)
*Qiang Xu,Xiangyu Wen,Changran Xu,Zeju Li,Jianyuan Zhong*

Main category: cs.SE

TL;DR: Current LLM-based agents are unreliable due to a mismatch between how they work and how we try to control them. This paper proposes ArbiterOS, a new architecture focused on governance, to make these agents trustworthy and robust for critical use cases.


<details>
  <summary>Details</summary>
Motivation: The rapid advancement of Large Language Models (LLMs) enables autonomous agents to perform complex tasks, but their deployment is hampered by unreliable behavior, making them untrustworthy for critical applications.

Method: The authors argue that the main issue is a paradigm mismatch between the probabilistic nature of LLM agents and the deterministic approach of traditional software engineering. They propose a governance-first paradigm and introduce a formal architecture called ArbiterOS to address this problem.

Result: ArbiterOS is presented as a solution for principled agent engineering, aiming to improve reliability, predictability, and trustworthiness of LLM-based autonomous agents.

Conclusion: Transitioning to a governance-first paradigm, as exemplified by ArbiterOS, can resolve the craft crisis in LLM agents, enabling safer and more reliable deployment in mission-critical settings.

Abstract: The advent of powerful Large Language Models (LLMs) has ushered in an ``Age
of the Agent,'' enabling autonomous systems to tackle complex goals. However,
the transition from prototype to production is hindered by a pervasive ``crisis
of craft,'' resulting in agents that are brittle, unpredictable, and ultimately
untrustworthy in mission-critical applications. This paper argues this crisis
stems from a fundamental paradigm mismatch -- attempting to command inherently
probabilistic processors with the deterministic mental models of traditional
software engineering. To solve this crisis, we introduce a governance-first
paradigm for principled agent engineering, embodied in a formal architecture we
call ArbiterOS.

</details>


### [3] [Benchmarking Correctness and Security in Multi-Turn Code Generation](https://arxiv.org/abs/2510.13859)
*Ruchit Rawal,Jeffrey Yang Fan Chiang,Chihao Shen,Jeffery Siyuan Tian,Aastha Mahajan,Tom Goldstein,Yizheng Chen*

Main category: cs.SE

TL;DR: MT-Sec shows that popular AI coding assistants become significantly less correct and secure in multi-turn, realistic coding tasks, highlighting the limitations of current single-turn benchmarks and the need for better multi-turn evaluation methods.


<details>
  <summary>Details</summary>
Motivation: Existing benchmarks for evaluating LLM-generated code focus on single-turn tasks, which don't accurately reflect the iterative and multi-turn nature of real-world software development. There is a need for a systematic assessment of both correctness and security in multi-turn coding scenarios.

Method: The authors introduce MT-Sec, a benchmark designed to evaluate correctness and security of LLM-assisted coding in multi-turn scenarios. They created MT-Sec using a synthetic data pipeline that converts single-turn tasks into multi-turn sequences, while reusing original test suites. The benchmark is used to assess 32 models (open- and closed-source) and agent scaffoldings in both full-program and code-diff generation.

Result: Across all models, there was a consistent 20-27% drop in “correct and secure” outputs when moving from single-turn to multi-turn settings, including state-of-the-art options. In multi-turn code-diff generation, models performed even worse, producing more incorrect and insecure outputs. Agent scaffoldings help in single-turn cases, but are less effective in multi-turn scenarios.

Conclusion: Current LLM coding assistants suffer notable drops in both correctness and security in multi-turn coding scenarios, demonstrating that existing single-turn benchmarks underestimate real-world complexity. There is a pressing need for benchmarks like MT-Sec that reflect genuine coding workflows and assess both correctness and security over multiple interaction turns.

Abstract: AI coding assistants powered by large language models (LLMs) have transformed
software development, significantly boosting productivity. While existing
benchmarks evaluate the correctness and security of LLM-generated code, they
are typically limited to single-turn tasks that do not reflect the iterative
nature of real-world development. We introduce MT-Sec, the first benchmark to
systematically evaluate both correctness and security in multi-turn coding
scenarios. We construct this using a synthetic data pipeline that transforms
existing single-turn tasks into semantically aligned multi-turn interaction
sequences, allowing reuse of original test suites while modeling the complexity
of real-world coding processes. We evaluate 32 open- and closed-source models,
and three agent-scaffolding on MT-Sec and observe a consistent 20-27% drop in
"correct and secure" outputs from single-turn to multi-turn settings -- even
among state-of-the-art models. Beyond full-program generation, we also evaluate
models on multi-turn code-diff generation -- an unexplored yet practically
relevant setting -- and find that models perform worse here, with increased
rates of functionally incorrect and insecure outputs. Finally, we find that
while agent scaffoldings boost single-turn code generation performance, they
are not quite as effective in multi-turn evaluations. Together, these findings
highlight the need for benchmarks that jointly evaluate correctness and
security in multi-turn, real-world coding workflows.

</details>


### [4] [A11YN: aligning LLMs for accessible web UI code generation](https://arxiv.org/abs/2510.13914)
*Janghan Yoon,Jaegwan Cho,Junhyeok Kim,Jiwan Chung,Jaehyun Jeon,Youngjae Yu*

Main category: cs.SE

TL;DR: A11yn is a new method that helps large language models generate much more accessible web UIs by penalizing accessibility violations during training. It shows that big improvements in accessibility are possible without sacrificing utility or appearance.


<details>
  <summary>Details</summary>
Motivation: Large language models can generate web interfaces from text instructions but often reproduce accessibility problems, making their outputs less inclusive for users with varying needs. Addressing these persistent accessibility issues in generated UI code is crucial.

Method: The authors propose A11yn, a method that aligns code-generating LLMs to produce accessibility-compliant web UIs. A11yn uses an innovative reward function during training that penalizes code violating the Web Content Accessibility Guidelines, with penalties scaled by violation severity. The authors also build a new instruction dataset (UIReq-6.8K) and a real-world benchmarking set (RealUIReq-300) for training and evaluation.

Result: A11yn reduces the Inaccessibility Rate by 60% compared to the base LLM, while maintaining the intended meaning and appearance of the generated web UIs. The system significantly outperforms existing methods on accessibility compliance.

Conclusion: It is feasible to systematically optimize LLMs for accessibility in code generation. Methods like A11yn can align large language models to reliably produce accessible and high-quality web UIs.

Abstract: Large language models (LLMs) have recently demonstrated strong capabilities
in generating functional and aesthetic web interfaces directly from
instructions. However, these models often replicate accessibility flaws from
their training data, resulting in interfaces that exclude users with diverse
needs and contexts. To address this gap, we introduce A11yn, the first method
that aligns code-generating LLMs to reliably produce accessibility-compliant
web UIs. A11yn optimizes a novel reward function that penalizes violations of
the Web Content Accessibility Guidelines (WCAG), with penalties scaled to the
severity of each violation as identified by an accessibility testing engine. To
support training, we construct UIReq-6.8K, a dataset of 6,800 diverse
instructions for web UI generation. For evaluation, we introduce RealUIReq-300,
a benchmark of 300 real-world web UI requests grounded and manually curated
from public web pages, spanning a broad range of use cases. Empirical results
show that A11yn significantly outperforms strong baselines, lowering the
Inaccessibility Rate by 60% over the base model while preserving semantic
fidelity and visual quality of generated UIs. These findings demonstrate that
accessibility can be systematically optimized within LLMs, showing the
feasibility of aligning code generation for accessibility.

</details>


### [5] [Signature in Code Backdoor Detection, how far are we?](https://arxiv.org/abs/2510.13992)
*Quoc Hung Le,Thanh Le-Cong,Bach Le,Bowen Xu*

Main category: cs.SE

TL;DR: This paper reassesses the effectiveness of Spectral Signature defense methods in detecting backdoor attacks on Large Language Models, especially code-focused models, and introduces a new metric for evaluating their performance.


<details>
  <summary>Details</summary>
Motivation: Backdoor attacks in LLMs used for software development pose significant risks, and current defenses are inadequate—improving detection methods for code models is critical for security.

Method: Systematic evaluation of Spectral Signature defense effectiveness under diverse attack scenarios and defense configurations on code models; exploration of alternative parameter settings and identification of a proxy metric.

Result: Varied Spectral Signature settings substantially impact backdoor detection performance, and the proposed proxy metric enhances the evaluation accuracy without requiring model retraining.

Conclusion: The commonly used Spectral Signature settings for code model backdoor detection are often not optimal; adjusting key parameters and applying the proposed metric allows for more accurate detection without retraining.

Abstract: As Large Language Models (LLMs) become increasingly integrated into software
development workflows, they also become prime targets for adversarial attacks.
Among these, backdoor attacks are a significant threat, allowing attackers to
manipulate model outputs through hidden triggers embedded in training data.
Detecting such backdoors remains a challenge, and one promising approach is the
use of Spectral Signature defense methods that identify poisoned data by
analyzing feature representations through eigenvectors. While some prior works
have explored Spectral Signatures for backdoor detection in neural networks,
recent studies suggest that these methods may not be optimally effective for
code models. In this paper, we revisit the applicability of Spectral
Signature-based defenses in the context of backdoor attacks on code models. We
systematically evaluate their effectiveness under various attack scenarios and
defense configurations, analyzing their strengths and limitations. We found
that the widely used setting of Spectral Signature in code backdoor detection
is often suboptimal. Hence, we explored the impact of different settings of the
key factors. We discovered a new proxy metric that can more accurately estimate
the actual performance of Spectral Signature without model retraining after the
defense.

</details>


### [6] [One Bug, Hundreds Behind: LLMs for Large-Scale Bug Discovery](https://arxiv.org/abs/2510.14036)
*Qiushi Wu,Yue Xiao,Dhilung Kirat,Kevin Eykholt,Jiyong Jang,Douglas Lee Schales*

Main category: cs.SE

TL;DR: BugStone uses machine learning and program analysis to automatically find recurring bug patterns in large codebases, reliably discovering thousands of vulnerabilities that may otherwise go unnoticed.


<details>
  <summary>Details</summary>
Motivation: Fixing bugs in large programs is difficult and time-consuming, especially when similar unresolved bugs exist in other parts of the code. Reporting bugs can unintentionally reveal attack patterns to adversaries.

Method: The authors developed BugStone, a program analysis system using LLVM and a Large Language Model (LLM). BugStone detects Recurring Pattern Bugs (RPBs) by learning from patched instances to identify similar error patterns throughout a codebase.

Result: BugStone identified over 22,000 potential issues in the Linux kernel, of which manual analysis confirmed 246 valid cases out of 400 sampled. The authors also curated a dataset of 1.9K security bugs, manually annotated 80 recurring patterns, and 850 fixes. BugStone achieved 92.2% precision and 79.1% pairwise accuracy on this dataset.

Conclusion: Recurring Pattern Bugs are widespread and pose significant security risks. The BugStone system can efficiently detect these bugs, greatly improving the security and quality of large codebases.

Abstract: Fixing bugs in large programs is a challenging task that demands substantial
time and effort. Once a bug is found, it is reported to the project
maintainers, who work with the reporter to fix it and eventually close the
issue. However, across the program, there are often similar code segments,
which may also contain the bug, but were missed during discovery. Finding and
fixing each recurring bug instance individually is labor intensive. Even more
concerning, bug reports can inadvertently widen the attack surface as they
provide attackers with an exploitable pattern that may be unresolved in other
parts of the program.
  In this paper, we explore these Recurring Pattern Bugs (RPBs) that appear
repeatedly across various code segments of a program or even in different
programs, stemming from a same root cause, but are unresolved. Our
investigation reveals that RPBs are widespread and can significantly compromise
the security of software programs. This paper introduces BugStone, a program
analysis system empowered by LLVM and a Large Language Model (LLM). The key
observation is that many RPBs have one patched instance, which can be leveraged
to identify a consistent error pattern, such as a specific API misuse. By
examining the entire program for this pattern, it is possible to identify
similar sections of code that may be vulnerable. Starting with 135 unique RPBs,
BugStone identified more than 22K new potential issues in the Linux kernel.
Manual analysis of 400 of these findings confirmed that 246 were valid. We also
created a dataset from over 1.9K security bugs reported by 23 recent top-tier
conference works. We manually annotate the dataset, identify 80 recurring
patterns and 850 corresponding fixes. Even with a cost-efficient model choice,
BugStone achieved 92.2% precision and 79.1% pairwise accuracy on the dataset.

</details>


### [7] [David vs. Goliath: A comparative study of different-sized LLMs for code generation in the domain of automotive scenario generation](https://arxiv.org/abs/2510.14115)
*Philipp Bauerfeind,Amir Salarpour,David Fernandez,Pedram MohajerAnsari,Johannes Reschke,Mert D. Pesé*

Main category: cs.SE

TL;DR: This paper introduces NL2Scenic, a standardized dataset and evaluation framework for translating natural language (NL) descriptions into Scenic DSL code for autonomous driving simulations. It assesses multiple large language models (LLMs), both proprietary and open-source, using various evaluation metrics and finds that mid-sized open-source models can perform competitively and cost-effectively.


<details>
  <summary>Details</summary>
Motivation: Testing autonomous driving systems with simulated scenarios requires reproducible scenario generation from natural language descriptions. Current methods are hampered by limited data, inconsistency, and evaluation challenges, necessitating a standardized approach.

Method: The authors constructed a dataset of 146 NL/Scenic code pairs and a 30-case test set, introduced multiple prompting variants (zero-shot, few-shot, CoT, step-by-step, multi-objective), and evaluated model outputs using both text-based and execution-based metrics. Human expert judgments were collected for ground-truth comparison.

Result: GPT-4o achieved the highest performance, but Qwen2.5Coder-14B reached 88% of expert-level accuracy on local hardware. Retrieval-augmented prompting, especially FSER, improved the performance of smaller models. Scaling beyond mid-size yields diminishing returns. The EDIT-COMP metric correlates well with human judgment and enhances reliable model ranking.

Conclusion: NL2Scenic and the new EDIT-COMP metric provide reproducible, reliable benchmarks for NL-to-Scenic code generation. While proprietary models like GPT-4o lead in performance, mid-sized open-source models like Qwen2.5Coder-14B are practical alternatives. Retrieval-augmented prompting methods further boost smaller models, making scenario programming for autonomous driving more accessible.

Abstract: Scenario simulation is central to testing autonomous driving systems. Scenic,
a domain-specific language (DSL) for CARLA, enables precise and reproducible
scenarios, but NL-to-Scenic generation with large language models (LLMs)
suffers from scarce data, limited reproducibility, and inconsistent metrics. We
introduce NL2Scenic, an open dataset and framework with 146 NL/Scenic pairs, a
difficulty-stratified 30-case test split, an Example Retriever, and 14
prompting variants (ZS, FS, CoT, SP, MoT). We evaluate 13 models: four
proprietary (GPT-4o, GPT-5, Claude-Sonnet-4, Gemini-2.5-pro) and nine
open-source code models (Qwen2.5Coder 0.5B-32B; CodeLlama 7B/13B/34B), using
text metrics (BLEU, ChrF, EDIT-SIM, CrystalBLEU) and execution metrics
(compilation and generation), and compare them with an expert study (n=11).
EDIT-SIM correlates best with human judgments; we also propose EDIT-COMP (F1 of
EDIT-SIM and compilation) as a robust dataset-level proxy that improves ranking
fidelity. GPT-4o performs best overall, while Qwen2.5Coder-14B reaches about 88
percent of its expert score on local hardware. Retrieval-augmented prompting,
Few-Shot with Example Retriever (FSER), consistently boosts smaller models, and
scaling shows diminishing returns beyond mid-size, with Qwen2.5Coder
outperforming CodeLlama at comparable scales. NL2Scenic and EDIT-COMP offer a
standardized, reproducible basis for evaluating Scenic code generation and
indicate that mid-size open-source models are practical, cost-effective options
for autonomous-driving scenario programming.

</details>


### [8] [A Hybrid, Knowledge-Guided Evolutionary Framework for Personalized Compiler Auto-Tuning](https://arxiv.org/abs/2510.14292)
*Haolin Pan,Hongbin Zhang,Mingjie Xing,Yanjun Wu*

Main category: cs.SE

TL;DR: The study proposes a smarter compiler pass auto-tuning approach using offline knowledge and online genetic algorithms, delivering better-optimized programs than traditional methods.


<details>
  <summary>Details</summary>
Motivation: Standard compiler optimizations like -O3 and -Oz apply generalized settings that miss program-specific performance gains. The need to overcome the NP-hardness of finding optimal pass order motivates the use of a hybrid, knowledge-driven evolutionary approach for auto-tuning compiler passes.

Method: The method involves a two-stage approach: (1) offline analysis to build a knowledge base with behavioral vectors, pass groups, synergy graphs, and prototype sequences; and (2) online genetic search using operators informed by this knowledge to produce optimized pass sequences for new programs.

Result: The paper introduces a hybrid, knowledge-guided evolutionary framework for automatic tuning of compiler optimization passes. It achieves significant additional program reduction (11% on average in LLVM IR instructions) over standard optimization (opt -Oz), by leveraging a comprehensive compilation knowledge base and knowledge-infused genetic operators.

Conclusion: Using a hybrid framework that combines offline profiling (knowledge base creation) with online evolutionary search enables more effective, personalized optimization sequences, outperforming baseline compiler settings in various datasets.

Abstract: Compiler pass auto-tuning is critical for enhancing software performance, yet
finding the optimal pass sequence for a specific program is an NP-hard problem.
Traditional, general-purpose optimization flags like -O3 and -Oz adopt a
one-size-fits-all approach, often failing to unlock a program's full
performance potential. To address this challenge, we propose a novel Hybrid,
Knowledge-Guided Evolutionary Framework. This framework intelligently guides
online, personalized optimization using knowledge extracted from a large-scale
offline analysis phase. During the offline stage, we construct a comprehensive
compilation knowledge base composed of four key components: (1) Pass Behavioral
Vectors to quantitatively capture the effectiveness of each optimization; (2)
Pass Groups derived from clustering these vectors based on behavior similarity;
(3) a Synergy Pass Graph to model beneficial sequential interactions; and (4) a
library of Prototype Pass Sequences evolved for distinct program types. In the
online stage, a bespoke genetic algorithm leverages this rich knowledge base
through specially designed, knowledge-infused genetic operators. These
operators transform the search by performing semantically-aware recombination
and targeted, restorative mutations. On a suite of seven public datasets, our
framework achieves an average of 11.0% additional LLVM IR instruction reduction
over the highly-optimized opt -Oz baseline, demonstrating its state-of-the-art
capability in discovering personalized, high-performance optimization
sequences.

</details>


### [9] [A Systematic Study of Time Limit Exceeded Errors in Online Programming Assignments](https://arxiv.org/abs/2510.14339)
*Jialu Zhang,Jialiang Gu,Wangmeiyu Zhang,José Pablo Cambronero,John Kolesar,Ruzica Piskac,Daming Li,Hanyuan Shi*

Main category: cs.SE

TL;DR: This paper studies why Time Limit Exceeded (TLE) errors happen on Codeforces, finds that they’re due to more than just slow algorithms, and introduces Nettle, an automated tool that fixes TLEs with a 98.5% success rate—outperforming previous methods and validated with a new robust evaluation framework.


<details>
  <summary>Details</summary>
Motivation: Many users on online programming platforms face the persistent problem of Time Limit Exceeded (TLE) errors, which are difficult to diagnose and resolve due to a lack of actionable feedback and limited platform support. This often leads to frustration and users abandoning their coding attempts.

Method: The authors performed a large-scale empirical study by manually analyzing 1000 Codeforces submissions with TLE errors. They classified the root causes of these errors and studied user behaviors in fixing them. Based on these insights, they developed Nettle, an automated repair tool for TLE errors, and Nettle-Eval, an evaluation framework to assess the repairs. Nettle integrates LLMs with compiler feedback and test cases to generate correct code edits.

Result: The analysis revealed that TLE errors stem from a broader set of issues than just inefficient algorithms, including infinite loops and inefficient I/O. Nettle fixed 98.5% of the 1000 real-world TLE cases, surpassing the strongest LLM baseline. All the fixes passed both the Nettle-Eval framework and Codeforces’ official checker.

Conclusion: TLE errors in programming platforms are more complex than previously thought. Targeted automated tools like Nettle, coupled with thoughtful evaluation frameworks, can effectively and reliably help users resolve TLE errors, making online programming more accessible and less frustrating.

Abstract: Online programming platforms such as Codeforces and LeetCode attract millions
of users seeking to learn to program or refine their skills for industry
interviews. A major challenge for these users is the Time Limit Exceeded (TLE)
error, triggered when a program exceeds the execution time bound. Although
designed as a performance safeguard, TLE errors are difficult to resolve: error
messages provide no diagnostic insight, platform support is minimal, and
existing debugging tools offer little help. As a result, many users abandon
their submissions after repeated TLE failures.
  This paper presents the first large-scale empirical study of TLE errors in
online programming. We manually analyzed 1000 Codeforces submissions with TLE
errors, classified their root causes, and traced how users attempted to fix
them. Our analysis shows that TLE errors often arise not only from inefficient
algorithms but also from infinite loops, improper data structure use, and
inefficient I/O, challenging the conventional view that TLEs are purely
performance issues.
  Guided by these findings, we introduce Nettle, the first automated repair
tool specifically designed for TLE errors, and Nettle-Eval, the first framework
for evaluating TLE repairs. Integrating LLMs with targeted automated feedback
generated by the compiler and test cases, Nettle produces small, correct code
edits that eliminate TLEs while preserving functionality. Evaluated on the same
1000 real-world cases, Nettle achieves a 98.5% fix rate, far exceeding the
strongest LLM baseline, and all of its repairs pass both Nettle-Eval and the
platform's official checker, confirming the reliability of our framework.

</details>


### [10] [PathFix: Automated Program Repair with Expected Path](https://arxiv.org/abs/2510.14341)
*Xu He,Shu Wang,Kun Sun*

Main category: cs.SE

TL;DR: PathFix is a novel APR framework that uses path-sensitive analysis and LLMs to generate targeted code repairs. By focusing on correct execution paths, it produces more accurate patches and handles complex code better than existing methods.


<details>
  <summary>Details</summary>
Motivation: Automated program repair (APR) techniques struggle with generating too many plausible patches and overfitting to incomplete test suites because generating precise specifications for buggy software is difficult. There is a need for improved approaches that can generate more accurate repairs and address these key limitations.

Method: The paper presents PathFix, a new APR method utilizing path-sensitive constraints. PathFix operates in four steps: (1) tracing fault paths in buggy software, (2) extracting expected execution paths leading to correct outputs, (3) generating and evaluating patches by solving state constraints along these expected paths, and (4) validating patch correctness. Additionally, a large language model (LLM) is integrated to improve repair performance and scalability.

Result: PathFix demonstrates superior performance compared to existing APR solutions, especially in repairing complex program structures, such as those containing loops and recursion.

Conclusion: PathFix effectively overcomes core APR challenges by leveraging path-sensitive analysis and LLMs. It generates more precise patches and achieves better repair outcomes, especially with complicated code patterns, outperforming prior approaches.

Abstract: Automated program repair (APR) techniques are effective in fixing inevitable
defects in software, enhancing development efficiency and software robustness.
However, due to the difficulty of generating precise specifications, existing
APR methods face two main challenges: generating too many plausible patch
candidates and overfitting them to partial test cases. To tackle these
challenges, we introduce a new APR method named PathFix, which leverages
path-sensitive constraints extracted from correct execution paths to generate
patches for repairing buggy code. It is based on one observation: if a buggy
program is repairable, at least one expected path is supposed to replace the
fault path in the patched program. PathFix operates in four main steps. First,
it traces fault paths reaching the fault output in the buggy program. Second,
it derives expected paths by analyzing the desired correct output on the
control flow graph, where an expected path defines how a feasible patch leads
to the correct execution. Third, PathFix generates and evaluates patches by
solving state constraints along the expected path. Fourth, we validate the
correctness of the generated patch. To further enhance repair performance and
mitigate scalability issues introduced by path-sensitive analysis, we integrate
a large language model (LLM) into our framework. Experimental results show that
PathFix outperforms existing solutions, particularly in handling complex
program structures such as loops and recursion.

</details>


### [11] [Towards Automated Governance: A DSL for Human-Agent Collaboration in Software Projects](https://arxiv.org/abs/2510.14465)
*Adem Ait,Gwendal Jouneaux,Javier Luis Cánovas Izquierdo,Jordi Cabot*

Main category: cs.SE

TL;DR: Proposes a special language (DSL) to create clearer, adaptable governance rules for diverse teams (humans and AI) in open-source software projects.


<details>
  <summary>Details</summary>
Motivation: Increasing diversity in software development (from both humans and AI agents) creates complex governance needs. Current OSS projects often lack clear, explicit governance policies, necessitating new approaches for effective collaboration.

Method: Conceptual design of a DSL for governance policy specification, addressing the diversity and automation needs of modern software development, illustrated through the context of OSS projects.

Result: The paper presents foundational concepts and a vision for a new Domain-Specific Language (DSL) aimed at defining and enforcing governance policies in software development projects with diverse human and AI-powered stakeholders, focusing especially on Open-Source Software (OSS) environments.

Conclusion: Implementing and adopting this DSL could lead to more robust, automated, and adaptable governance frameworks, enhancing collaboration and policy clarity in OSS projects and other multi-stakeholder software environments.

Abstract: The stakeholders involved in software development are becoming increasingly
diverse, with both human contributors from varied backgrounds and AI-powered
agents collaborating together in the process. This situation presents unique
governance challenges, particularly in Open-Source Software (OSS) projects,
where explicit policies are often lacking or unclear. This paper presents the
vision and foundational concepts for a novel Domain-Specific Language (DSL)
designed to define and enforce rich governance policies in systems involving
diverse stakeholders, including agents. This DSL offers a pathway towards more
robust, adaptable, and ultimately automated governance, paving the way for more
effective collaboration in software projects, especially OSS ones.

</details>


### [12] [E2Edev: Benchmarking Large Language Models in End-to-End Software Development Task](https://arxiv.org/abs/2510.14509)
*Jingyao Liu,Chen Huang,Zhizhao Guan,Wenqiang Lei,Yang Deng*

Main category: cs.SE

TL;DR: E2EDev is a new benchmark with fine-grained requirements, BDD test scenarios, and an automated Behave-based pipeline, supported by a HITL annotation framework. Current frameworks and LLMs still struggle on these tasks, highlighting the need for better E2ESD solutions.


<details>
  <summary>Details</summary>
Motivation: There is a need for fine-grained, efficient end-to-end software development (E2ESD) tools and benchmarks, as existing frameworks and large language models (LLMs) struggle to solve these tasks effectively and cost-efficiently.

Method: The paper introduces E2EDev, which includes a detailed set of user requirements, multiple BDD (Behavior-Driven Development) test scenarios with corresponding Python steps, and an automated testing pipeline on the Behave framework, supported by a Human-in-the-Loop Multi-Agent Annotation Framework (HITL-MAA) to ensure quality with less annotation effort.

Result: Analysis shows that current E2ESD frameworks and LLMs still face significant challenges in effectively addressing these tasks, pointing to gaps in the field.

Conclusion: There is an ongoing need for more effective and affordable solutions in end-to-end software development tasks, and E2EDev provides a new benchmark to foster progress in this area.

Abstract: E2EDev comprises (i) a fine-grained set of user requirements, (ii) {multiple
BDD test scenarios with corresponding Python step implementations for each
requirement}, and (iii) a fully automated testing pipeline built on the Behave
framework. To ensure its quality while reducing the annotation effort, E2EDev
leverages our proposed Human-in-the-Loop Multi-Agent Annotation Framework
(HITL-MAA). {By evaluating various E2ESD frameworks and LLM backbones with
E2EDev}, our analysis reveals a persistent struggle to effectively solve these
tasks, underscoring the critical need for more effective and cost-efficient
E2ESD solutions. Our codebase and benchmark are publicly available at
https://github.com/SCUNLP/E2EDev.

</details>


### [13] [Software Testing Education and Industry Needs - Report from the ENACTEST EU Project](https://arxiv.org/abs/2510.14625)
*Mehrdad Saadatmand,Abbas Khan,Beatriz Marin,Ana C. R Paiva,Nele Van Asch,Graham Moran,Felix Cammaerts,Monique Snoeck,Alexandra Mendes*

Main category: cs.SE

TL;DR: There are serious gaps between what industry needs and what current software testing education provides, particularly in new domains like AI testing, security, and soft skills.


<details>
  <summary>Details</summary>
Motivation: Software testers must keep up with rapid changes in tools and practices, but there's uncertainty about whether current educational offerings and training actually meet evolving industry needs.

Method: The researchers conducted two focus groups and interviews with software testing professionals from diverse industries, along with a curated, small-scale scoping review. They used a collaboratively designed and iteratively refined study instrument, then analyzed results via thematic qualitative analysis.

Result: The study found significant knowledge gaps in current software testing education, especially in AI testing, security testing, and soft skills. These gaps are not sufficiently addressed in academic literature or professional training. Industry professionals face challenges in training delivery and evaluating its quality, and have identified areas where training and knowledge transfer methods need improvement.

Conclusion: The current approach to software testing education and professional training does not fully prepare testers for industry's actual competency needs. Academics and industry practitioners must collaborate to update curricula and training methods, with particular focus on emerging topics and soft skills.

Abstract: The evolving landscape of software development demands that software testers
continuously adapt to new tools, practices, and acquire new skills. This study
investigates software testing competency needs in industry, identifies
knowledge gaps in current testing education, and highlights competencies and
gaps not addressed in academic literature. This is done by conducting two focus
group sessions and interviews with professionals across diverse domains,
including railway industry, healthcare, and software consulting and performing
a curated small-scale scoping review. The study instrument, co-designed by
members of the ENACTEST project consortium, was developed collaboratively and
refined through multiple iterations to ensure comprehensive coverage of
industry needs and educational gaps. In particular, by performing a thematic
qualitative analysis, we report our findings and observations regarding:
professional training methods, challenges in offering training in industry,
different ways of evaluating the quality of training, identified knowledge gaps
with respect to academic education and industry needs, future needs and trends
in testing education, and knowledge transfer methods within companies. Finally,
the scoping review results confirm knowledge gaps in areas such as AI testing,
security testing and soft skills.

</details>


### [14] [ATGen: Adversarial Reinforcement Learning for Test Case Generation](https://arxiv.org/abs/2510.14635)
*Qingyao Li,Xinyi Dai,Weiwen Liu,Xiangyang Li,Yasheng Wang,Ruiming Tang,Yong Yu,Weinan Zhang*

Main category: cs.SE

TL;DR: Static datasets limit current code test generators. ATGen uses adversarial reinforcement learning to dynamically challenge and improve test case generation, outperforming existing methods and increasing the reliability of code from LLMs.


<details>
  <summary>Details</summary>
Motivation: Existing test generation methods for code produced by Large Language Models are limited by static datasets, unable to evolve and challenge models with more complex or novel bugs.

Method: ATGen, a framework utilizing adversarial reinforcement learning, pits a test case generator against a code generator that crafts increasingly difficult bugs, creating a dynamic, curriculum-based training loop. The test generator is optimized jointly for output accuracy and attack success using RL.

Result: ATGen outperformed current state-of-the-art baselines in test case generation, serving as a better filter in Best-of-N inference and a more effective reward source for code model training.

Conclusion: A dynamic adversarial curriculum via ATGen breaks the limits of static training, improving the reliability of LLM-generated code and establishing a novel paradigm for test case generation.

Abstract: Large Language Models (LLMs) excel at code generation, yet their outputs
often contain subtle bugs, for which effective test cases are a critical
bottleneck. Existing test generation methods, whether based on prompting or
supervised fine-tuning, rely on static datasets. This imposes a
``fixed-difficulty ceiling'', fundamentally limiting their ability to uncover
novel or more complex bugs beyond their training scope. To overcome this, we
introduce ATGen, a framework that trains a test case generator via adversarial
reinforcement learning. ATGen pits a test generator against an adversarial code
generator that continuously crafts harder bugs to evade the current policy.
This dynamic loop creates a curriculum of increasing difficulty challenging
current policy. The test generator is optimized via Reinforcement Learning (RL)
to jointly maximize ``Output Accuracy'' and ``Attack Success'', enabling it to
learn a progressively stronger policy that breaks the fixed-difficulty ceiling
of static training. Extensive experiments demonstrate that ATGen significantly
outperforms state-of-the-art baselines. We further validate its practical
utility, showing it serves as both a more effective filter for Best-of-N
inference and a higher-quality reward source for training code generation
models. Our work establishes a new, dynamic paradigm for improving the
reliability of LLM-generated code.

</details>


### [15] [Requirement Identification for Traffic Simulations in Driving Simulators](https://arxiv.org/abs/2510.14653)
*Sven Tarlowski,Lutz Eckstein*

Main category: cs.SE

TL;DR: The paper presents a stepwise methodology for identifying realistic traffic simulation requirements, improving experimental validity and engagement, which aids automotive development.


<details>
  <summary>Details</summary>
Motivation: There is a challenge in ensuring traffic simulation reflects realistic conditions, which is necessary for reliable automotive development and testing.

Method: The paper introduces a structured methodology that uses sub-goals in each study phase to derive specific requirements for microscopic traffic levels, agent models, and visual representations.

Result: This methodology enables systematic identification of technical needs, ensuring high fidelity in traffic simulations and improving validity of experiments and participant engagement.

Conclusion: The approach clearly connects study objectives to traffic simulation design, supporting more robust automotive development and testing.

Abstract: This paper addresses the challenge of ensuring realistic traffic conditions
by proposing a methodology that systematically identifies traffic simulation
requirements. Using a structured approach based on sub-goals in each study
phase, specific technical needs are derived for microscopic levels, agent
models, and visual representation. The methodology aims to maintain a high
degree of fidelity, enhancing both the validity of experimental outcomes and
participant engagement. By providing a clear link between study objectives and
traffic simulation design, this approach supports robust automotive development
and testing.

</details>


### [16] [LLM Agents for Automated Web Vulnerability Reproduction: Are We There Yet?](https://arxiv.org/abs/2510.14700)
*Bin Liu,Yanjie Zhao,Guoai Xu,Haoyu Wang*

Main category: cs.SE

TL;DR: This paper rigorously evaluates various large language model agents for automated web vulnerability reproduction, finding that while LLMs can handle simple cases, they fail with complex real-world vulnerabilities due to environmental and authentication challenges, indicating the need for more adaptive and autonomous agent capabilities.


<details>
  <summary>Details</summary>
Motivation: Automated web vulnerability reproduction is crucial for translating vulnerability reports into working exploits, aiding security researchers and practitioners. However, leveraging LLM agents for this task remains underexplored, especially in the context of real-world web vulnerabilities.

Method: The authors conducted the first comprehensive evaluation of 20 state-of-the-art LLM agents from software engineering, cybersecurity, and general domains. They assessed these agents across 16 dimensions (technical, adaptability, user factors) and selected three leading agents for deeper benchmarking on 80 real-world CVEs involving diverse vulnerability types and web technologies.

Result: LLM agents had reasonable success with simple, library-based vulnerabilities but consistently failed to reproduce complex, service-based vulnerabilities requiring multi-component environments and authentication. Performance suffered significantly when incomplete guidance (e.g., authentication details) was provided, with over 33% degradation observed.

Conclusion: There exists a significant gap between current LLM agent capabilities and the practical requirements of automated web vulnerability reproduction, especially for complex scenarios. Advances are needed in environmental adaptability and autonomous problem-solving to make LLM agents reliably effective for real-world web security tasks.

Abstract: Large language model (LLM) agents have demonstrated remarkable capabilities
in software engineering and cybersecurity tasks, including code generation,
vulnerability discovery, and automated testing. One critical but underexplored
application is automated web vulnerability reproduction, which transforms
vulnerability reports into working exploits. Although recent advances suggest
promising potential, challenges remain in applying LLM agents to real-world web
vulnerability reproduction scenarios. In this paper, we present the first
comprehensive evaluation of state-of-the-art LLM agents for automated web
vulnerability reproduction. We systematically assess 20 agents from software
engineering, cybersecurity, and general domains across 16 dimensions, including
technical capabilities, environment adaptability, and user experience factors,
on 3 representative web vulnerabilities. Based on the results, we select three
top-performing agents (OpenHands, SWE-agent, and CAI) for in-depth evaluation
on our benchmark dataset of 80 real-world CVEs spanning 7 vulnerability types
and 6 web technologies. Our results reveal that while LLM agents achieve
reasonable success on simple library-based vulnerabilities, they consistently
fail on complex service-based vulnerabilities requiring multi-component
environments. Complex environment configurations and authentication barriers
create a gap where agents can execute exploit code but fail to trigger actual
vulnerabilities. We observe high sensitivity to input guidance, with
performance degrading by over 33% under incomplete authentication information.
Our findings highlight the significant gap between current LLM agent
capabilities and the demands of reliable automated vulnerability reproduction,
emphasizing the need for advances in environmental adaptation and autonomous
problem-solving capabilities.

</details>


### [17] [Leveraging Code Cohesion Analysis to Identify Source Code Supply Chain Attacks](https://arxiv.org/abs/2510.14778)
*Maor Reuben,Ido Mendel,Or Feldman,Moshe Kravchik,Mordehai Guri,Rami Puzis*

Main category: cs.SE

TL;DR: The paper presents an unsupervised method for detecting supply chain attacks in software by measuring cohesion disruptions using a name-prediction-based metric. The approach effectively identifies functions with malicious code injections even in highly imbalanced scenarios, illustrating its utility for enhancing software security.


<details>
  <summary>Details</summary>
Motivation: Supply chain attacks, involving malicious code injected into legitimate software, are a serious but rare threat with potentially devastating consequences. Automated detection is challenging because it is hard to determine the intent of injected code within its context. Current tools are limited in detecting such sophisticated attacks.

Method: The study introduces an unsupervised method to detect malicious code injections by measuring disruptions in source code cohesion. It proposes a name-prediction-based cohesion (NPC) metric that quantifies changes in function cohesion and naming patterns after code injections, contrasting those with normal code evolution.

Result: Analyzing over 54,000 functions from 369 open-source C++ projects, the method showed that injected code tends to decrease cohesion and leads to shorter, less descriptive function names. Evaluation under highly imbalanced test conditions (to simulate the rarity of supply chain attacks) demonstrated promising detection capability, with a Precision@100 of 36.41% at a 1:1,000 ratio and 12.47% at 1:10,000.

Conclusion: Automated measurement of code cohesion, especially using name-prediction-based metrics, shows potential as an effective means for highlighting possible supply chain attacks. This approach could thus improve code integrity and security by identifying malicious code injections in software repositories.

Abstract: Supply chain attacks significantly threaten software security with malicious
code injections within legitimate projects. Such attacks are very rare but may
have a devastating impact. Detecting spurious code injections using automated
tools is further complicated as it often requires deciphering the intention of
both the inserted code and its context. In this study, we propose an
unsupervised approach for highlighting spurious code injections by quantifying
cohesion disruptions in the source code. Using a name-prediction-based cohesion
(NPC) metric, we analyze how function cohesion changes when malicious code is
introduced compared to natural cohesion fluctuations. An analysis of 54,707
functions over 369 open-source C++ repositories reveals that code injection
reduces cohesion and shifts naming patterns toward shorter, less descriptive
names compared to genuine function updates. Considering the sporadic nature of
real supply-chain attacks, we evaluate the proposed method with extreme
test-set imbalance and show that monitoring high-cohesion functions with NPC
can effectively detect functions with injected code, achieving a Precision@100
of 36.41% at a 1:1,000 ratio and 12.47% at 1:10,000. These results suggest that
automated cohesion measurements, in general, and name-prediction-based
cohesion, in particular, may help identify supply chain attacks, improving
source code integrity.

</details>


### [18] [Instruction Set Migration at Warehouse Scale](https://arxiv.org/abs/2510.14928)
*Eric Christopher,Kevin Crossan,Wolff Dobson,Chris Kennelly,Drew Lewis,Kun Lin,Martin Maas,Parthasarathy Ranganathan,Emma Rapati,Brian Yang*

Main category: cs.SE

TL;DR: Migrating codebases between instruction set architectures (e.g., from x86 to Arm) is now more about tackling a broad set of challenges than just binary translation, thanks to open-source ecosystems. Google's large-scale migration shows much of the process can be automated—especially with AI—though some hard problems remain and need further research.


<details>
  <summary>Details</summary>
Motivation: The motivation stems from the increasing need to migrate codebases between ISAs, as seen in the adoption of Arm by cloud hyperscalers, and the observation that academic focus has lagged behind the evolving challenges of ISA migration.

Method: The authors analyze a large-scale x86-to-Arm migration at Google, involving around 40,000 code commits, and derive a taxonomy of migration tasks. They study Google's automation strategies and the role of AI in the migration process.

Result: The analysis reveals a taxonomy of migration tasks, highlights successful automation strategies, and identifies the significant impact of AI. Some migration tasks remain unresolved, pointing to ongoing research needs.

Conclusion: The paper concludes that the key challenges in migrating codebases between ISAs have shifted from binary translation to broader, multifaceted tasks enabled by open-source ecosystems, and that automation—particularly with AI—can address many steps, although some challenges remain.

Abstract: Migrating codebases from one instruction set architecture (ISA) to another is
a major engineering challenge. A recent example is the adoption of Arm (in
addition to x86) across the major Cloud hyperscalers. Yet, this problem has
seen limited attention by the academic community. Most work has focused on
static and dynamic binary translation, and the traditional conventional wisdom
has been that this is the primary challenge.
  In this paper, we show that this is no longer the case. Modern ISA migrations
can often build on a robust open-source ecosystem, making it possible to
recompile all relevant software from scratch. This introduces a new and
multifaceted set of challenges, which are different from binary translation.
  By analyzing a large-scale migration from x86 to Arm at Google, spanning
almost 40,000 code commits, we derive a taxonomy of tasks involved in ISA
migration. We show how Google automated many of the steps involved, and
demonstrate how AI can play a major role in automatically addressing these
tasks. We identify tasks that remain challenging and highlight research
challenges that warrant further attention.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [19] [HITrees: Higher-Order Interaction Trees](https://arxiv.org/abs/2510.14558)
*Amir Mohammad Fadaei Ayyam,Michael Sammler*

Main category: cs.PL

TL;DR: This paper introduces Higher-Order Interaction Trees (HITrees) for supporting higher-order effects in compositional semantics, implemented in Lean and demonstrated on complex language features like parallelism and call/cc.


<details>
  <summary>Details</summary>
Motivation: Existing interaction trees lack support for higher-order effects, which are crucial for modeling advanced semantic features like parallel composition and call/cc in formal verification.

Method: The authors introduce Higher-Order Interaction Trees (HITrees), employing two main techniques: (1) redesigning effect notions so that fixpoints of higher-order input effects can be expressed as inductive types, and (2) using defunctionalization to encode higher-order outputs as first-order representations. They implement HITrees in Lean and provide a comprehensive effects library.

Result: HITrees successfully support higher-order effects in a non-guarded type theory, enabling modeling of concurrency, recursion, and call/cc. The authors also provide state transition system and monadic program interpretations of HITrees.

Conclusion: HITrees extend interaction trees to handle higher-order effects, enhancing their applicability for formal semantics involving advanced features such as parallel composition and call/cc. The Lean implementation and library demonstrate HITrees’ expressiveness and practical utility.

Abstract: Recent years have witnessed the rise of compositional semantics as a
foundation for formal verification of complex systems. In particular,
interaction trees have emerged as a popular denotational semantics. Interaction
trees achieve compositionality by providing a reusable library of effects.
However, their notion of effects does not support higher-order effects, i.e.,
effects that take or return monadic computations. Such effects are essential to
model complex semantic features like parallel composition and call/cc.
  We introduce Higher-Order Interaction Trees (HITrees), the first variant of
interaction trees to support higher-order effects in a non-guarded type theory.
HITrees accomplish this through two key techniques: first, by designing the
notion of effects such that the fixpoints of effects with higher-order input
can be expressed as inductive types inside the type theory; and second, using
defunctionalization to encode higher-order outputs into a first-order
representation. We implement HITrees in the Lean proof assistant, accompanied
by a comprehensive library of effects including concurrency, recursion, and
call/cc. Furthermore, we provide two interpretations of HITrees, as state
transition systems and as monadic programs. To demonstrate the expressiveness
of HITrees, we apply them to define the semantics of a language with parallel
composition and call/cc.

</details>
