<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 9]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Empirical Studies on Quantum Optimization for Software Engineering: A Systematic Analysis](https://arxiv.org/abs/2510.27113)
*Man Zhang,Yuechen Li,Tao Yue,Kai-Yuan Cai*

Main category: cs.SE

TL;DR: This paper systematically reviews empirical practices in studies of quantum-related optimization algorithms for software engineering, finds key gaps in experimental rigor and reporting, and calls for better protocols and real-world case studies to improve future research.


<details>
  <summary>Details</summary>
Motivation: Quantum, quantum-inspired, and hybrid algorithms are increasingly used for tackling software engineering optimization problems, but standardized guidelines for empirical studies in this context are lacking.

Method: The authors conducted a systematic analysis of primary studies identified from a recent systematic literature review on quantum optimization applied to software engineering. They examined studies based on experimental design, hyperparameter settings, use cases, baselines, tools, and evaluation metrics.

Result: The study found several deficiencies in current practices, such as inconsistent reporting of experimental repetition, insufficient documentation on number of shots and noise handling, and a lack of standardized protocols and quantum-specific quality metrics.

Conclusion: The paper concludes that there is a need for improved, standardized methodologies in empirical research involving quantum algorithms in software engineering and highlights the importance of real-world case studies to better assess the practical effectiveness of these approaches.

Abstract: In recent years, quantum, quantum-inspired, and hybrid algorithms are
increasingly showing promise for solving software engineering optimization
problems. However, best-intended practices for conducting empirical studies
have not yet well established. In this paper, based on the primary studies
identified from the latest systematic literature review on quantum optimization
for software engineering problems, we conducted a systematic analysis on these
studies from various aspects including experimental designs, hyperparameter
settings, case studies, baselines, tooling, and metrics. We identify key gaps
in the current practices such as limited reporting of the number of
repetitions, number of shots, and inadequate consideration of noise handling,
as well as a lack of standardized evaluation protocols such as the adoption of
quality metrics, especially quantum-specific metrics. Based on our analysis, we
provide insights for designing empirical studies and highlight the need for
more real-world and open case studies to assess cost-effectiveness and
practical utility of the three types of approaches: quantum-inspired, quantum,
and hybrid. This study is intended to offer an overview of current practices
and serve as an initial reference for designing and conducting empirical
studies on evaluating and comparing quantum, quantum-inspired, and hybrid
algorithms in solving optimization problems in software engineering.

</details>


### [2] [MARIA: A Framework for Marginal Risk Assessment without Ground Truth in AI Systems](https://arxiv.org/abs/2510.27163)
*Jieshan Chen,Suyu Ma,Qinghua Lu,Sung Une Lee,Liming Zhu*

Main category: cs.SE

TL;DR: The paper introduces a marginal risk assessment framework for AI deployment that relies on comparing the AI with existing systems instead of absolute metrics, enabling safer and more effective adoption when ground truth data is unavailable.


<details>
  <summary>Details</summary>
Motivation: Traditional evaluation of AI systems requires ground truth data, which is often unavailable due to high costs, delayed outcomes, or incomplete existing data. This poses a challenge when assessing the risk and efficacy of replacing established processes with AI.

Method: The paper proposes a marginal risk assessment framework, which focuses on evaluating the difference in risk between AI and incumbent systems, rather than their absolute risk. The framework emphasizes three relative evaluation methodologies: predictability, capability, and interaction dominance. This approach avoids dependency on ground truth data.

Result: By using relative rather than absolute evaluation methods, software teams can better identify the areas where AI systems improve processes, potentially introduce risks, or require caution during adoption.

Conclusion: Shifting from absolute to relative evaluation empowers teams to make informed decisions about adopting AI, ensuring improvements with minimal added risk and responsible deployment.

Abstract: Before deploying an AI system to replace an existing process, it must be
compared with the incumbent to ensure improvement without added risk.
Traditional evaluation relies on ground truth for both systems, but this is
often unavailable due to delayed or unknowable outcomes, high costs, or
incomplete data, especially for long-standing systems deemed safe by
convention. The more practical solution is not to compute absolute risk but the
difference between systems. We therefore propose a marginal risk assessment
framework, that avoids dependence on ground truth or absolute risk. It
emphasizes three kinds of relative evaluation methodology, including
predictability, capability and interaction dominance. By shifting focus from
absolute to relative evaluation, our approach equips software teams with
actionable guidance: identifying where AI enhances outcomes, where it
introduces new risks, and how to adopt such systems responsibly.

</details>


### [3] [On the Marriage of Theory and Practice in Data-Aware Business Processes via Low-Code](https://arxiv.org/abs/2510.27229)
*Ali Nour Eldin,Benjamin Dalmas,Walid Gaaloul*

Main category: cs.SE

TL;DR: BPMN-ProX is a low-code framework that enables formal, accessible verification of business process models with integrated data. It empowers non-experts to perform robust model checking, improving business process reliability and agility.


<details>
  <summary>Details</summary>
Motivation: Business process models are widely used but lack formal characterization, making their verification challenging. As data is integral to process execution, there is a need for tools that facilitate reliable verification of data-aware BPMN models.

Method: The paper introduces BPMN-ProX, a low-code testing framework designed to enhance verification of data-aware BPMN models. It integrates advanced data handling capabilities and leverages state-of-the-art model checkers to verify execution semantics.

Result: BPMN-ProX bridges the gap between non-technical users and experts by providing a user-friendly tool for formal and robust verification of business process models. The approach enables agile, reliable, and user-centric process management.

Conclusion: Formalizing business process modeling with tools like BPMN-ProX improves verification, supports collaboration between stakeholders, and enhances the reliability of data-aware business process management.

Abstract: In recent years, there has been a growing interest in the verification of
business process models. Despite their lack of formal characterization, these
models are widely adopted in both industry and academia. To address this issue,
formalizing the execution semantics of business process modeling languages is
essential. Since data and process are two facets of the same coin, and data are
critical elements in the execution of process models, this work introduces
Proving an eXecutable BPMN injected with data, BPMN-ProX. BPMN-ProX is a
low-code testing framework that significantly enhances the verification of
data-aware BPMN. This low-code platform helps bridge the gap between
non-technical experts and professionals by proposing a tool that integrates
advanced data handling and employs a robust verification mechanism through
state-of-the-art model checkers. This innovative approach combines theoretical
verification with practical modeling, fostering more agile, reliable, and
user-centric business process management.

</details>


### [4] [Vintage Code, Modern Judges: Meta-Validation in Low Data Regimes](https://arxiv.org/abs/2510.27244)
*Ora Nova Fandina,Gal Amram,Eitan Farchi,Shmulik Froimovich,Raviv Gal,Wesam Ibraheem,Rami Katan,Alice Podolsky,Orna Raz*

Main category: cs.SE

TL;DR: The paper introduces SparseAlign, a new framework for validating AI model evaluators with limited human labels. It helps ensure Large Language Models as Judges (LaaJs) are reliable for tasks like COBOL modernization, even when there's little annotated data. SparseAlign proved effective in real-world use, supporting more trustworthy model selection and deployment.


<details>
  <summary>Details</summary>
Motivation: Modernizing applications written in legacy languages (e.g., COBOL, PL/I, REXX) is challenged by a scarcity of experts and limited high-quality human evaluation data. Organizations are increasingly using Large Language Models as Judges (LaaJs) to evaluate code outputs, but there's a risk of unreliable judgments without proper validation, especially since it’s hard to align LaaJ outputs with human judgment when annotated data is scarce.

Method: The paper introduces SparseAlign, a formal framework that evaluates LaaJ alignment with sparse human-labeled data. SparseAlign uses a novel pairwise-confidence concept and a score-sensitive metric to assess both the consistency and accuracy of LaaJ rankings relative to human evaluators, even when only a small amount of labeled data is available. SparseAlign was applied to the selection of LaaJs for COBOL code explanation tasks and includes a case study with four LaaJs.

Result: SparseAlign enabled the reliable selection of language model evaluators (LaaJs) for use in COBOL application modernization workflows. The evaluators that best aligned with human judgment were integrated into decision-making processes for model releases. A case study showed SparseAlign's practical value in real-world scenarios despite limited human-labeled data.

Conclusion: SparseAlign provides a principled way to validate and select reliable language model evaluators (LaaJs) even when human-annotated evaluation data are sparse, reducing the risk of unreliable judgments and improving trust in AI-assisted application modernization.

Abstract: Application modernization in legacy languages such as COBOL, PL/I, and REXX
faces an acute shortage of resources, both in expert availability and in
high-quality human evaluation data. While Large Language Models as a Judge
(LaaJ) offer a scalable alternative to expert review, their reliability must be
validated before being trusted in high-stakes workflows. Without principled
validation, organizations risk a circular evaluation loop, where unverified
LaaJs are used to assess model outputs, potentially reinforcing unreliable
judgments and compromising downstream deployment decisions. Although various
automated approaches to validating LaaJs have been proposed, alignment with
human judgment remains a widely used and conceptually grounded validation
strategy. In many real-world domains, the availability of human-labeled
evaluation data is severely limited, making it difficult to assess how well a
LaaJ aligns with human judgment. We introduce SparseAlign, a formal framework
for assessing LaaJ alignment with sparse human-labeled data. SparseAlign
combines a novel pairwise-confidence concept with a score-sensitive alignment
metric that jointly capture ranking consistency and score proximity, enabling
reliable evaluator selection even when traditional statistical methods are
ineffective due to limited annotated examples. SparseAlign was applied
internally to select LaaJs for COBOL code explanation. The top-aligned
evaluators were integrated into assessment workflows, guiding model release
decisions. We present a case study of four LaaJs to demonstrate SparseAlign's
utility in real-world evaluation scenarios.

</details>


### [5] [Efficient Integration of cross platform functions onto service-oriented architectures](https://arxiv.org/abs/2510.27344)
*Thomas Schulik,Viswanatha Reddy Batchu,Ramesh Kumar Dharmapuri,Saran Gundlapalli,Parthasarathy Nadarajan,Philipp Pelcz*

Main category: cs.SE

TL;DR: The paper introduces a standardized, platform-agnostic approach to developing automotive applications, simplifying integration across various software architectures. The concept was validated on AUTOSAR Adaptive and ROS 2 platforms, showing improved efficiency through machine-readable interface descriptions and semi-automation tools.


<details>
  <summary>Details</summary>
Motivation: The automotive industry's E/E and software architectures are becoming increasingly complex due to advances in technology and the emergence of Software-Defined Vehicles (SDVs). This complexity has led to a diverse array of heterogeneous software platforms, making the development and integration of automotive applications more challenging.

Method: The paper proposes a novel concept for application development and integration by standardizing application interfaces and designing apps to be hardware- and platform/middleware-agnostic. The approach uses machine-readable descriptions of applications and middleware to facilitate integration. Tools for semi-automated development and integration are also presented. The concept is validated via example implementation and integration on AUTOSAR Adaptive and ROS 2 platforms, with metrics provided to measure efficiency.

Result: The proposed concept enables efficient development and integration of applications across multiple heterogeneous automotive software platforms. The approach was successfully demonstrated by developing and integrating an example application onto both AUTOSAR Adaptive and ROS 2 platforms. The presented metrics confirm the efficiency of the concept.

Conclusion: A standardized, platform-agnostic development and integration methodology significantly improves efficiency and flexibility for application deployment in increasingly complex automotive software environments. The proposed concept and supporting tools facilitate hardware- and middleware-agnostic application design, streamlining integration across diverse platforms.

Abstract: The automotive industry is currently undergoing a major transformation with
respect to the Electric/Electronic (E/E) and software architecture, driven by a
significant increase in the complexity of the technological stack within a
vehicle. This complexity acts as a driving force for Software-Defined Vehicles
(SDVs) leading to the evolution of the automotive E/E architectures from
decentralized configuration comprising multiple Electronic Control Units (ECUs)
towards a more integrated configuration comprising a smaller number of ECUs,
domain controllers, gateways, and High-Performance Computers (HPCs) [2]. This
transition along with several other reasons have resulted in heterogeneous
software platforms such as AUTOSAR Classic, AUTOSAR Adaptive, and prototypical
frameworks like ROS 2. It is therefore essential to develop applications that
are both hardware- and platform/middleware-agnostic to attain development and
integration efficiency. This work presents an application development and
integration concept to facilitate developing applications as Software as a
Product (SaaP), while simultaneously ensuring efficient integration onto
multiple software architecture platforms. The concept involves designing
applications in a hardware- and software platform-agnostic manner and
standardizing application interfaces [6]. It also includes describing the
relevant aspects of the application and corresponding middleware in a
machine-readable format to aid the integration of developed applications.
Additionally, tools are developed to facilitate semi-automation of the
development and integration processes. An example application has been
developed and integrated onto AUTOSAR Adaptive and ROS 2, demonstrating the
applicability of the approach. Finally, metrics are presented to show the
efficiency of the overall concept.

</details>


### [6] [Agentic LLMs for REST API Test Amplification: A Comparative Study Across Cloud Applications](https://arxiv.org/abs/2510.27417)
*Jarne Besjes,Robbe Nooyens,Tolgahan Bardakci,Mutlu Beyazit,Serge Demeyer*

Main category: cs.SE

TL;DR: This paper investigates how agent-powered Large Language Models can automate and improve REST API test generation across various cloud applications. Results show better coverage and bug detection with less human effort, though there are trade-offs in computational cost and efficiency.


<details>
  <summary>Details</summary>
Motivation: REST APIs are fundamental to cloud-native systems, but creating automated, comprehensive, and boundary-exploring test cases for these APIs is difficult and resource-intensive. There is a need to enhance test automation and efficiency.

Method: The paper extends previous research on using Large Language Models (LLMs) for test amplification, specifically by experimenting with both single-agent and multi-agent LLM configurations. These were evaluated on four diverse cloud applications, focusing on REST APIs.

Result: Amplified test suites generated by agentic LLM systems were semantically valid and required little human oversight. These suites improved both endpoint and parameter coverage, helped in identifying defects, and could generalize across different API architectures. The paper also analyzed computational and resource costs, noting trade-offs between accuracy, scalability, and efficiency.

Conclusion: LLM-driven test amplification offers a promising way to automate and scale REST API testing, enhancing coverage and defect detection with minimal intervention, while also considering computational sustainability.

Abstract: Representational State Transfer (REST) APIs are a cornerstone of modern cloud
native systems. Ensuring their reliability demands automated test suites that
exercise diverse and boundary level behaviors. Nevertheless, designing such
test cases remains a challenging and resource intensive endeavor. This study
extends prior work on Large Language Model (LLM) based test amplification by
evaluating single agent and multi agent configurations across four additional
cloud applications. The amplified test suites maintain semantic validity with
minimal human intervention. The results demonstrate that agentic LLM systems
can effectively generalize across heterogeneous API architectures, increasing
endpoint and parameter coverage while revealing defects. Moreover, a detailed
analysis of computational cost, runtime, and energy consumption highlights
trade-offs between accuracy, scalability, and efficiency. These findings
underscore the potential of LLM driven test amplification to advance the
automation and sustainability of REST API testing in complex cloud
environments.

</details>


### [7] [CodeAlignBench: Assessing Code Generation Models on Developer-Preferred Code Adjustments](https://arxiv.org/abs/2510.27565)
*Forough Mehralian,Ryan Shar,James R. Rae,Alireza Hashemi*

Main category: cs.SE

TL;DR: The authors present a new, multi-language benchmark that evaluates how well large language models follow instructions and improve code. The results show varying performance across tasks and languages, providing a more thorough picture of model strengths and weaknesses than traditional benchmarks that only check if the code works.


<details>
  <summary>Details</summary>
Motivation: Current benchmarks for code generation by large language models (LLMs) mostly assess if the code works (functional correctness), but they do not adequately represent the variety of real-world coding tasks or fully consider what developers actually want, such as following detailed instructions and making iterative improvements.

Method: The authors introduce a multi-language, extensible benchmark aimed at evaluating the ability of LLMs to follow instructions. This benchmark works for any standalone coding problem and assesses performance in two main scenarios: (1) following pre-defined constraints in the original problem, and (2) refining the code based on additional or follow-up instructions. They tested their benchmark empirically using tasks from LiveBench, which were automatically translated from Python into Java and JavaScript.

Result: Automated benchmarking revealed that different LLMs display varying capacities for instruction-following, depending on the task and language. The benchmark can highlight the models' strengths and weaknesses in following instructions and generating/refining code across multiple languages and objectives.

Conclusion: The proposed benchmarking pipeline offers a more comprehensive evaluation for code generation models by assessing their instruction-following abilities in both original and refinement scenarios and across multiple programming languages. This approach yields deeper insights into the models' real-world applicability and limitations, moving beyond just functional correctness.

Abstract: As large language models become increasingly capable of generating code,
evaluating their performance remains a complex and evolving challenge. Existing
benchmarks primarily focus on functional correctness, overlooking the diversity
of real-world coding tasks and developer expectations. To this end, we
introduce a multi-language benchmark that evaluates LLM instruction-following
capabilities and is extensible to operate on any set of standalone coding
problems. Our benchmark evaluates instruction following in two key settings:
adherence to pre-defined constraints specified with the initial problem, and
the ability to perform refinements based on follow-up instructions. For this
paper's analysis, we empirically evaluated our benchmarking pipeline with
programming tasks from LiveBench, that are also automatically translated from
Python into Java and JavaScript. Our automated benchmark reveals that models
exhibit differing levels of performance across multiple dimensions of
instruction-following. Our benchmarking pipeline provides a more comprehensive
evaluation of code generation models, highlighting their strengths and
limitations across languages and generation goals.

</details>


### [8] [Enhancing software product lines with machine learning components](https://arxiv.org/abs/2510.27640)
*Luz-Viviana Cobaleda,Julián Carvajal,Paola Vallejo,Andrés López,Raúl Mazo*

Main category: cs.SE

TL;DR: This paper presents a structured framework to help Software Product Lines (SPLs) systematically integrate machine learning components, improving variability management and reuse. Existing solutions rarely address both SPL and ML integration together. The framework, partially implemented with the VariaMos tool, fills this gap and supports the design of ML-enabled SPLs.


<details>
  <summary>Details</summary>
Motivation: Modern software systems are increasingly incorporating machine learning to enhance data-driven decision-making. However, in the context of software product lines (SPLs), the inclusion of ML introduces new challenges in managing variability and reuse. Existing solutions generally address either SPL variability or ML integration in isolation, leaving a gap at their intersection.

Method: The paper proposes a structured framework that extends Software Product Line engineering to facilitate the integration of ML components. The framework supports systematic modeling of variability and reuse in SPLs with ML capabilities. Implementation of the framework has been initiated using the VariaMos tool.

Result: A new framework is presented to support the systematic modeling and management of variability in SPLs with integrated ML components. The framework aids in the effective design and reuse of systems featuring ML and has been partially realized through the VariaMos tool.

Conclusion: Integrating ML components in SPLs raises complexity in variability management and reuse. The proposed framework provides a systematic approach to address these challenges, marking a step forward in combining SPL engineering with ML integration. Partial implementation demonstrates feasibility using existing tools.

Abstract: Modern software systems increasingly integrate machine learning (ML) due to
its advancements and ability to enhance data-driven decision-making. However,
this integration introduces significant challenges for software engineering,
especially in software product lines (SPLs), where managing variability and
reuse becomes more complex with the inclusion of ML components. Although
existing approaches have addressed variability management in SPLs and the
integration of ML components in isolated systems, few have explored the
intersection of both domains. Specifically, there is limited support for
modeling and managing variability in SPLs that incorporate ML components. To
bridge this gap, this article proposes a structured framework designed to
extend Software Product Line engineering, facilitating the integration of ML
components. It facilitates the design of SPLs with ML capabilities by enabling
systematic modeling of variability and reuse. The proposal has been partially
implemented with the VariaMos tool.

</details>


### [9] [On Selecting Few-Shot Examples for LLM-based Code Vulnerability Detection](https://arxiv.org/abs/2510.27675)
*Md Abdul Hannan,Ronghao Ni,Chi Zhang,Limin Jia,Ravi Mangal,Corina S. Pasareanu*

Main category: cs.SE

TL;DR: This paper investigates how to pick the best few-shot examples for improving LLMs in code vulnerability detection, proposing selection based on LLM performance on individual samples and similarity to the query program. Results show that thoughtful example selection enhances LLM accuracy in this task.


<details>
  <summary>Details</summary>
Motivation: LLMs struggle with detecting code vulnerabilities. Improving their performance in this task is desirable. In-context learning (ICL) shows promise if good few-shot examples are chosen, but the selection strategy is critical. The paper addresses how best to select examples for ICL in code vulnerability detection.

Method: The authors explore two main criteria for selecting few-shot examples for ICL: (1) using samples where LLMs perform consistently (make or avoid mistakes), hypothesizing that performance signals usefulness, and (2) sampling based on similarity to the query program via k-nearest neighbors. They evaluate these approaches—both separately and in combination—using open-source LLMs on several datasets.

Result: Evaluation shows the effectiveness of the selection criteria—individually and in combinations—on improving LLM performance for code vulnerability detection across multiple datasets.

Conclusion: Careful selection of few-shot examples, considering both LLM performance on candidate samples and their similarity to the query, can significantly enhance code vulnerability detection capabilities of large language models.

Abstract: Large language models (LLMs) have demonstrated impressive capabilities for
many coding tasks, including summarization, translation, completion, and code
generation. However, detecting code vulnerabilities remains a challenging task
for LLMs. An effective way to improve LLM performance is in-context learning
(ICL) - providing few-shot examples similar to the query, along with correct
answers, can improve an LLM's ability to generate correct solutions. However,
choosing the few-shot examples appropriately is crucial to improving model
performance. In this paper, we explore two criteria for choosing few-shot
examples for ICL used in the code vulnerability detection task. The first
criterion considers if the LLM (consistently) makes a mistake or not on a
sample with the intuition that LLM performance on a sample is informative about
its usefulness as a few-shot example. The other criterion considers similarity
of the examples with the program under query and chooses few-shot examples
based on the $k$-nearest neighbors to the given sample. We perform evaluations
to determine the benefits of these criteria individually as well as under
various combinations, using open-source models on multiple datasets.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [10] [Dependence-Driven, Scalable Quantum Circuit Mapping with Affine Abstractions](https://arxiv.org/abs/2510.27067)
*Marouane Benbetka,Merwan Bekkar,Riyadh Baghdadi,Martin Kong*

Main category: cs.PL

TL;DR: This paper presents a new qubit mapping method that leverages transitive dependence information, resulting in fewer SWAP gates and reduced circuit depth for quantum programs, outperforming several leading qubit mappers on practical benchmarks.


<details>
  <summary>Details</summary>
Motivation: Qubit Mapping is crucial in quantum compilation due to physical constraints on QPUs, which only allow nearest-neighbor interactions. Traditional mapping approaches often fail to leverage dependence information within circuits, leading to increased circuit latency and number of SWAP gates, thus increasing error rates.

Method: The paper introduces a new qubit mapping algorithm that uses the weight of transitive dependences. By modeling quantum circuits with affine abstractions, the algorithm can efficiently compute transitive dependences, thereby enabling new methods for partitioning circuits and assigning meaningful weights to different layers for more optimal SWAP gate insertion.

Result: The proposed algorithm was evaluated on IBM and Rigetti QPUs using benchmarks from QUEKO and QASMBench, comparing it to four baseline tools (QMAP, Sabre, Cirq, TKET). The results showed significant reductions in circuit depth and swap count, with the approach matching or exceeding the scalability of existing methods.

Conclusion: Exploiting transitive dependence information via affine abstractions enables more efficient qubit mapping. The new algorithm significantly reduces the number of SWAPs and the circuit depth on real benchmarks compared to leading baseline tools, paving the way for more reliable quantum computations under current hardware constraints.

Abstract: Qubit Mapping is a critical task in Quantum Compilation, as modern Quantum
Processing Units (QPUs) are constrained to nearest-neighbor interactions
defined by a qubit coupling graph. This compiler pass repairs the connectivity
of two-qubit gates whose operands are not adjacent by inserting SWAP gates that
move the state of qubits between directly connected qubits. Deciding when to
introduce SWAPs while minimizing their count is critical because the error in
quantum programs increases exponentially with the circuit latency, measured in
number of gates along the critical path of the circuit. Prior work for this
problem relied on heuristics and exact methods that partition the circuit into
two or more layers, but failed to exploit valuable dependence information in
any form.
  This paper introduces a novel qubit mapping algorithm based on the weight of
transitive dependences. The introduced mapper models quantum circuits with
affine abstractions thereby yielding the ability to compute transitive
dependences. In turn, the newfound information is used to partition circuits by
dependence distances and compute, efficiently, distinct weights for each layer.
We evaluate the efficiency of our mapper on IBM and Rigetti QPUs, using the
large datasets from the QUEKO and QASMBench benchmark suites, and against four
baseline tools (QMAP, Sabre, Cirq and TKET), demonstrating notable improvements
in circuit depth and swap count while delivering competitive scalability.

</details>
