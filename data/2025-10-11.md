<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 9]
- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Modeling Developer Burnout with GenAI Adoption](https://arxiv.org/abs/2510.07435)
*Zixuan Feng,Sadia Afroz,Anita Sarma*

Main category: cs.SE

TL;DR: Adopting GenAI in software development may increase burnout risk due to higher job demands, but job resources and positive perceptions can reduce this effect, potentially making GenAI adoption more beneficial than harmful.


<details>
  <summary>Details</summary>
Motivation: The motivation is to explore the potential negative impacts, specifically burnout, that Generative AI (GenAI) adoption may have on software developers, despite its productivity benefits.

Method: The authors used a concurrent embedded mixed-methods research design, surveying 442 developers and combining quantitative analysis (using PLS-SEM and regression) with qualitative analysis of open-ended responses.

Result: The study found that GenAI adoption increases burnout risk by raising job demands. However, sufficient job resources and positive perceptions of GenAI can buffer and mitigate these negative effects.

Conclusion: While GenAI can increase burnout through heightened job demands, supportive resources and an optimistic outlook on GenAI can help developers experience its adoption as a positive opportunity.

Abstract: Generative AI (GenAI) is rapidly reshaping software development workflows.
While prior studies emphasize productivity gains, the adoption of GenAI also
introduces new pressures that may harm developers' well-being. In this paper,
we investigate the relationship between the adoption of GenAI and developers'
burnout. We utilized the Job Demands--Resources (JD--R) model as the analytic
lens in our empirical study. We employed a concurrent embedded mixed-methods
research design, integrating quantitative and qualitative evidence. We first
surveyed 442 developers across diverse organizations, roles, and levels of
experience. We then employed Partial Least Squares--Structural Equation
Modeling (PLS-SEM) and regression to model the relationships among job demands,
job resources, and burnout, complemented by a qualitative analysis of
open-ended responses to contextualize the quantitative findings. Our results
show that GenAI adoption heightens burnout by increasing job demands, while job
resources and positive perceptions of GenAI mitigate these effects, reframing
adoption as an opportunity.

</details>


### [2] [HotBugs.jar: A Benchmark of Hot Fixes for Time-Critical Bugs](https://arxiv.org/abs/2510.07529)
*Carol Hanna,Federica Sarro,Mark Harman,Justyna Petke*

Main category: cs.SE

TL;DR: HotBugs$.jar is a new, comprehensive benchmark dataset of real-world, reproducible hot fixes from Apache projects, supporting rapid debugging and automated repair research in software engineering.


<details>
  <summary>Details</summary>
Motivation: There is a lack of benchmarks specifically for evaluating hot fixes, which are vital for maintaining reliability and rapid recovery in production systems.

Method: The authors mined Jira issue data from 10 active Apache projects, manually evaluated candidate patches, and packaged the validated hot fixes with associated metadata and test suites for reproducibility.

Result: Out of over 190K commits and 150K issues, 679 genuine hot fixes were identified and validated, including 110 reproducible cases, all released in the HotBugs$.jar dataset with comprehensive documentation and metadata.

Conclusion: HotBugs$.jar introduces a dedicated dataset that facilitates research and evaluation in hot fixes, providing both reproducible cases and extensive metadata for each entry.

Abstract: Hot fixes are urgent, unplanned changes deployed to production systems to
address time-critical issues. Despite their importance, no existing evaluation
benchmark focuses specifically on hot fixes. We present HotBugs$.$jar, the
first dataset dedicated to real-world hot fixes. From an initial mining of 10
active Apache projects totaling over 190K commits and 150K issue reports, we
identified 746 software patches that met our hot-fix criteria. After manual
evaluation, 679 were confirmed as genuine hot fixes, of which 110 are
reproducible using a test suite. Building upon the Bugs$.$jar framework,
HotBugs$.$jar integrates these 110 reproducible cases and makes available all
679 manually validated hot fixes, each enriched with comprehensive metadata to
support future research. Each hot fix was systematically identified using Jira
issue data, validated by independent reviewers, and packaged in a reproducible
format with buggy and fixed versions, test suites, and metadata. HotBugs$.$jar
has already been adopted as the official challenge dataset for the Search-Based
Software Engineering (SBSE) Conference Challenge Track, demonstrating its
immediate impact. This benchmark enables the study and evaluation of tools for
rapid debugging, automated repair, and production-grade resilience in modern
software systems to drive research in this essential area forward.

</details>


### [3] [RustAssure: Differential Symbolic Testing for LLM-Transpiled C-to-Rust Code](https://arxiv.org/abs/2510.07604)
*Yubo Bai,Tapti Palit*

Main category: cs.SE

TL;DR: RustAssure leverages LLMs and unique testing techniques to automatically and reliably transpile C code to safe, idiomatic Rust, achieving high compilation and semantic equivalence rates in real-world cases.


<details>
  <summary>Details</summary>
Motivation: Many existing codebases are written in unsafe memory languages like C, making them vulnerable to security issues. There is a need to safely and efficiently convert (transpile) such codebases to memory-safe languages like Rust.

Method: RustAssure uses Large Language Models (LLMs) guided by prompt engineering techniques to automatically transpile C code to idiomatic and safe Rust code. To ensure correctness, it applies differential symbolic testing to check semantic equivalence between C and Rust versions.

Result: RustAssure was evaluated on five real-world applications/libraries. It successfully generated compiling Rust code for 89.8% of C functions, and for 69.9% of these, the symbolic return values matched between C and Rust.

Conclusion: RustAssure effectively automates the transpilation of C codebases to Rust using LLMs and ensures semantic similarity via symbolic differential testing, significantly aiding code migration toward safer languages.

Abstract: Rust is a memory-safe programming language that significantly improves
software security. Existing codebases written in unsafe memory languages, such
as C, must first be transpiled to Rust to take advantage of Rust's improved
safety guarantees. RustAssure presents a system that uses Large Language Models
(LLMs) to automatically transpile existing C codebases to Rust. RustAssure uses
prompt engineering techniques to maximize the chances of the LLM generating
idiomatic and safe Rust code. Moreover, because LLMs often generate code with
subtle bugs that can be missed under traditional unit or fuzz testing,
RustAssure performs differential symbolic testing to establish the semantic
similarity between the original C and LLM-transpiled Rust code. We evaluated
RustAssure with five real-world applications and libraries, and showed that our
system is able to generate compilable Rust functions for 89.8% of all C
functions, of which 69.9% produced equivalent symbolic return values for both
the C and Rust functions.

</details>


### [4] [AppForge: From Assistant to Independent Developer -- Are GPTs Ready for Software Development?](https://arxiv.org/abs/2510.07740)
*Dezhi Ran,Yuan Cao,Mengzhou Wu,Simin Chen,Yuzhe Guo,Jun Ren,Zihe Song,Hao Yu,Jialei Wei,Linyi Li,Wei Yang,Baishakhi Ray,Tao Xie*

Main category: cs.SE

TL;DR: The study introduces APPFORGE, a benchmark to test LLMs’ ability to build complete Android apps from descriptions. Results show that top LLMs still perform poorly, with even the best model producing only 18.8% correct apps, pointing out the challenging gap between function-level code generation and real-world systems programming.


<details>
  <summary>Details</summary>
Motivation: Existing benchmarks for large language models (LLMs) in code generation focus mainly on isolated function-level tasks, but real-world software development requires reasoning about entire systems, including managing component interactions, states, lifecycles, and frameworks. There is a gap in evaluating LLMs on fully constructing whole applications.

Method: The authors introduce APPFORGE, a benchmark with 101 software development problems based on real-world Android apps. They use a multi-agent system to automatically extract functionalities from app documents and generate test cases to validate implementations. Android development experts manually verify the data, and APPFORGE incorporates an automated evaluation framework for assessment without human intervention.

Result: Evaluation of 12 high-profile LLMs, including GPT-5, shows poor performance on the task: the best result is only 18.8% functionally correct apps. This highlights the major difficulties LLMs face in comprehensive, real-world app development.

Conclusion: Current LLMs, even state-of-the-art ones, struggle to generate functionally correct, complex multi-component software from scratch. APPFORGE reveals the need for significant advances before LLMs can reliably handle whole-application software engineering tasks.

Abstract: Large language models (LLMs) have demonstrated remarkable capability in
function-level code generation tasks. Unlike isolated functions, real-world
applications demand reasoning over the entire software system: developers must
orchestrate how different components interact, maintain consistency across
states over time, and ensure the application behaves correctly within the
lifecycle and framework constraints. Yet, no existing benchmark adequately
evaluates whether LLMs can bridge this gap and construct entire software
systems from scratch. To address this gap, we propose APPFORGE, a benchmark
consisting of 101 software development problems drawn from real-world Android
apps. Given a natural language specification detailing the app functionality, a
language model is tasked with implementing the functionality into an Android
app from scratch. Developing an Android app from scratch requires understanding
and coordinating app states, lifecycle management, and asynchronous operations,
calling for LLMs to generate context-aware, robust, and maintainable code. To
construct APPFORGE, we design a multi-agent system to automatically summarize
the main functionalities from app documents and navigate the app to synthesize
test cases validating the functional correctness of app implementation.
Following rigorous manual verification by Android development experts, APPFORGE
incorporates the test cases within an automated evaluation framework that
enables reproducible assessment without human intervention, making it easily
adoptable for future research. Our evaluation on 12 flagship LLMs show that all
evaluated models achieve low effectiveness, with the best-performing model
(GPT-5) developing only 18.8% functionally correct applications, highlighting
fundamental limitations in current models' ability to handle complex,
multi-component software engineering challenges.

</details>


### [5] [Interleaved Learning and Exploration: A Self-Adaptive Fuzz Testing Framework for MLIR](https://arxiv.org/abs/2510.07815)
*Zeyu Sun,Jingjing Liang,Weiyi Wang,Chenyao Suo,Junjie Chen,Fanjiang Xu*

Main category: cs.SE

TL;DR: FLEX is an advanced fuzzing framework for MLIR, leveraging neural networks and adaptive feedback to efficiently discover more bugs and improve code coverage, outperforming existing fuzzers by a significant margin.


<details>
  <summary>Details</summary>
Motivation: Current fuzzing approaches for MLIR rely on manually crafted templates or rule-based mutations, which struggle to generate diverse and semantically valid test cases. This makes it difficult to expose subtle or deep-seated bugs in MLIR's complex code base. There is a need for more effective methods to ensure MLIR's robustness and correctness.

Method: The paper introduces FLEX, a self-adaptive fuzzing framework for MLIR. FLEX uses neural networks for program generation, a perturbed sampling strategy to encourage diversity, and a feedback-driven augmentation loop that improves its model using both crashing and non-crashing test cases. FLEX starts from a limited seed corpus and learns valid syntax and semantics over time to autonomously generate high-quality test inputs.

Result: In a 30-day campaign, FLEX discovered 80 previously unknown bugs in the upstream MLIR compiler, including new root causes and parser bugs. In 24-hour fixed-revision comparisons, FLEX detected 53 bugs, outperforming the best baseline by over 3.5x, and achieved 28.2% code coverage—42% higher than the next-best tool. Ablation studies showed the importance of perturbed generation and diversity augmentation for FLEX's success.

Conclusion: FLEX significantly improves the effectiveness of fuzz testing for MLIR by combining neural network-based generation, diversity strategies, and adaptive feedback. It finds more bugs and achieves higher code coverage than traditional fuzzers.

Abstract: MLIR (Multi-Level Intermediate Representation) has rapidly become a
foundational technology for modern compiler frameworks, enabling extensibility
across diverse domains. However, ensuring the correctness and robustness of
MLIR itself remains challenging. Existing fuzzing approaches-based on manually
crafted templates or rule-based mutations-struggle to generate sufficiently
diverse and semantically valid test cases, making it difficult to expose subtle
or deep-seated bugs within MLIR's complex and evolving code space. In this
paper, we present FLEX, a novel self-adaptive fuzzing framework for MLIR. FLEX
leverages neural networks for program generation, a perturbed sampling strategy
to encourage diversity, and a feedback-driven augmentation loop that
iteratively improves its model using both crashing and non-crashing test cases.
Starting from a limited seed corpus, FLEX progressively learns valid syntax and
semantics and autonomously produces high-quality test inputs. We evaluate FLEX
on the upstream MLIR compiler against four state-of-the-art fuzzers. In a
30-day campaign, FLEX discovers 80 previously unknown bugs-including multiple
new root causes and parser bugs-while in 24-hour fixed-revision comparisons, it
detects 53 bugs (over 3.5x as many as the best baseline) and achieves 28.2%
code coverage, outperforming the next-best tool by 42%. Ablation studies
further confirm the critical role of both perturbed generation and diversity
augmentation in FLEX's effectiveness.

</details>


### [6] [Bug Histories as Sources of Compiler Fuzzing Mutators](https://arxiv.org/abs/2510.07834)
*Lingjun Liu,Feiran Qin,Owolabi Legunsen,Marcelo d'Amorim*

Main category: cs.SE

TL;DR: By mining mutators from compiler bug reports, the paper's proposed IssueMut approach significantly improves compiler bug detection, uncovering many new and confirmed bugs missed by traditional fuzzers.


<details>
  <summary>Details</summary>
Motivation: Compiler bugs can cause major issues since compilers are critical infrastructure. Mutational fuzzers are used to find such bugs, but their effectiveness relies on the quality of mutators, and there has been no prior work on using compiler bug histories to design these mutators.

Method: The authors propose IssueMut, an approach that automatically mines mutators from compiler bug reports. These mutators are then injected into existing mutational compiler fuzzers. The researchers collected 587 mutators from 1760 GCC and LLVM bug reports and tested them by running IssueMut on these compilers with their standard test corpora.

Result: The use of 'bug history' mutators discovered 28 new bugs in GCC and 37 in LLVM, which were not found by a state-of-the-art mutational compiler fuzzer. Out of these, 60 bugs were confirmed or fixed, proving the effectiveness of the approach.

Conclusion: Mining mutators from bug histories greatly enhances the effectiveness of compiler fuzzers, indicating that bug reports contain valuable information for finding new compiler bugs. Incorporating this historical data leads to the discovery of additional significant bugs missed by existing approaches.

Abstract: Bugs in compilers, which are critical infrastructure today, can have outsized
negative impacts. Mutational fuzzers aid compiler bug detection by
systematically mutating compiler inputs, i.e., programs. Their effectiveness
depends on the quality of the mutators used. Yet, no prior work used compiler
bug histories as a source of mutators. We propose IssueMut, the first approach
for extracting compiler fuzzing mutators from bug histories. Our insight is
that bug reports contain hints about program elements that induced compiler
bugs; they can guide fuzzers towards similar bugs. IssueMut uses an automated
method to mine mutators from bug reports and retrofit such mutators into
existing mutational compiler fuzzers. Using IssueMut, we mine 587 mutators from
1760 GCC and LLVM bug reports. Then, we run IssueMut on these compilers, with
all their test inputs as seed corpora. We find that "bug history" mutators are
effective: they find new bugs that a state-of-the-art mutational compiler
fuzzer misses-28 in GCC and 37 in LLVM. Of these, 60 were confirmed or fixed,
validating our idea that bug histories have rich information that compiler
fuzzers should leverage.

</details>


### [7] [An AUTOSAR-Aligned Architectural Study of Vulnerabilities in Automotive SoC Software](https://arxiv.org/abs/2510.07941)
*Srijita Basu,Haraldsson Bengt,Miroslaw Staron,Christian Berger,Jennifer Horkoff,Magnus Almgren*

Main category: cs.SE

TL;DR: The paper systematically analyzes 180 SoC automotive vulnerabilities using an AUTOSAR-aligned architecture, identifying key patterns, root causes, and modules with delayed mitigation. It provides actionable insights to better secure SoC-based automotive systems.


<details>
  <summary>Details</summary>
Motivation: The motivation for this study is the increasing integration and complexity of System-on-Chip (SoC) platforms in Cooperative, Connected and Automated Mobility (CCAM) systems, which are safety-critical. Despite the adoption of the AUTOSAR standard to manage this complexity, security challenges persist, especially in real-time contexts. There is also a lack of systematic analysis about the root causes and impacts of vulnerabilities within AUTOSAR-aligned architectures.

Method: The study analyzes 180 publicly reported automotive SoC vulnerabilities. These vulnerabilities are mapped onto a representative SoC software architecture model aligned with AUTOSAR principles, focusing on layered abstraction and service orientation. The research identifies root causes, affected modules, and examines mitigation delays categorized by Common Weakness Enumeration (CWE) types and architectural layers.

Result: The analysis identifies 16 root causes and 56 affected software modules. It reveals dominant vulnerability patterns and certain critical modules that experience prolonged patch delays. The findings are consolidated to offer actionable recommendations for improved vulnerability detection, prioritization, and localization in SoC-based vehicle platforms.

Conclusion: Systematic analysis of real-world SoC vulnerabilities in automotive CPS platforms, following AUTOSAR principles, uncovers prevalent weaknesses, delayed patches in certain modules, and suggests practical guidance to enhance security in these safety-critical systems.

Abstract: Cooperative, Connected and Automated Mobility (CCAM) are complex
cyber-physical systems (CPS) that integrate computation, communication, and
control in safety-critical environments. At their core, System-on-Chip (SoC)
platforms consolidate processing units, communication interfaces, AI
accelerators, and security modules into a single chip. AUTOSAR (AUTomotive Open
System ARchitecture) standard was developed in the automotive domain to better
manage this complexity, defining layered software structures and interfaces to
facilitate reuse of HW/SW components. However, in practice, this integrated SoC
software architecture still poses security challenges, particularly in
real-time, safety-critical environments. Recent reports highlight a surge in
SoC-related vulnerabilities, yet systematic analysis of their root causes and
impact within AUTOSAR-aligned architectures is lacking. This study fills that
gap by analyzing 180 publicly reported automotive SoC vulnerabilities, mapped
to a representative SoC software architecture model that is aligned with
AUTOSAR principles for layered abstraction and service orientation. We identify
16 root causes and 56 affected software modules, and examine mitigation delays
across Common Weakness Enumeration (CWE) categories and architectural layers.
We uncover dominant vulnerability patterns and critical modules with prolonged
patch delays, and provide actionable insights for securing automotive CPS
platforms, including guides for improved detection, prioritization, and
localization strategies for SoC software architectures in SoC-based vehicle
platforms.

</details>


### [8] [Past, Present, and Future of Bug Tracking in the Generative AI Era](https://arxiv.org/abs/2510.08005)
*Utku Boran Torun,Mehmet Taha Demircan,Mahmut Furkan Gön,Eray Tüzün*

Main category: cs.SE

TL;DR: The paper presents an LLM-powered bug tracking system that automates reporting, triaging, and patch generation, greatly speeding up bug fixes and improving collaboration, with promised efficiency gains over traditional manual systems.


<details>
  <summary>Details</summary>
Motivation: The motivation behind this paper is to address the inefficiencies and delays caused by traditional bug tracking systems, where manual and asynchronous processes hamper the speed and effectiveness of identifying and resolving bugs. The current division of responsibilities among different stakeholders and the communication barriers between non-technical and technical teams further slow down the process, causing frustration for users.

Method: The authors propose an AI-powered bug tracking framework that leverages large language models (LLMs) to automate key phases of bug reporting, reproduction, triaging, and resolution. Users report bugs in natural language, LLM agents refine and attempt to reproduce issues, request missing information, classify and resolve invalid reports, localize and assign valid bugs, and even generate candidate patches. Human oversight ensures accuracy and quality throughout the process.

Result: By integrating LLM-powered automation into each phase of the bug tracking and resolution pipeline, the system achieves significant reductions in time-to-fix and minimizes human overhead. The approach accelerates response times, improves collaboration between users and developers, and strengthens overall software maintenance.

Conclusion: An LLM-driven automation framework for bug tracking can markedly improve traditional systems by reducing delays and human intervention, promoting more efficient software maintenance and a user-centric experience.

Abstract: Traditional bug tracking systems rely heavily on manual reporting,
reproduction, triaging, and resolution, each carried out by different
stakeholders such as end users, customer support, developers, and testers. This
division of responsibilities requires significant coordination and widens the
communication gap between non-technical users and technical teams, slowing the
process from bug discovery to resolution. Moreover, current systems are highly
asynchronous; users often wait hours or days for a first response, delaying
fixes and contributing to frustration. This paper examines the evolution of bug
tracking, from early paper-based reporting to today's web-based and SaaS
platforms. Building on this trajectory, we propose an AI-powered bug tracking
framework that augments existing tools with intelligent, large language model
(LLM)-driven automation. Our framework addresses two main challenges: reducing
time-to-fix and minimizing human overhead. Users report issues in natural
language, while AI agents refine reports, attempt reproduction, and request
missing details. Reports are then classified, invalid ones resolved through
no-code fixes, and valid ones localized and assigned to developers. LLMs also
generate candidate patches, with human oversight ensuring correctness. By
integrating automation into each phase, our framework accelerates response
times, improves collaboration, and strengthens software maintenance practices
for a more efficient, user-centric future.

</details>


### [9] [Building Whitespace-Sensitive Languages Using Whitespace-Insensitive Components](https://arxiv.org/abs/2510.08200)
*Alexander Hellwig,Nico Jansen,Bernhard Rumpe*

Main category: cs.SE

TL;DR: The paper introduces a pre-parsing technique to reuse whitespace-insensitive language modules for building whitespace-sensitive languages (like Python), improving reusability and reducing development effort in language engineering.


<details>
  <summary>Details</summary>
Motivation: The current landscape in Software Language Engineering struggles with reusability between whitespace-sensitive and whitespace-insensitive language components, leading to duplicated effort and limited library reuse. There is no established method to integrate these components efficiently.

Method: The paper proposes a pre-processing technique that allows modular, whitespace-insensitive language modules to be used for constructing whitespace-sensitive languages. This is achieved by handling whitespace transformation before the parsing phase.

Result: The approach is validated by reconstructing a simplified version of the Python programming language, demonstrating that the technique works in practice.

Conclusion: This pre-processing solution enhances the reusability of existing language components, reducing development time and improving the quality of software language products.

Abstract: In Software Language Engineering, there is a trend towards reusability by
composing modular language components. However, this reusability is severely
inhibited by a gap in integrating whitespace-sensitive and
whitespace-insensitive languages. There is currently no consistent procedure
for seamlessly reusing such language components in both cases, such that
libraries often cannot be reused, and whitespacesensitive languages are
developed from scratch. This paper presents a technique for using modular,
whitespaceinsensitive language modules to construct whitespace sensitive
languages by pre-processing language artifacts before parsing. The approach is
evaluated by reconstructing a simplified version of the programming language
Python. Our solution aims to increase the reusability of existing language
components to reduce development time and increase the overall quality of
software languages.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [10] [Type, Ability, and Effect Systems: Perspectives on Purity, Semantics, and Expressiveness](https://arxiv.org/abs/2510.07582)
*Yuyan Bao,Tiark Rompf*

Main category: cs.PL

TL;DR: The paper introduces a better way to measure and compare how programming languages enforce the separation of pure and effectful computations. It finds that existing systems each have unique strengths, and proposes a hybrid approach that combines the best aspects for more robust language design.


<details>
  <summary>Details</summary>
Motivation: Programming languages benefit from a clear separation between pure computation and effectful interaction, but existing approaches for enforcing this separation struggle with trade-offs between precision and usability. There's a need for clearer assessment and comparison of these systems.

Method: The paper proposes a semantic, type-agnostic definition of purity inspired by contextual equivalence, and uses the concept of 'degree of completeness' to measure expressiveness. It formally analyzes minimal effect and capability systems using this measure and provides a logical relation model to prove properties like purity across systems.

Result: The analysis shows that minimal meaningful effect systems and capability systems are incomparable in expressiveness; neither system fully subsumes the other. The authors then propose a hybrid system that combines type, effect, and ability systems to harness their strengths and avoid pitfalls, supported by a formal model.

Conclusion: The paper concludes that by adopting a semantic definition of purity and a new measure of expressiveness, clearer and fairer comparisons between effect typing disciplines are possible. Their proposed combination approach leverages the strengths of multiple systems, facilitating better proofs and properties.

Abstract: Programming benefits from a clear separation between pure, mathematical
computation and impure, effectful interaction with the world. Existing
approaches to enforce this separation include monads, type-and-effect systems,
and capability systems. All share a tension between precision and usability,
and each one has non-obvious strengths and weaknesses.
  This paper aims to raise the bar in assessing such systems. First, we propose
a semantic definition of purity, inspired by contextual equivalence, as a
baseline independent of any specific typing discipline. Second, we propose that
expressiveness should be measured by the degree of completeness, i.e., how many
semantically pure terms can be typed as pure. Using this measure, we focus on
minimal meaningful effect and capability systems and show that they are
incomparable, i.e., neither subsumes the other in terms of expressiveness.
  Based on this result, we propose a synthesis and show that type, ability, and
effect systems combine their respective strengths while avoiding their
weaknesses. As part of our formal model, we provide a logical relation to
facilitate proofs of purity and other properties for a variety of effect typing
disciplines.

</details>


### [11] [The Functional Machine Calculus III: Control](https://arxiv.org/abs/2510.07851)
*Willem Heijltjes*

Main category: cs.PL

TL;DR: The paper extends the Functional Machine Calculus to include imperative branching and looping constructs, enabling it to model both functional and imperative languages faithfully, while retaining strong theoretical guarantees like confluence and strong normalization.


<details>
  <summary>Details</summary>
Motivation: To unify imperative and functional programming paradigms by extending the lambda-calculus to naturally support effects, control flow, and imperative constructs, while maintaining desirable properties like strong normalization and confluence.

Method: The paper extends the Functional Machine Calculus by defining a simple operational semantics, based on the Krivine machine with enhancements such as multiple operand stacks and a continuation stack, to model branching, looping, and effects.

Result: The calculus now supports not just sequential computation but also branching and looping control flow, allowing the embedding of a complete imperative language with constructs like conditionals, iterations, exceptions, constants, and algebraic data types, all while preserving key properties like confluent reduction and strong normalization (without iteration).

Conclusion: The new approach offers a unified model for functional and imperative computation, with a sound operational semantics and type system, making it possible to faithfully represent both paradigms within a single framework.

Abstract: The Functional Machine Calculus (Heijltjes 2022) is a new approach to
unifying the imperative and functional programming paradigms. It extends the
lambda-calculus, preserving the key features of confluent reduction and typed
termination, to embed computational effects, evaluation strategies, and control
flow operations. The first instalment modelled sequential higher-order
computation with global store, input/output, probabilities, and
non-determinism, and embedded both the call-by-name and call-by-value
lambda-calculus, as well as Moggi's computational metalanguage and Levy's
call-by-push-value. The present paper extends the calculus from sequential to
branching and looping control flow. This allows the faithful embedding of a
minimal but complete imperative language, including conditionals, exception
handling, and iteration, as well as constants and algebraic data types.
  The calculus is defined through a simple operational semantics, extending the
(simplified) Krivine machine for the lambda-calculus with multiple operand
stacks to model effects and a continuation stack to model sequential,
branching, and looping computation. It features a confluent reduction relation
and a system of simple types that guarantees termination of the machine and
strong normalization of reduction (in the absence of iteration). These
properties carry over to the embedded imperative language, providing a unified
functional-imperative model of computation that supports simple types, a direct
and intuitive operational semantics, and a confluent reduction semantics.

</details>
