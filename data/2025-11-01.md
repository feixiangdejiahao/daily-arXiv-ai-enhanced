<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 18]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Internal Vulnerabilities, External Threats: A Grounded Framework for Enterprise Open Source Risk Governance](https://arxiv.org/abs/2510.25882)
*Wenhao Yang,Minghui Zhou,Daniel Izquierdo Cortázar,Yehui Wang*

Main category: cs.SE

TL;DR: Traditional technical risk management is insufficient for open source adoption in enterprises due to systemic and governance risks. This paper develops and validates a holistic risk governance framework, including decision models, taxonomies, and actionable mitigation strategies, to proactively address these threats.


<details>
  <summary>Details</summary>
Motivation: Traditional risk management practices in enterprises engaging with open source software are too narrowly focused on technical risks, leaving them vulnerable to systemic and governance-related threats that are not captured by existing tools.

Method: A grounded theory study was conducted with 15 practitioners to develop a holistic risk governance framework. The framework is formalized through an analytical logic chain (Objectives -> Threats -> Vulnerabilities -> Mitigation) and validated with retrospective case studies from three industry experts.

Result: The paper introduces a Strategic Objectives Matrix for clarifying enterprise goals, a dual taxonomy of external threats and internal vulnerabilities, and an actionable mitigation framework. These tools offer a comprehensive approach for enterprises to assess and address risks in open source engagement.

Conclusion: Enterprises need to move beyond tactical, technical risk management towards holistic risk governance. The proposed framework enables organizations to systematically identify, analyze, and mitigate complex risks associated with open source by building an organizational 'immune system.'

Abstract: Enterprise engagement with open source has evolved from tactical adoption to
strategic deep integration, exposing them to a complex risk landscape far
beyond mere code. However, traditional risk management, narrowly focused on
technical tools, is structurally inadequate for systemic threats like upstream
"silent fixes", community conflicts, or sudden license changes, creating a
dangerous governance blind spot. To address this governance vacuum and enable
the necessary shift from tactical risk management to holistic risk governance,
we conducted a grounded theory study with 15 practitioners to develop a
holistic risk governance framework. Our study formalizes an analytical
framework built on a foundational risk principle: an uncontrollable External
Threat (e.g., a sudden license change in a key dependency) only becomes a
critical risk when it exploits a controllable Internal Vulnerability (e.g., an
undefined risk appetite for single-vendor projects), which then amplifies the
impact.The framework operationalizes this principle through a clear logical
chain: "Objectives -> Threats -> Vulnerabilities -> Mitigation" (OTVM). This
provides a holistic decision model that transcends mere technical checklists.
Based on this logic, our contributions are: (1) a "Strategic Objectives Matrix"
to clarify goals; (2) a systematic dual taxonomy of External Threats (Ex-Tech,
Ex-Comm, Ex-Eco) and Internal Vulnerabilities (In-Strat, In-Ops, In-Tech); and
(3) an actionable mitigation framework mapping capability-building to these
vulnerabilities. The framework's analytical utility was validated by three
industry experts through retrospective case studies on real-world incidents.
This work provides a novel diagnostic lens and a systematic path for
enterprises to shift from reactive "firefighting" to proactively building an
organizational "immune system".

</details>


### [2] [PRISM: Proof-Carrying Artifact Generation through LLM x MDE Synergy and Stratified Constraints](https://arxiv.org/abs/2510.25890)
*Tong Ma,Hui Lai,Hui Wang,Zhenhu Tian,Jizhou Wang,Haichao Wu,Yongfan Gao,Chaochao Li,Fengjie Xu,Ling Fang*

Main category: cs.SE

TL;DR: PRISM merges LLMs with model-driven engineering to automate generation of compliance-ready, validated artifacts for safety-critical domains, demonstrating effectiveness in automotive and legal scenarios while reducing manual checks.


<details>
  <summary>Details</summary>
Motivation: Ensuring regulator-ready and machine-checkable evidence for safety- and compliance-critical domains is challenging, often requiring labor-intensive manual validation and remediation. Automating this process is crucial to streamline compliance and safety assurance.

Method: PRISM combines a Unified Meta-Model (UMM) for semantic reconciliation, an Integrated Constraint Model (ICM) for enforcement, and Constraint-Guided Verifiable Generation (CVG) for two-layer constraint-driven artifact generation and validation.

Result: The system was evaluated in automotive software engineering (AUTOSAR) and cross-border legal jurisdiction (Brussels I bis). PRISM succeeded in producing valid, auditable artifacts suitable for compliance, significantly reducing manual effort required.

Conclusion: PRISM yields structurally valid, auditable artifacts compatible with current tooling, greatly minimizing the need for manual corrections and paving the way for automated artifact generation with integrated assurance.

Abstract: PRISM unifies Large Language Models with Model-Driven Engineering to generate
regulator-ready artifacts and machine-checkable evidence for safety- and
compliance-critical domains. PRISM integrates three pillars: a Unified
Meta-Model (UMM) reconciles heterogeneous schemas and regulatory text into a
single semantic space; an Integrated Constraint Model (ICM) compiles structural
and semantic requirements into enforcement artifacts including generation-time
automata (GBNF, DFA) and post-generation validators (e.g., SHACL, SMT); and
Constraint-Guided Verifiable Generation (CVG) applies these through two-layer
enforcement - structural constraints drive prefix-safe decoding while
semantic/logical validation produces machine-checkable certificates. When
violations occur, PRISM performs audit-guided repair and records generation
traces for compliance review. We evaluate PRISM in automotive software
engineering (AUTOSAR) and cross-border legal jurisdiction (Brussels I bis).
PRISM produces structurally valid, auditable artifacts that integrate with
existing tooling and substantially reduce manual remediation effort, providing
a practical path toward automated artifact generation with built-in assurance.

</details>


### [3] [CHCVerif: A Portfolio-Based Solver for Constrained Horn Clauses](https://arxiv.org/abs/2510.26431)
*Mihály Dobos-Kovács,Levente Bajczi,András Vörös*

Main category: cs.SE

TL;DR: The paper presents CHCVERIF, a CHC solver that leverages existing software verification tools via a portfolio approach. While it isn't outstanding for all cases, particularly linear arithmetic, it shows promise for bitvector problems and highlights the potential of integrating verification tools into CHC solving.


<details>
  <summary>Details</summary>
Motivation: CHCs are important for verification tasks but existing solvers may struggle, especially with low-level semantics like bitvectors. There's a need for improved CHC solving, leveraging mature tools.

Method: CHCVERIF is proposed—a solver that uses a portfolio approach and repurposes established software verification tools to solve CHCs.

Result: CHCVERIF shows moderate success in linear integer arithmetic and modest success with bitvectors. It demonstrates that software verification tools can serve as effective backends for CHC solving when used in a portfolio.

Conclusion: Software verification tools can be effectively reused for CHC solving, especially with a carefully selected portfolio, expanding opportunities for benchmarks involving low-level semantics.

Abstract: Constrained Horn Clauses (CHCs) are widely adopted as intermediate
representations for a variety of verification tasks, including safety checking,
invariant synthesis, and interprocedural analysis. This paper introduces
CHCVERIF, a portfolio-based CHC solver that adopts a software verification
approach for solving CHCs. This approach enables us to reuse mature software
verification tools to tackle CHC benchmarks, particularly those involving
bitvectors and low-level semantics. Our evaluation shows that while the method
enjoys only moderate success with linear integer arithmetic, it achieves modest
success on bitvector benchmarks. Moreover, our results demonstrate the
viability and potential of using software verification tools as backends for
CHC solving, particularly when supported by a carefully constructed portfolio.

</details>


### [4] [A Process Mining-Based System For The Analysis and Prediction of Software Development Workflows](https://arxiv.org/abs/2510.25935)
*Antía Dorado,Iván Folgueira,Sofía Martín,Gonzalo Martín,Álvaro Porto,Alejandro Ramos,John Wallace*

Main category: cs.SE

TL;DR: CodeSight combines process mining of GitHub data with an LSTM model to accurately predict if pull requests will meet their deadlines, helping teams identify risks early and improve workflow efficiency.


<details>
  <summary>Details</summary>
Motivation: Monitoring and managing deadline compliance in software projects is challenging due to complex workflows and dynamic activities. Early identification of potential deadline breaches can improve project outcomes and efficiency.

Method: CodeSight automatically collects and converts GitHub development and deployment data into process mining logs, analyzes workflow metrics, and uses an LSTM machine learning model to predict remaining PR (pull request) resolution times based on activity traces and static features.

Result: CodeSight achieves high precision and F1 scores in predicting whether PRs will comply with deadlines, enabling proactive identification of potential deadline breaches in software development workflows.

Conclusion: Integrating process mining and machine learning enables accurate prediction of deadline compliance in software projects, supporting early intervention and improved project management.

Abstract: CodeSight is an end-to-end system designed to anticipate deadline compliance
in software development workflows. It captures development and deployment data
directly from GitHub, transforming it into process mining logs for detailed
analysis. From these logs, the system generates metrics and dashboards that
provide actionable insights into PR activity patterns and workflow efficiency.
Building on this structured representation, CodeSight employs an LSTM model
that predicts remaining PR resolution times based on sequential activity traces
and static features, enabling early identification of potential deadline
breaches. In tests, the system demonstrates high precision and F1 scores in
predicting deadline compliance, illustrating the value of integrating process
mining with machine learning for proactive software project management.

</details>


### [5] [Beyond Synthetic Benchmarks: Evaluating LLM Performance on Real-World Class-Level Code Generation](https://arxiv.org/abs/2510.26130)
*Musfiqur Rahman,SayedHassan Khatoonabadi,Emad Shihab*

Main category: cs.SE

TL;DR: LLMs succeed at generating correct code for synthetic functions, but their real-world class-level code generation lags far behind. More documentation and retrieval-augmented generation improve results slightly, but major type and attribute errors persist. The study exposes a large gap between synthetic and real-world performance, with clear implications for future LLM development.


<details>
  <summary>Details</summary>
Motivation: While large language models (LLMs) have shown strong ability in code generation at the function level, their effectiveness on more complex, real-world class-level code in genuine software development settings has not been thoroughly explored. The paper seeks to fill this gap by evaluating LLM performance on authentic software classes rather than stylized function benchmarks.

Method: The authors created a benchmark of real-world Python classes from open-source repositories, dividing them into seen (familiar) and unseen (novel) partitions. They assessed several LLMs using different input specification styles, degrees of documentation completeness, and with/without retrieval-augmented generation. The team measured functional correctness and analyzed error types to understand where and why LLMs fail.

Result: LLMs perform very well on synthetic benchmarks (84–89% correctness) but struggle on real-world class-level code (25–34% correctness), regardless of whether the codebase is novel or familiar to the model. More comprehensive documentation slightly improves results (1–3%), but retrieval-augmented methods that supplement code context with concrete examples yield more significant gains (4–7%). Dominant errors in real tasks are type and attribute issues, which differ from the assertion errors overrepresented in synthetic tests. Retrieval helps logical correctness but can create new dependency problems.

Conclusion: Current LLMs are significantly limited in real-world class-level code generation. Improving context modeling, documentation strategies, and especially retrieval-based methods are necessary to bridge the performance gap observed between synthetic and practical scenarios. The results provide a critical research direction for developing more robust AI code assistants.

Abstract: Large language models (LLMs) have advanced code generation at the function
level, yet their ability to produce correct class-level implementations in
authentic software projects remains poorly understood. This work introduces a
novel benchmark derived from open-source repositories, comprising real-world
classes divided into seen and unseen partitions to evaluate generalization
under practical conditions. The evaluation examines multiple LLMs under varied
input specifications, retrieval-augmented configurations, and documentation
completeness levels.
  Results reveal a stark performance disparity: LLMs achieve 84% to 89%
correctness on established synthetic benchmarks but only 25% to 34% on
real-world class tasks, with negligible differences between familiar and novel
codebases. Comprehensive docstrings yield modest gains of 1% to 3% in
functional accuracy, though statistical significance is rare.
Retrieval-augmented generation proves most effective with partial
documentation, improving correctness by 4% to 7% by supplying concrete
implementation patterns absent from specifications. Error profiling identifies
AttributeError, TypeError, and AssertionError as dominant failure modes (84% of
cases), with synthetic tests overemphasizing assertion issues and real-world
scenarios highlighting type and attribute mismatches. Retrieval augmentation
reduces logical flaws but can introduce dependency conflicts.
  The benchmark and analysis expose critical limitations in current LLM
capabilities for class-level engineering, offering actionable insights for
enhancing context modelling, documentation strategies, and retrieval
integration in production code assistance tools.

</details>


### [6] [Reduction of Test Re-runs by Prioritizing Potential Order Dependent Flaky Tests](https://arxiv.org/abs/2510.26171)
*Hasnain Iqbal,Zerina Begum,Kazi Sakib*

Main category: cs.SE

TL;DR: This paper introduces a static field analysis technique that prioritizes order-dependent (OD) flaky tests in software projects, cutting down on unnecessary test runs and improving CI efficiency.


<details>
  <summary>Details</summary>
Motivation: Flaky tests undermine the reliability of automated software testing, particularly within CI/CD pipelines, yet do not necessarily indicate actual faults. Detecting and repairing order-dependent (OD) flaky tests typically require many re-runs, increasing cost and inefficiency.

Method: The authors propose a novel prioritization method for identifying potential OD tests by analyzing shared static fields in test classes, which are likely sources of order-dependence.

Result: In experiments on 27 project modules, their approach successfully prioritized all OD tests in 23 cases, reducing test executions by 65.92% and unnecessary re-runs by 72.19%.

Conclusion: The proposed static analysis-based prioritization method significantly reduces the resources needed to detect OD flaky tests, making CI pipelines more efficient and reliable.

Abstract: Flaky tests can make automated software testing unreliable due to their
unpredictable behavior. These tests can pass or fail on the same code base on
multiple runs. However, flaky tests often do not refer to any fault, even
though they can cause the continuous integration (CI) pipeline to fail. A
common type of flaky test is the order-dependent (OD) test. The outcome of an
OD test depends on the order in which it is run with respect to other test
cases. Several studies have explored the detection and repair of OD tests.
However, their methods require re-runs of tests multiple times, that are not
related to the order dependence. Hence, prioritizing potential OD tests is
necessary to reduce the re-runs. In this paper, we propose a method to
prioritize potential order-dependent tests. By analyzing shared static fields
in test classes, we identify tests that are more likely to be order-dependent.
In our experiment on 27 project modules, our method successfully prioritized
all OD tests in 23 cases, reducing test executions by an average of 65.92% and
unnecessary re-runs by 72.19%. These results demonstrate that our approach
significantly improves the efficiency of OD test detection by lowering
execution costs.

</details>


### [7] [The "4W+1H" of Software Supply Chain Security Checklist for Critical Infrastructure](https://arxiv.org/abs/2510.26174)
*Liming Dong,Sung Une Lee,Zhenchang Xing,Muhammad Ejaz Ahmed,Stefan Avgoustakis*

Main category: cs.SE

TL;DR: This paper reviews global and Australian software supply chain security frameworks, highlights gaps for critical infrastructure sectors, and introduces a checklist to help stakeholders address evolving risks more effectively.


<details>
  <summary>Details</summary>
Motivation: Frequent and sophisticated software supply chain attacks are a growing threat to critical infrastructure, and current security frameworks are fragmented and insufficient for these sectors.

Method: A multivocal literature review was conducted spanning international frameworks, Australian regulations, and academic studies. The “4W+1H” analytical approach was used to map and synthesize practices.

Result: Ten core categories of security practices were identified and systematically mapped. An actionable, multi-layered checklist of 80 questions was created to help stakeholders evaluate and improve their security posture.

Conclusion: There are significant gaps between existing software supply chain security frameworks and the sector-specific needs of critical infrastructure. A more integrated, context-aware approach is required to effectively address evolving risks.

Abstract: The increasing frequency and sophistication of software supply chain attacks
pose severe risks to critical infrastructure sectors, threatening national
security, economic stability, and public safety. Despite growing awareness,
existing security practices remain fragmented and insufficient, with most
frameworks narrowly focused on isolated life cycle stages or lacking alignment
with the specific needs of critical infrastructure (CI) sectors. In this paper,
we conducted a multivocal literature review across international frameworks,
Australian regulatory sources, and academic studies to identify and analyze
security practices across the software supply chain, especially specific CI
sector. Our analysis found that few existing frameworks are explicitly tailored
to CI domains. We systematically leveraged identified software supply chain
security frameworks, using a "4W+1H" analytical approach, we synthesized ten
core categories (what) of software supply chain security practices, mapped them
across life-cycle phases (when), stakeholder roles (who), and implementation
levels (how), and examined their coverage across existing frameworks (where).
Building on these insights, the paper culminates in structured, multi-layered
checklist of 80 questions designed to relevant stakeholders evaluate and
enhance their software supply chain security. Our findings reveal gaps between
framework guidance and sector-specific needs, highlight the need for
integrated, context-aware approaches to safeguard critical infrastructure from
evolving software supply chain risks.

</details>


### [8] [A Research Roadmap for Augmenting Software Engineering Processes and Software Products with Generative AI](https://arxiv.org/abs/2510.26275)
*Domenico Amalfitano,Andreas Metzger,Marco Autili,Tommaso Fulcini,Tobias Hey,Jan Keim,Patrizio Pelliccione,Vincenzo Scotti,Anne Koziolek,Raffaela Mirandola,Andreas Vogelsang*

Main category: cs.SE

TL;DR: The paper creates a validated roadmap for how generative AI will shape software engineering, outlines four augmentation types, research challenges, future directions, and predicts key changes in the field by 2030.


<details>
  <summary>Details</summary>
Motivation: Generative AI is quickly changing the landscape of software engineering, impacting various processes and outcomes. There is a need for a structured roadmap to understand and guide the integration of GenAI into software engineering, and to identify research challenges and opportunities.

Method: The authors employed design science research with three iterative cycles, integrating evidence from workshop discussions, literature reviews, and peer feedback. McLuhan's tetrads were used as a conceptual tool to analyze GenAI's impact. The study cross-validated results with independent teams for rigor.

Result: The paper presents a roadmap identifying four key types of GenAI augmentation in software engineering, detailing associated research challenges and opportunities. These are consolidated into future research directions, with ten predictions for the state of software engineering in 2030.

Conclusion: The study offers a transparent and reproducible roadmap to understand and analyze GenAI's transformative influence on software engineering, providing a basis for guiding future research and development in GenAI-augmented SE.

Abstract: Generative AI (GenAI) is rapidly transforming software engineering (SE)
practices, influencing how SE processes are executed, as well as how software
systems are developed, operated, and evolved. This paper applies design science
research to build a roadmap for GenAI-augmented SE. The process consists of
three cycles that incrementally integrate multiple sources of evidence,
including collaborative discussions from the FSE 2025 "Software Engineering
2030" workshop, rapid literature reviews, and external feedback sessions
involving peers. McLuhan's tetrads were used as a conceptual instrument to
systematically capture the transforming effects of GenAI on SE processes and
software products.The resulting roadmap identifies four fundamental forms of
GenAI augmentation in SE and systematically characterizes their related
research challenges and opportunities. These insights are then consolidated
into a set of future research directions. By grounding the roadmap in a
rigorous multi-cycle process and cross-validating it among independent author
teams and peers, the study provides a transparent and reproducible foundation
for analyzing how GenAI affects SE processes, methods and tools, and for
framing future research within this rapidly evolving area. Based on these
findings, the article finally makes ten predictions for SE in the year 2030.

</details>


### [9] [Empowering RepoQA-Agent based on Reinforcement Learning Driven by Monte-carlo Tree Search](https://arxiv.org/abs/2510.26287)
*Guochang Li,Yuchen Liu,Zhen Qin,Yunkun Wang,Jianping Zhong,Chen Zhi,Binhua Li,Fei Huang,Yongbin Li,Shuiguang Deng*

Main category: cs.SE

TL;DR: RepoSearch-R1 uses MCTS for reinforcement learning to help LLM agents answer repository questions more completely and efficiently, sidestepping data compliance issues and outperforming previous methods.


<details>
  <summary>Details</summary>
Motivation: Existing LLM-based approaches for code repository reasoning suffer from poor guidance in tool use and decision-making or rely on costly model distillation and data sharing that cause compliance problems in enterprise scenarios. The need for an agentic, efficient, and compliant method motivates this work.

Method: The paper introduces RepoSearch-R1, an agentic reinforcement learning framework leveraging Monte-carlo Tree Search (MCTS) for generating diverse reasoning paths in multi-turn tool interactions. This enables self-training without data from external sources, thus eschewing model distillation and supervision. A specialized RepoQA-Agent is constructed for repository question-answering tasks using this framework.

Result: RepoSearch-R1 shows marked improvements: a 16% increase in answer completeness over no-retrieval baselines, 19.5% over iterative retrieval, and a 33% boost in training efficiency compared to prior agentic RL methods. Its cold-start approach avoids compliance risks while preserving reasoning diversity and answer accuracy.

Conclusion: RepoSearch-R1 successfully overcomes limitations of previous repository-level software engineering approaches by enabling agents to self-train safely and efficiently, achieving superior answer completeness and training efficiency without reliance on external large models or supervision.

Abstract: Repository-level software engineering tasks require large language models
(LLMs) to efficiently navigate and extract information from complex codebases
through multi-turn tool interactions. Existing approaches face significant
limitations: training-free, in-context learning methods struggle to guide
agents effectively in tool utilization and decision-making based on
environmental feedback, while training-based approaches typically rely on
costly distillation from larger LLMs, introducing data compliance concerns in
enterprise environments. To address these challenges, we introduce
RepoSearch-R1, a novel agentic reinforcement learning framework driven by
Monte-carlo Tree Search (MCTS). This approach allows agents to generate
diverse, high-quality reasoning trajectories via self-training without
requiring model distillation or external supervision. Based on RepoSearch-R1,
we construct a RepoQA-Agent specifically designed for repository
question-answering tasks. Comprehensive evaluation on repository
question-answering tasks demonstrates that RepoSearch-R1 achieves substantial
improvements of answer completeness: 16.0% enhancement over no-retrieval
methods, 19.5% improvement over iterative retrieval methods, and 33% increase
in training efficiency compared to general agentic reinforcement learning
approaches. Our cold-start training methodology eliminates data compliance
concerns while maintaining robust exploration diversity and answer completeness
across repository-level reasoning tasks.

</details>


### [10] [Environmental Impact of CI/CD Pipelines](https://arxiv.org/abs/2510.26413)
*Nuno Saavedra,Alexandra Mendes,João F. Ferreira*

Main category: cs.SE

TL;DR: This paper quantifies GitHub Actions’ carbon and water footprints using the largest-ever dataset of workflow runs, showing substantial environmental impact, and recommends ways to reduce it by better resource management and strategic runner deployment.


<details>
  <summary>Details</summary>
Motivation: Developers are generally unaware of the environmental impact of CI/CD pipelines, as service providers do not disclose carbon and water footprint data. Given the increasing environmental impact of cloud computing, understanding and mitigating these effects is crucial.

Method: The study applies methodology from the Cloud Carbon Footprint framework and analyzes over 2.2 million workflow runs from 18,000+ repositories, making it the largest dataset used for this purpose.

Result: The estimated carbon footprint of GitHub Actions in 2024 ranges from 150.5 to 994.9 MTCO2e, with a most likely scenario of 456.9 MTCO2e. Water footprint estimates range from 1,989.6 to 37,664.5 kiloliters, with a most likely scenario of 5,738.2 kiloliters. Mitigation strategies are suggested, such as optimizing runner geographic location, managing scheduled runs, and reducing repository size.

Conclusion: GitHub Actions has a significant carbon and water footprint. It is possible to mitigate this impact by optimizing resource use and making strategic choices about runner deployment.

Abstract: CI/CD pipelines are widely used in software development, yet their
environmental impact, particularly carbon and water footprints (CWF), remains
largely unknown to developers, as CI service providers typically do not
disclose such information. With the growing environmental impact of cloud
computing, understanding the CWF of CI/CD services has become increasingly
important.
  This work investigates the CWF of using GitHub Actions, focusing on
open-source repositories where usage is free and unlimited for standard
runners. We build upon a methodology from the Cloud Carbon Footprint framework
and we use the largest dataset of workflow runs reported in the literature to
date, comprising over 2.2 million workflow runs from more than 18,000
repositories.
  Our analysis reveals that the GitHub Actions ecosystem results in a
substantial CWF. Our estimates for the carbon footprint in 2024 range from
150.5 MTCO2e in the most optimistic scenario to 994.9 MTCO2e in the most
pessimistic scenario, while the water footprint ranges from 1,989.6 to 37,664.5
kiloliters. The most likely scenario estimates are 456.9 MTCO2e for carbon
footprint and 5,738.2 kiloliters for water footprint. To provide perspective,
the carbon footprint in the most likely scenario is equivalent to the carbon
captured by 7,615 urban trees in a year, and the water footprint is comparable
to the water consumed by an average American family over 5,053 years.
  We explore strategies to mitigate this impact, primarily by reducing wasted
computational resources. Key recommendations include deploying runners in
regions whose energy production has a low environmental impact such as France
and the United Kingdom, implementing stricter deactivation policies for
scheduled runs and aligning their execution with periods when the regional
energy mix is more environmentally favorable, and reducing the size of
repositories.

</details>


### [11] [Nexus: Execution-Grounded Multi-Agent Test Oracle Synthesis](https://arxiv.org/abs/2510.26423)
*Dong Huang,Mingzhe Du,Jie M. Zhang,Zheng Lin,Meng Luo,Qianru Zhang,See-Kiong Ng*

Main category: cs.SE

TL;DR: Nexus is a multi-agent framework for generating more accurate software test oracles. By combining specialist agents, collaborative critique, and an automated refinement loop, Nexus produces better test oracles, leading to higher bug detection and program repair success than existing baselines.


<details>
  <summary>Details</summary>
Motivation: Test oracle generation is a difficult and long-standing problem in non-regression testing, where reliable testing depends on accurately distinguishing intended from unintended software behavior. Existing methods often lack accuracy and robustness for automated oracle generation.

Method: Nexus introduces a multi-agent framework, where four specialized agents with different testing philosophies collaboratively critique, refine, and validate generated test oracles. After initial generation, candidate oracles are tested against plausible implementations in a secure sandbox, with an automated self-refinement loop fixing incorrect oracles using runtime errors from validation.

Result: Experiments show that Nexus outperforms prior state-of-the-art methods on seven benchmarks. For example, oracle accuracy on LiveCodeBench increases from 46.30% to 57.73% for GPT-4.1-Mini. Bug detection on HumanEval rises from 90.91% to 95.45%, and program repair success improves from 35.23% to 69.32%.

Conclusion: Nexus's multi-agent deliberation and automated refinement strategy substantially boost test oracle accuracy and robustness, improving bug detection and automated program repair success rates over previous systems.

Abstract: Test oracle generation in non-regression testing is a longstanding challenge
in software engineering, where the goal is to produce oracles that can
accurately determine whether a function under test (FUT) behaves as intended
for a given input. In this paper, we introduce Nexus, a novel multi-agent
framework to address this challenge. Nexus generates test oracles by leveraging
a diverse set of specialized agents that synthesize test oracles through a
structured process of deliberation, validation, and iterative self-refinement.
During the deliberation phase, a panel of four specialist agents, each
embodying a distinct testing philosophy, collaboratively critiques and refines
an initial set of test oracles. Then, in the validation phase, Nexus generates
a plausible candidate implementation of the FUT and executes the proposed
oracles against it in a secure sandbox. For any oracle that fails this
execution-based check, Nexus activates an automated selfrefinement loop, using
the specific runtime error to debug and correct the oracle before
re-validation. Our extensive evaluation on seven diverse benchmarks
demonstrates that Nexus consistently and substantially outperforms
state-of-theart baselines. For instance, Nexus improves the test-level oracle
accuracy on the LiveCodeBench from 46.30% to 57.73% for GPT-4.1-Mini. The
improved accuracy also significantly enhances downstream tasks: the bug
detection rate of GPT4.1-Mini generated test oracles on HumanEval increases
from 90.91% to 95.45% for Nexus compared to baselines, and the success rate of
automated program repair improves from 35.23% to 69.32%.

</details>


### [12] [SecureReviewer: Enhancing Large Language Models for Secure Code Review through Secure-aware Fine-tuning](https://arxiv.org/abs/2510.26457)
*Fang Liu,Simiao Liu,Yinghao Zhu,Xiaoli Lian,Li Zhang*

Main category: cs.SE

TL;DR: SecureReviewer is a new approach for LLM-based code review that improves detection and resolution of security issues. It uses a unique dataset, fine-tuning strategies, RAG for domain grounding, and a security-specific metric, leading to superior results over existing methods.


<details>
  <summary>Details</summary>
Motivation: Current automated code review tools, especially those using LLMs, are not sufficiently effective in identifying and resolving security issues, partly due to a lack of specialized datasets and suitable evaluation metrics.

Method: The authors propose SecureReviewer, which involves constructing a security-focused code review dataset, fine-tuning LLMs with a secure-aware strategy for generating security-related review comments, integrating Retrieval-Augmented Generation (RAG) to reduce hallucination and increase reliability, and introducing a new evaluation metric called SecureBLEU.

Result: Their experimental results show that SecureReviewer surpasses existing automated code review methods in both the accuracy of detecting security issues and the quality and usefulness of the review comments generated.

Conclusion: SecureReviewer enhances the effectiveness of LLM-based code review for security issues by combining specialized datasets, secure-focused fine-tuning, RAG, and secure-aware evaluation metrics. This approach achieves superior performance compared to current state-of-the-art baselines.

Abstract: Identifying and addressing security issues during the early phase of the
development lifecycle is critical for mitigating the long-term negative impacts
on software systems. Code review serves as an effective practice that enables
developers to check their teammates' code before integration into the codebase.
To streamline the generation of review comments, various automated code review
approaches have been proposed, where LLM-based methods have significantly
advanced the capabilities of automated review generation. However, existing
models primarily focus on general-purpose code review, their effectiveness in
identifying and addressing security-related issues remains underexplored.
Moreover, adapting existing code review approaches to target security issues
faces substantial challenges, including data scarcity and inadequate evaluation
metrics. To address these limitations, we propose SecureReviewer, a new
approach designed for enhancing LLMs' ability to identify and resolve
security-related issues during code review. Specifically, we first construct a
dataset tailored for training and evaluating secure code review capabilities.
Leveraging this dataset, we fine-tune LLMs to generate code review comments
that can effectively identify security issues and provide fix suggestions with
our proposed secure-aware fine-tuning strategy. To mitigate hallucination in
LLMs and enhance the reliability of their outputs, we integrate the RAG
technique, which grounds the generated comments in domain-specific security
knowledge. Additionally, we introduce SecureBLEU, a new evaluation metric
designed to assess the effectiveness of review comments in addressing security
issues. Experimental results demonstrate that SecureReviewer outperforms
state-of-the-art baselines in both security issue detection accuracy and the
overall quality and practical utility of generated review comments.

</details>


### [13] [Automated Extract Method Refactoring with Open-Source LLMs: A Comparative Study](https://arxiv.org/abs/2510.26480)
*Sivajeet Chand,Melih Kilic,Roland Würsching,Sushant Kumar Pandey,Alexander Pretschner*

Main category: cs.SE

TL;DR: Open-source LLMs, guided by Recursive criticism and improvement prompting, substantially improve automated Extract Method refactoring. Best models achieved strong code correctness and quality, with high developer acceptance, suggesting human-in-the-loop evaluation is vital for refining metrics and outcomes.


<details>
  <summary>Details</summary>
Motivation: Automating Extract Method refactoring remains difficult and largely manual, even though it is crucial for code readability and maintainability. Resource-efficient open-source LLMs may provide effective automation for this high-level software engineering task.

Method: The authors systematically evaluated five open-source LLMs (3B–8B parameters) on Python EMR tasks using automated metrics (test pass percentage, code quality stats) and developer survey feedback, comparing one-shot and Recursive criticism and improvement prompting strategies.

Result: RCI-based prompting had higher test pass rates and improved code quality. Deepseek-Coder-RCI and Qwen2.5-Coder-RCI reduced method LOC and cyclomatic complexity, with over 70% developer acceptance. Qwen2.5-Coder was rated highest by developers, while traditional metrics did not always align with developer preferences. The authors provide an open-source benchmark for future research.

Conclusion: RCI-based prompting with open-source LLMs significantly improves automated Extract Method refactoring performance, surpassing traditional one-shot methods in functional correctness, code quality, and human acceptance.

Abstract: Automating the Extract Method refactoring (EMR) remains challenging and
largely manual despite its importance in improving code readability and
maintainability. Recent advances in open-source, resource-efficient Large
Language Models (LLMs) offer promising new approaches for automating such
high-level tasks. In this work, we critically evaluate five state-of-the-art
open-source LLMs, spanning 3B to 8B parameter sizes, on the EMR task for Python
code. We systematically assess functional correctness and code quality using
automated metrics and investigate the impact of prompting strategies by
comparing one-shot prompting to a Recursive criticism and improvement (RCI)
approach. RCI-based prompting consistently outperforms one-shot prompting in
test pass rates and refactoring quality. The best-performing models,
Deepseek-Coder-RCI and Qwen2.5-Coder-RCI, achieve test pass percentage (TPP)
scores of 0.829 and 0.808, while reducing lines of code (LOC) per method from
12.103 to 6.192 and 5.577, and cyclomatic complexity (CC) from 4.602 to 3.453
and 3.294, respectively. A developer survey on RCI-generated refactorings shows
over 70% acceptance, with Qwen2.5-Coder rated highest across all evaluation
criteria. In contrast, the original code scored below neutral, particularly in
readability and maintainability, underscoring the benefits of automated
refactoring guided by quality prompts. While traditional metrics like CC and
LOC provide useful signals, they often diverge from human judgments,
emphasizing the need for human-in-the-loop evaluation. Our open-source
benchmark offers a foundation for future research on automated refactoring with
LLMs.

</details>


### [14] [Envisioning Future Interactive Web Development: Editing Webpage with Natural Language](https://arxiv.org/abs/2510.26516)
*Truong Hai Dang,Jingyu Xiao,Yintong Huo*

Main category: cs.SE

TL;DR: This paper presents Instruct4Edit, an automated pipeline that generates high-quality training data for web code editing, enabling fine-tuning of LLMs for accurate code modifications based on natural language instructions. Open-source models fine-tuned in this way rival proprietary systems, and the dataset and models are publicly released.


<details>
  <summary>Details</summary>
Motivation: Editing existing web application code according to new user design requirements is challenging for LLMs, mainly due to lack of high-quality tuning datasets. This limits LLMs' usefulness in iterative web editing tasks.

Method: They propose an automated data generation pipeline using LLMs to synthesize a fine-tuning dataset called Instruct4Edit for web editing. The pipeline creates diverse instructions, applies corresponding code modifications, and verifies results visually.

Result: Fine-tuning models on Instruct4Edit consistently improves the accuracy and structural coherence of code changes made in response to human instructions. Smaller open-source models can reach performance levels competitive with proprietary systems.

Conclusion: Automated tuning data generation enables scalable, transparent, and reproducible natural language-based web editing. The approach helps open-source models to be competitive and all resources are publicly shared.

Abstract: The evolution of web applications relies on iterative code modifications, a
process that is traditionally manual and time-consuming. While Large Language
Models (LLMs) can generate UI code, their ability to edit existing code from
new design requirements (e.g., "center the logo") remains a challenge. This is
largely due to the absence of large-scale, high-quality tuning data to align
model performance with human expectations. In this paper, we introduce a novel,
automated data generation pipeline that uses LLMs to synthesize a high-quality
fine-tuning dataset for web editing, named Instruct4Edit. Our approach
generates diverse instructions, applies the corresponding code modifications,
and performs visual verification to ensure correctness. By fine-tuning models
on Instruct4Edit, we demonstrate consistent improvement in translating human
intent into precise, structurally coherent, and visually accurate code changes.
This work provides a scalable and transparent foundation for natural language
based web editing, demonstrating that fine-tuning smaller open-source models
can achieve competitive performance with proprietary systems. We release all
data, code implementations, and model checkpoints for reproduction.

</details>


### [15] [Reflecting on Empirical and Sustainability Aspects of Software Engineering Research in the Era of Large Language Models](https://arxiv.org/abs/2510.26538)
*David Williams,Max Hort,Maria Kechagia,Aldeida Aleti,Justyna Petke,Federica Sarro*

Main category: cs.SE

TL;DR: LLM use in Software Engineering presents benchmarking, replicability, and sustainability challenges. The paper surveys ICSE research, exposes current practices and problems, and offers recommendations for improvement.


<details>
  <summary>Details</summary>
Motivation: Software Engineering research using Large Language Models faces challenges in benchmarking rigour, contamination, replicability, and sustainability.

Method: The paper surveys and analyzes current LLM-based SE research at ICSE, providing a structured overview of practices and issues.

Result: The analysis highlights both good practices and persistent shortcomings in LLM-based SE research. Recommendations are given to improve benchmarking, replicability, and tackle costs.

Conclusion: The paper recommends measures to strengthen benchmarking rigour, enhance replicability, and address financial and environmental concerns in LLM-based SE research.

Abstract: Software Engineering (SE) research involving the use of Large Language Models
(LLMs) has introduced several new challenges related to rigour in benchmarking,
contamination, replicability, and sustainability. In this paper, we invite the
research community to reflect on how these challenges are addressed in SE. Our
results provide a structured overview of current LLM-based SE research at ICSE,
highlighting both encouraging practices and persistent shortcomings. We
conclude with recommendations to strengthen benchmarking rigour, improve
replicability, and address the financial and environmental costs of LLM-based
SE.

</details>


### [16] ["Show Me You Comply... Without Showing Me Anything": Zero-Knowledge Software Auditing for AI-Enabled Systems](https://arxiv.org/abs/2510.26576)
*Filippo Scaramuzza,Renato Cordeiro Ferreira,Tomaz Maia Suller,Giovanni Quattrocchi,Damian Andrew Tamburri,Willem-Jan van den Heuvel*

Main category: cs.SE

TL;DR: The paper proposes ZKMLOps, a framework that embeds Zero-Knowledge Proofs into MLOps to enable auditable, regulation-compliant AI systems without exposing sensitive data or models, and validates its practicality for financial risk auditing.


<details>
  <summary>Details</summary>
Motivation: AI systems are increasingly used in critical domains, making trustworthiness, auditability, and regulatory compliance essential. Existing software verification methods are costly, manual, and not suitable for the opaque nature of most AI models, creating a conflict between transparency and protecting proprietary assets.

Method: The paper introduces ZKMLOps, a new verification framework that uses Zero-Knowledge Proofs (ZKPs) within the Machine-Learning Operations (MLOps) lifecycle. It applies ZKPs to allow cryptographically verifiable compliance proof without revealing sensitive information, and integrates these with standard software engineering processes.

Result: ZKMLOps enables modular, repeatable processes for generating verifiable cryptographic proofs of compliance. The practical applicability is demonstrated through financial risk auditing use case and empirical evaluation of ZKP protocols, focusing on performance versus model complexity.

Conclusion: Zero-Knowledge Proofs can effectively address the tension between regulatory verifiability and proprietary data protection in AI systems, offering a feasible path for trustworthy, auditable AI in high-stakes domains.

Abstract: The increasing exploitation of Artificial Intelligence (AI) enabled systems
in critical domains has made trustworthiness concerns a paramount showstopper,
requiring verifiable accountability, often by regulation (e.g., the EU AI Act).
Classical software verification and validation techniques, such as procedural
audits, formal methods, or model documentation, are the mechanisms used to
achieve this. However, these methods are either expensive or heavily manual and
ill-suited for the opaque, "black box" nature of most AI models. An intractable
conflict emerges: high auditability and verifiability are required by law, but
such transparency conflicts with the need to protect assets being audited-e.g.,
confidential data and proprietary models-leading to weakened accountability. To
address this challenge, this paper introduces ZKMLOps, a novel MLOps
verification framework that operationalizes Zero-Knowledge Proofs
(ZKPs)-cryptographic protocols allowing a prover to convince a verifier that a
statement is true without revealing additional information-within
Machine-Learning Operations lifecycles. By integrating ZKPs with established
software engineering patterns, ZKMLOps provides a modular and repeatable
process for generating verifiable cryptographic proof of compliance. We
evaluate the framework's practicality through a study of regulatory compliance
in financial risk auditing and assess feasibility through an empirical
evaluation of top ZKP protocols, analyzing performance trade-offs for ML models
of increasing complexity.

</details>


### [17] [Online and Interactive Bayesian Inference Debugging](https://arxiv.org/abs/2510.26579)
*Nathanael Nussbaumer,Markus Böck,Jürgen Cito*

Main category: cs.SE

TL;DR: Debugging Bayesian inference in probabilistic programming is hard. The paper introduces a new interactive tool that makes this process faster and easier, as shown in an evaluation with 18 users.


<details>
  <summary>Details</summary>
Motivation: Probabilistic programming enables Bayesian modeling and automated inference for many practitioners, but debugging inference is challenging and demands considerable expertise and effort.

Method: The authors developed a new tool for debugging Bayesian inference, which integrates directly into the development environment and supports online and interactive debugging. They identify key requirements for such frameworks and design their tool accordingly. The tool was evaluated through a study with 18 experienced users.

Result: The study demonstrated that the new online and interactive debugging tool significantly decreases both the time and difficulty required to debug Bayesian inference tasks.

Conclusion: The novel debugging approach and tool make Bayesian inference debugging much more efficient and accessible, facilitating broader use and development.

Abstract: Probabilistic programming is a rapidly developing programming paradigm which
enables the formulation of Bayesian models as programs and the automation of
posterior inference. It facilitates the development of models and conducting
Bayesian inference, which makes these techniques available to practitioners
from multiple fields. Nevertheless, probabilistic programming is notoriously
difficult as identifying and repairing issues with inference requires a lot of
time and deep knowledge. Through this work, we introduce a novel approach to
debugging Bayesian inference that reduces time and required knowledge
significantly. We discuss several requirements a Bayesian inference debugging
framework has to fulfill, and propose a new tool that meets these key
requirements directly within the development environment. We evaluate our
results in a study with 18 experienced participants and show that our approach
to online and interactive debugging of Bayesian inference significantly reduces
time and difficulty on inference debugging tasks.

</details>


### [18] [Stitch: Step-by-step LLM Guided Tutoring for Scratch](https://arxiv.org/abs/2510.26634)
*Yuan Si,Kyle Qi,Daming Li,Hanyuan Shi,Jialu Zhang*

Main category: cs.SE

TL;DR: Stitch, an interactive tutoring tool for Scratch programming, uses stepwise scaffolding and explanations (powered by large language models) to help students fix code errors without just showing them the answer. Empirical results show Stitch leads to better learning and problem-solving compared to direct-answer or typical automated feedback methods.


<details>
  <summary>Details</summary>
Motivation: Block-based environments like Scratch are popular for teaching programming, but while block syntax reduces superficial mistakes, students still struggle with deeper semantic errors. Existing debugging methods often show learners the correct solution explicitly, which fixes errors but does not foster independent problem-solving skills.

Method: The paper introduces Stitch, an interactive tutoring system. Stitch uses a Diff-Analyze module to compare the student's code with a reference solution, highlight critical differences, and generate explanations using a large language model. Learners are guided to inspect, understand, and partially fix their code in a step-by-step, iterative manner until the program works as intended.

Result: Stitch was evaluated against an advanced automated feedback generation tool for Scratch. The step-by-step scaffolding and guided interaction provided by Stitch was found to promote deeper learning and problem-solving compared to simply presenting the correct answer or using current automated feedback systems.

Conclusion: Step-by-step, interactive feedback is significantly more effective for learning in block-based programming environments than direct-answer strategies or conventional automated feedback. Stitch's guided approach fosters problem-solving skills and better learning outcomes.

Abstract: Block-based environments such as Scratch are increasingly popular in
programming education. While block syntax reduces surface errors, semantic bugs
remain common and challenging for novices to resolve. Existing debugging
workflows typically show the correct program directly to learners, a strategy
that may fix errors but undermines the development of problem-solving skills.
  We present Stitch, an interactive tutoring system that replaces "showing the
answer" with step-by-step scaffolding. The system's Diff-Analyze module
contrasts a student's project with a reference implementation, identifies the
most critical differences, and uses a large language model to explain why these
changes matter. Learners inspect highlighted blocks through a custom rendering
engine, understand the explanations, and selectively apply partial fixes. This
iterative process continues until the intended functionality is achieved.
  We evaluate Stitch in an empirical study, comparing it against a
state-of-the-art automated feedback generation tool for Scratch. Our key
insight is that simply presenting the correct program is pedagogically
ineffective. In contrast, our interactive, step-by-step guided system promotes
a more effective learning experience. More broadly, what constitutes effective
feedback in block-based programming remains an open question. Our evaluation
provides new evidence that step-by-step tutoring significantly enhances
learning outcomes, outperforming both direct-answer approaches and current
automated feedback generation tools.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [19] [Fair intersection of seekable iterators](https://arxiv.org/abs/2510.26016)
*Michael Arntzenius*

Main category: cs.PL

TL;DR: The paper generalizes miniKanren's fair search strategy, showing that bounded work per disjunct can elegantly enable worst-case optimal joins via seekable iterators, suitable for functional programming.


<details>
  <summary>Details</summary>
Motivation: miniKanren improves upon Prolog by implementing a fair and complete search through bounded exploration of disjuncts. The authors are motivated to explore whether this concept of fairness can be used for other problems — specifically, efficient and worst-case optimal data joins — and implemented in a way compatible with functional languages.

Method: The paper demonstrates how miniKanren's fairness mechanism, specifically bounding the work per disjunct before switching, can be adapted to worst-case optimal join algorithms using seekable iterators. This approach is compositional and suitable for functional programming environments.

Result: The authors show that bounded work, a fairness technique, provides an elegant and compositional framework for implementing worst-case optimal join algorithms with seekable iterators, enabling shallow embedding in functional languages.

Conclusion: Fairness via bounded work is a useful principle that can be generalized from miniKanren to efficient join algorithms, enabling compositional design and shallow embedding in functional languages.

Abstract: miniKanren's key semantic advance over Prolog is to implement a complete yet
efficient search strategy, fairly interleaving execution between disjuncts.
This fairness is accomplished by bounding how much work is done exploring one
disjunct before switching to the next. We show that the same idea -- fairness
via bounded work -- underlies an elegant compositional approach to implementing
worst-case optimal joins using a seekable iterator interface, suitable for
shallow embedding in functional languages.

</details>
