{"id": "2509.09019", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.09019", "abs": "https://arxiv.org/abs/2509.09019", "authors": ["Mohit Tekriwal", "John Sarracino"], "title": "Towards Verified Compilation of Floating-point Optimization in Scientific Computing Programs", "comment": null, "summary": "Scientific computing programs often undergo aggressive compiler optimization\nto achieve high performance and efficient resource utilization. While\nperformance is critical, we also need to ensure that these optimizations are\ncorrect. In this paper, we focus on a specific class of optimizations,\nfloating-point optimizations, notably due to fast math, at the LLVM IR level.\nWe present a preliminary work, which leverages the Verified LLVM framework in\nthe Rocq theorem prover, to prove the correctness of Fused-Multiply-Add (FMA)\noptimization for a basic block implementing the arithmetic expression $a * b +\nc$ . We then propose ways to extend this preliminary results by adding more\nprogram features and fast math floating-point optimizations.", "AI": {"tldr": "This paper demonstrates how formal verification can ensure the correctness of compiler-level floating-point optimizations, specifically the Fused-Multiply-Add operation, using the Verified LLVM framework and Rocq theorem prover, with potential for further generalization.", "motivation": "Compiler optimizations, especially floating-point optimizations, are widely used in scientific computing for performance gains, but their correctness must be guaranteed to maintain result integrity.", "method": "The study uses the Verified LLVM framework within the Rocq theorem prover to formally verify the correctness of Fused-Multiply-Add (FMA) optimization at the LLVM IR level for the expression a * b + c.", "result": "The preliminary verification shows that using Rocq's theorem-proving capabilities, the correctness of FMA optimization for a basic arithmetic block can be formally proven. The paper also suggests expanding the approach to other fast math optimizations and program features.", "conclusion": "Formal verification using theorem provers like Rocq with Verified LLVM shows promise in ensuring the correctness of floating-point optimizations, particularly FMA, and the methodology can be extended to broader cases."}}
{"id": "2509.09059", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.09059", "abs": "https://arxiv.org/abs/2509.09059", "authors": ["Paulette Koronkevich", "William J. Bowman"], "title": "Dependent-Type-Preserving Memory Allocation", "comment": "Submitted and received second place at the Student Research\n  Competition at Principles of Programming Languages 2022", "summary": "Dependently typed programming languages such as Coq, Agda, Idris, and F*,\nallow programmers to write detailed specifications of their programs and prove\ntheir programs meet these specifications. However, these specifications can be\nviolated during compilation since they are erased after type checking. External\nprograms linked with the compiled program can violate the specifications of the\noriginal program and change the behavior of the compiled program -- even when\ncompiled with a verified compiler. For example, since Coq does not allow\nexplicitly allocating memory, a programmer might link their Coq program with a\nC program that can allocate memory. Even if the Coq program is compiled with a\nverified compiler, the external C program can still violate the memory-safe\nspecification of the Coq program by providing an uninitialized pointer to\nmemory. This error could be ruled out by type checking in a language expressive\nenough to indicate whether memory is initialized versus uninitialized. Linking\nwith a program with an uninitialized pointer could be considered ill-typed, and\nour linking process could prevent linking with ill-typed programs. To\nfacilitate type checking during linking, we can use type-preserving\ncompilation, which preserves the types through the compilation process. In this\nongoing work, we develop a typed intermediate language that supports dependent\nmemory allocation, as well as a dependent-type-preserving compiler pass for\nmemory allocation.", "AI": {"tldr": "Dependently typed languages lose their guarantees when linking with external programs after compilation. This work introduces a typed intermediate language and type-preserving compiler pass that support memory safety and maintain dependent types, thereby helping prevent violations of program specifications during linking.", "motivation": "Dependently typed languages enable strong program specifications and proofs, but these guarantees can be violated after compilation, especially through interactions with external programs. Specifically, dependencies on erased types during compilation and unsafe linking can undermine type-safety.", "method": "The authors propose the use of type-preserving compilation. They develop a typed intermediate language that supports dependent memory allocation and introduce a compiler pass that preserves dependent types related to memory allocation, enabling type checking even during linking.", "result": "The paper provides an ongoing development of a type system and compiler pass that maintains dependent types throughout compilation, aiming to prevent specification violations caused by interaction with ill-typed external programs.", "conclusion": "Type-preserving compilation, along with a typed intermediate language, can help enforce program specifications even when linking with external programs, by ensuring ill-typed linkages are ruled out."}}
{"id": "2509.08843", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.08843", "abs": "https://arxiv.org/abs/2509.08843", "authors": ["Sidney Shapiro"], "title": "Pattern-Based File and Data Access with Python Glob: A Comprehensive Guide for Computational Research", "comment": null, "summary": "Pattern-based file access is a fundamental but often under-documented aspect\nof computational research. The Python glob module provides a simple yet\npowerful way to search, filter, and ingest files using wildcard patterns,\nenabling scalable workflows across disciplines. This paper introduces glob as a\nversatile tool for data science, business analytics, and artificial\nintelligence applications. We demonstrate use cases including large-scale data\ningestion, organizational data analysis, AI dataset construction, and\nreproducible research practices. Through concrete Python examples with widely\nused libraries such as pandas,scikit-learn, and matplotlib, we show how glob\nfacilitates efficient file traversal and integration with analytical pipelines.\nBy situating glob within the broader context of reproducible research and data\nengineering, we highlight its role as a methodological building block. Our goal\nis to provide researchers and practitioners with a concise reference that\nbridges foundational concepts and applied practice, making glob a default\ncitation for file pattern matching in Python-based research workflows.", "AI": {"tldr": "This paper positions Python's glob module as a core tool for scalable, reproducible file access in data science and AI research, illustrating its practical benefits with real-world examples.", "motivation": "File pattern matching is fundamental but under-documented; there is a need to clarify and promote best practices for file access in computational research to support reproducibility and scalability.", "method": "Concrete Python examples are provided using popular libraries (pandas, scikit-learn, matplotlib) to demonstrate glob's integration and utility in file traversal and analytical pipelines.", "result": "Glob significantly streamlines data ingestion, analysis, AI dataset construction, and supports robust and reproducible research through efficient file management.", "conclusion": "The glob module is an essential methodological tool for pattern-based file access, facilitating reproducible and scalable workflows in Python-driven research and analytics."}}
{"id": "2509.08857", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2509.08857", "abs": "https://arxiv.org/abs/2509.08857", "authors": ["Marcelino Garcia", "Renato Garcia", "Arthur Parizotto", "Andre Mendes", "Pedro Valle", "Ricardo Vilela", "Renato Balancieri", "Williamson Silva"], "title": "A Systematic Mapping Study on Chatbots in Programming Education", "comment": "18 pages, 1 figure, 3 tables", "summary": "Educational chatbots have gained prominence as support tools for teaching\nprogramming, particularly in introductory learning contexts. This paper\npresents a Systematic Mapping Study (SMS) that investigated how such agents\nhave been developed and applied in programming education. From an initial set\nof 3,216 publications, 54 studies were selected and analyzed based on five\nresearch subquestions, addressing chatbot types, programming languages used,\neducational content covered, interaction models, and application contexts. The\nresults reveal a predominance of chatbots designed for Python instruction,\nfocusing on fundamental programming concepts, and employing a wide variety of\npedagogical approaches and technological architectures. In addition to\nidentifying trends and gaps in the literature, this study provides insights to\ninform the development of new educational tools for programming instruction.", "AI": {"tldr": "A systematic review of 54 studies shows most educational chatbots for programming teach Python and basic concepts, using diverse teaching methods and technology setups; insights from this review can inform the creation of better programming education tools.", "motivation": "Educational chatbots have become prominent tools to support programming instruction, especially in introductory courses. There is a need to understand how these tools are developed and applied in educational contexts.", "method": "The authors conducted a Systematic Mapping Study (SMS) by reviewing an initial set of 3,216 publications, selecting and analyzing 54 studies using five research subquestions related to chatbot types, programming languages, educational content, interaction models, and application contexts.", "result": "The study found a dominance of chatbots designed for teaching Python, centered on fundamental programming concepts. It observed a variety of pedagogical approaches and technical architectures used in these agents.", "conclusion": "There are clear trends (Python, fundamental concepts, varied approaches) and gaps in the literature regarding educational chatbots for programming, and these findings can guide the future development of instructional tools."}}
{"id": "2509.08863", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.08863", "abs": "https://arxiv.org/abs/2509.08863", "authors": ["Qianqian Luo", "Liuchang Xu", "Qingming Lin", "Sensen Wu", "Ruichen Mao", "Chao Wang", "Hailin Feng", "Bo Huang", "Zhenhong Du"], "title": "GeoJSON Agents:A Multi-Agent LLM Architecture for Geospatial Analysis-Function Calling vs Code Generation", "comment": null, "summary": "LLMs have made substantial progress in task automation and natural language\nunderstanding.However,without expertise in GIS,they continue to encounter\nlimitations.To address these issues, we propose GeoJSON Agents-a multi-agent\nLLM architecture.This framework transforms natural language tasks into\nstructured GeoJSON operation commands and processes spatial data using two\nwidely adopted LLM enhancement techniques:Function Calling and Code\nGeneration.The architecture consists of three components-task parsing,agent\ncollaboration,and result integration-aimed at enhancing both the performance\nand scalability of GIS automation.The Planner agent interprets natural language\ntasks into structured GeoJSON commands.Then,specialized Worker agents\ncollaborate according to assigned roles to perform spatial data processing and\nanalysis,either by invoking predefined function APIs or by dynamically\ngenerating and executing Python-based spatial analysis code.Finally,the system\nintegrates the outputs from multiple execution rounds into\nreusable,standards-compliant GeoJSON files.To systematically evaluate the\nperformance of the two approaches,we constructed a benchmark dataset of 70\ntasks with varying complexity and conducted experiments using OpenAI's GPT-4o\nas the core model.Results indicate that the Function Calling-based GeoJSON\nAgent achieved an accuracy of 85.71%,while the Code Generation-based agent\nreached 97.14%,both significantly outperforming the best-performing\ngeneral-purpose model (48.57%).Further analysis reveals that the Code\nGeneration provides greater flexibility,whereas the Function Calling approach\noffers more stable execution.This study is the first to introduce an LLM\nmulti-agent framework for GeoJSON data and to compare the strengths and\nlimitations of two mainstream LLM enhancement methods,offering new perspectives\nfor improving GeoAI system performance.", "AI": {"tldr": "This paper presents GeoJSON Agents, a novel multi-agent LLM architecture designed to automate GIS tasks by translating natural language into structured spatial commands. It compares Function Calling and Code Generation, finding that both techniques far outperform general-purpose models in task accuracy. Code Generation is more flexible, while Function Calling is more stable, providing a new path forward for advanced GeoAI systems.", "motivation": "LLMs have advanced in task automation and natural language understanding, but lack expertise in Geographic Information Systems (GIS), limiting their effectiveness for GIS-specific tasks. Addressing this gap is crucial for expanding LLM capabilities to spatial domains.", "method": "The paper proposes GeoJSON Agents, a multi-agent LLM architecture that transforms natural language tasks into structured GeoJSON operation commands. It utilizes two enhancement techniques: Function Calling and Code Generation. The system features three components: task parsing, agent collaboration (with Planner and Worker agents), and result integration. Spatial data is processed by either calling predefined functions or dynamically generating Python code. The outputs are standardized into GeoJSON files. The methods are systematically benchmarked using 70 GIS tasks with GPT-4o as the core model.", "result": "Function Calling-based GeoJSON Agents achieved 85.71% accuracy; Code Generation-based Agents reached 97.14% accuracy\u2014both substantially higher than general-purpose models (48.57%). Code Generation provides more flexibility, while Function Calling offers greater stability.", "conclusion": "The study introduces the first LLM multi-agent framework for GeoJSON data, demonstrating the superior performance of specialized enhancement techniques in GIS automation. It sheds light on the respective strengths and weaknesses of Function Calling and Code Generation, offering new insights for future GeoAI system improvements."}}
{"id": "2509.08865", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.08865", "abs": "https://arxiv.org/abs/2509.08865", "authors": ["Guangyu Zhang", "Xixuan Wang", "Shiyu Sun", "Peiyan Xiao", "Kun Sun", "Yanhai Xiong"], "title": "TraceRAG: A LLM-Based Framework for Explainable Android Malware Detection and Behavior Analysis", "comment": null, "summary": "Sophisticated evasion tactics in malicious Android applications, combined\nwith their intricate behavioral semantics, enable attackers to conceal\nmalicious logic within legitimate functions, underscoring the critical need for\nrobust and in-depth analysis frameworks. However, traditional analysis\ntechniques often fail to recover deeply hidden behaviors or provide\nhuman-readable justifications for their decisions. Inspired by advances in\nlarge language models (LLMs), we introduce TraceRAG, a retrieval-augmented\ngeneration (RAG) framework that bridges natural language queries and Java code\nto deliver explainable malware detection and analysis. First, TraceRAG\ngenerates summaries of method-level code snippets, which are indexed in a\nvector database. At query time, behavior-focused questions retrieve the most\nsemantically relevant snippets for deeper inspection. Finally, based on the\nmulti-turn analysis results, TraceRAG produces human-readable reports that\npresent the identified malicious behaviors and their corresponding code\nimplementations. Experimental results demonstrate that our method achieves 96\\%\nmalware detection accuracy and 83.81\\% behavior identification accuracy based\non updated VirusTotal (VT) scans and manual verification. Furthermore, expert\nevaluation confirms the practical utility of the reports generated by TraceRAG.", "AI": {"tldr": "TraceRAG is a new framework leveraging large language models to improve Android malware detection. It links natural language questions to code, achieves high detection and behavior identification accuracy, and generates expert-validated, human-readable reports.", "motivation": "Malicious Android applications use advanced evasion tactics and complex behaviors to hide their malicious logic within legitimate functions, making detection challenging. Existing analysis tools often cannot uncover deeply hidden behaviors or provide clear human-readable explanations for their findings.", "method": "TraceRAG, a framework inspired by large language models, utilizes retrieval-augmented generation (RAG) to link natural language queries with Java code. It first summarizes method-level code, stores these summaries in a vector database, retrieves relevant snippets in response to behavior-driven queries, and finally generates detailed, readable reports about malicious behaviors and their implementation.", "result": "TraceRAG achieves 96% malware detection accuracy and 83.81% behavior identification accuracy, validated by both VirusTotal scans and manual verification. Experts also found its reports to be effective and practical.", "conclusion": "TraceRAG offers a robust solution for Android malware detection and explanation by bridging natural language and code. It not only identifies deeply hidden malicious behaviors with high accuracy but also provides clear, actionable reports for human analysts."}}
{"id": "2509.08867", "categories": ["cs.SE", "cs.AI", "68T01", "I.2.7"], "pdf": "https://arxiv.org/pdf/2509.08867", "abs": "https://arxiv.org/abs/2509.08867", "authors": ["K. Pronk", "Q. Zhao"], "title": "Benchmarking Energy Efficiency of Large Language Models Using vLLM", "comment": "6 pages, 6 figures", "summary": "The prevalence of Large Language Models (LLMs) is having an growing impact on\nthe climate due to the substantial energy required for their deployment and\nuse. To create awareness for developers who are implementing LLMs in their\nproducts, there is a strong need to collect more information about the energy\nefficiency of LLMs. While existing research has evaluated the energy efficiency\nof various models, these benchmarks often fall short of representing realistic\nproduction scenarios. In this paper, we introduce the LLM Efficiency Benchmark,\ndesigned to simulate real-world usage conditions. Our benchmark utilizes vLLM,\na high-throughput, production-ready LLM serving backend that optimizes model\nperformance and efficiency. We examine how factors such as model size,\narchitecture, and concurrent request volume affect inference energy efficiency.\nOur findings demonstrate that it is possible to create energy efficiency\nbenchmarks that better reflect practical deployment conditions, providing\nvaluable insights for developers aiming to build more sustainable AI systems.", "AI": {"tldr": "The paper presents a new benchmark that measures LLM energy efficiency under realistic use conditions, helping developers create more sustainable AI solutions.", "motivation": "Rising utilization of Large Language Models (LLMs) is increasing their climate impact due to high energy consumption. Current energy efficiency benchmarks for LLMs do not accurately simulate real-world production environments, necessitating better information for developers.", "method": "The paper introduces the LLM Efficiency Benchmark, which is designed to simulate realistic deployment scenarios. It uses vLLM, a highly efficient LLM serving backend, to evaluate the impact of model size, architecture, and concurrent request volume on inference energy efficiency.", "result": "The study shows that it is feasible to develop more realistic energy efficiency benchmarks for LLMs. These benchmarks reveal how various factors influence energy efficiency in practical conditions, offering actionable insights for optimizing sustainability.", "conclusion": "By adopting benchmarks that mirror production conditions, developers can gain more relevant data on LLM energy usage, ultimately advancing the development of more sustainable AI systems."}}
{"id": "2509.09072", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.09072", "abs": "https://arxiv.org/abs/2509.09072", "authors": ["Ahmed Adnan", "Mushfiqur Rahman", "Saad Sakib Noor", "Kazi Sakib"], "title": "CLARA: A Developer's Companion for Code Comprehension and Analysis", "comment": "In proceedings at the 40th IEEE/ACM International Conference on\n  Automated Software Engineering, ASE 2025", "summary": "Code comprehension and analysis of open-source project codebases is a task\nfrequently performed by developers and researchers. However, existing tools\nthat practitioners use for assistance with such tasks often require prior\nproject setup, lack context-awareness, and involve significant manual effort.\nTo address this, we present CLARA, a browser extension that utilizes a\nstate-of-the-art inference model to assist developers and researchers in: (i)\ncomprehending code files and code fragments, (ii) code refactoring, and (iii)\ncode quality attribute detection. We qualitatively evaluated CLARA's inference\nmodel using existing datasets and methodology, and performed a comprehensive\nuser study with 10 developers and academic researchers to assess its usability\nand usefulness. The results show that CLARA is useful, accurate, and practical\nin code comprehension and analysis tasks. CLARA is an open-source tool\navailable at https://github.com/SaadNoor555/CLARA_tool_demo. A video showing\nthe full capabilities of CLARA can be found at\nhttps://youtu.be/VDKVXvIH41Q?si=qBFsmS_Y4m_9x3YH.", "AI": {"tldr": "CLARA is a browser extension helping developers and researchers effectively understand and analyze open-source code with minimal setup. It was found useful and accurate in both dataset-based evaluation and user studies.", "motivation": "Developers and researchers frequently need to comprehend and analyze code in open-source projects, but existing tools are cumbersome, requiring setup, lacking contextual understanding, and demanding manual effort.", "method": "CLARA, a browser extension, leverages a state-of-the-art inference model to provide code comprehension, refactoring support, and code quality attribute detection. Its performance was evaluated qualitatively using existing datasets and a user study involving 10 participants.", "result": "CLARA was found to be useful, accurate, and practical for code comprehension and analysis tasks according to the qualitative evaluation and user study.", "conclusion": "CLARA is an effective, open-source browser extension that assists developers and researchers in code comprehension and analysis without requiring complex setup, making the process more efficient."}}
{"id": "2509.09192", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.09192", "abs": "https://arxiv.org/abs/2509.09192", "authors": ["Doha Nam", "Taehyoun Kim", "Duksan Ryu", "Jongmoon Baik"], "title": "Probing Pre-trained Language Models on Code Changes: Insights from ReDef, a High-Confidence Just-in-Time Defect Prediction Dataset", "comment": "An anonymous link containing the dataset, construction scripts, and\n  experimental code is publicly available for reproducibility:\n  https://figshare.com/s/4f202bc0921e26b41dc2", "summary": "Just-in-Time software defect prediction (JIT-SDP) plays a critical role in\nprioritizing risky code changes during code review and continuous integration.\nHowever, existing datasets often suffer from noisy labels and low precision in\nidentifying bug-inducing commits. To address this, we present ReDef\n(Revert-based Defect dataset), a high-confidence benchmark of function-level\nmodifications curated from 22 large-scale C/C++ projects. Defective cases are\nanchored by revert commits, while clean cases are validated through post-hoc\nhistory checks. Ambiguous instances are conservatively filtered out via a\nGPT-assisted triage process involving multiple votes and audits. This pipeline\nyields 3,164 defective and 10,268 clean modifications, offering substantially\nmore reliable labels than prior existing resources. Beyond dataset\nconstruction, we provide the first systematic evaluation of how pre-trained\nlanguage models (PLMs) reason about code modifications -- specifically, which\ninput encodings most effectively expose change information, and whether models\ngenuinely capture edit semantics. We fine-tune CodeBERT, CodeT5+, and UniXcoder\nunder five encoding strategies, and further probe their sensitivity through\ncounterfactual perturbations that swap added/deleted blocks, invert diff\npolarity, or inject spurious markers. Our results show that compact diff-style\nencodings consistently outperform whole-function formats across all PLMs, with\nstatistical tests confirming large, model-independent effects. However, under\ncounterfactual tests, performance degrades little or not at all -- revealing\nthat what appears to be robustness in fact reflects reliance on superficial\ncues rather than true semantic understanding. These findings indicate that,\nunlike in snapshot-based tasks, current PLMs remain limited in their ability to\ngenuinely comprehend code modifications.", "AI": {"tldr": "The paper introduces a high-confidence, function-level code modification dataset for defect prediction and shows that while language models excel with certain input encodings, they do not fundamentally understand code changes as intended.", "motivation": "Existing JIT software defect prediction datasets are noisy and imprecise, making it hard to accurately evaluate or improve models. The study aims to provide better defect labels and understand how pre-trained language models reason about code changes.", "method": "The authors built a new dataset (ReDef) with high-confidence labels using revert commits for defects, history checks for clean modifications, and GPT-assisted triage to filter ambiguity. They then systematically evaluated various pre-trained language models under multiple input encodings, including robustness tests with counterfactual edits.", "result": "A reliable dataset of 3,164 defective and 10,268 clean code modifications was created. PLMs performed best with diff-style encodings, but counterfactual tests revealed that models relied on superficial cues rather than deep semantic understanding of code changes.", "conclusion": "While the new dataset improves defect prediction research, current PLMs do not truly comprehend code modifications; their robustness is more apparent than real, based on shallow patterns rather than actual edit semantics."}}
{"id": "2509.09194", "categories": ["cs.SE", "cs.AI", "68N19"], "pdf": "https://arxiv.org/pdf/2509.09194", "abs": "https://arxiv.org/abs/2509.09194", "authors": ["Ayelet Berzack", "Guy Katz"], "title": "On Integrating Large Language Models and Scenario-Based Programming for Improving Software Reliability", "comment": null, "summary": "Large Language Models (LLMs) are fast becoming indispensable tools for\nsoftware developers, assisting or even partnering with them in crafting complex\nprograms. The advantages are evident -- LLMs can significantly reduce\ndevelopment time, generate well-organized and comprehensible code, and\noccasionally suggest innovative ideas that developers might not conceive on\ntheir own. However, despite their strengths, LLMs will often introduce\nsignificant errors and present incorrect code with persuasive confidence,\npotentially misleading developers into accepting flawed solutions.\n  In order to bring LLMs into the software development cycle in a more reliable\nmanner, we propose a methodology for combining them with ``traditional''\nsoftware engineering techniques in a structured way, with the goal of\nstreamlining the development process, reducing errors, and enabling users to\nverify crucial program properties with increased confidence. Specifically, we\nfocus on the Scenario-Based Programming (SBP) paradigm -- an event-driven,\nscenario-based approach for software engineering -- to allow human developers\nto pour their expert knowledge into the LLM, as well as to inspect and verify\nits outputs.\n  To evaluate our methodology, we conducted a significant case study, and used\nit to design and implement the Connect4 game. By combining LLMs and SBP we were\nable to create a highly-capable agent, which could defeat various strong\nexisting agents. Further, in some cases, we were able to formally verify the\ncorrectness of our agent. Finally, our experience reveals interesting insights\nregarding the ease-of-use of our proposed approach. The full code of our\ncase-study will be made publicly available with the final version of this\npaper.", "AI": {"tldr": "LLMs can speed up software development but are error-prone. Combining LLMs with Scenario-Based Programming enables developers to control, verify, and improve LLM-generated code. In a Connect4 case study, this method produced a strong, verifiable agent and demonstrated practical benefits for developers.", "motivation": "Large Language Models (LLMs) offer potential in software development but also introduce significant errors, thus requiring more reliable methodologies for their use.", "method": "The paper proposes combining LLMs with traditional software engineering techniques, specifically using the Scenario-Based Programming (SBP) paradigm to help developers leverage LLMs while verifying program correctness and reducing errors.", "result": "A case study was conducted, developing the Connect4 game by integrating LLMs and SBP. The resulting agent outperformed existing agents and, in some cases, its correctness was formally verified. The methodology showed promising ease-of-use.", "conclusion": "Integrating LLMs with SBP in a structured process enhances reliability, streamlines development, and allows for verification of software properties, making it a promising approach for safely deploying LLMs in software engineering."}}
{"id": "2509.09294", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.09294", "abs": "https://arxiv.org/abs/2509.09294", "authors": ["Solal Rapaport", "Laurent Pautet", "Samuel Tardieu", "Stefano Zacchiroli"], "title": "Altered Histories in Version Control System Repositories: Evidence from the Trenches", "comment": null, "summary": "Version Control Systems (VCS) like Git allow developers to locally rewrite\nrecorded history, e.g., to reorder and suppress commits or specific data in\nthem. These alterations have legitimate use cases, but become problematic when\nperformed on public branches that have downstream users: they break push/pull\nworkflows, challenge the integrity and reproducibility of repositories, and\ncreate opportunities for supply chain attackers to sneak into them nefarious\nchanges. We conduct the first large-scale investigation of Git history\nalterations in public code repositories. We analyze 111 M (millions)\nrepositories archived by Software Heritage, which preserves VCS histories even\nacross alterations. We find history alterations in 1.22 M repositories, for a\ntotal of 8.7 M rewritten histories. We categorize changes by where they happen\n(which repositories, which branches) and what is changed in them (files or\ncommit metadata). Conducting two targeted case studies we show that altered\nhistories recurrently change licenses retroactively, or are used to remove\n''secrets'' (e.g., private keys) committed by mistake. As these behaviors\ncorrespond to bad practices-in terms of project governance or security\nmanagement, respectively-that software recipients might want to avoid, we\nintroduce GitHistorian, an automated tool, that developers can use to spot and\ndescribe history alterations in public Git repositories.", "AI": {"tldr": "Altering history in public Git repositories is widespread and poses risks to users, project governance, and security. This paper presents the first extensive analysis of such alterations, categorizes their types and impacts, and introduces GitHistorian\u2014a tool to automatically detect and describe history changes in public repositories.", "motivation": "The paper is motivated by the need to understand and address the risks associated with history alterations in public Git repositories. Such alterations can disrupt workflows, compromise integrity and reproducibility, and facilitate supply chain attacks, especially when performed on branches used by downstream users.", "method": "The authors conduct a large-scale empirical study by analyzing 111 million repositories archived by Software Heritage, which preserves version control histories even after alterations. They identify and categorize changes, and perform two targeted case studies to assess the impact of specific types of history alterations. Additionally, they develop an automated tool called GitHistorian to detect history alterations.", "result": "The study reveals that 1.22 million repositories had altered histories, amounting to 8.7 million instances of history rewriting. The alterations include both changes to files and commit metadata, often involving retroactive license changes or removal of sensitive data such as private keys. These practices are considered bad for project governance and security management.", "conclusion": "History alterations in public Git repositories are prevalent and potentially dangerous, frequently involving problematic practices that downstream users and software recipients may wish to detect and avoid. The GitHistorian tool provides an automated solution for identifying and describing such alterations, contributing to improved project governance and security."}}
{"id": "2509.09313", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.09313", "abs": "https://arxiv.org/abs/2509.09313", "authors": ["Moritz Mock", "Thomas Forrer", "Barbara Russo"], "title": "Cross-Domain Evaluation of Transformer-Based Vulnerability Detection on Open & Industry Data", "comment": "Accepted to the 26th International Conference on Product-Focused\n  Software Process Improvement (PROFES 2025)", "summary": "Deep learning solutions for vulnerability detection proposed in academic\nresearch are not always accessible to developers, and their applicability in\nindustrial settings is rarely addressed. Transferring such technologies from\nacademia to industry presents challenges related to trustworthiness, legacy\nsystems, limited digital literacy, and the gap between academic and industrial\nexpertise. For deep learning in particular, performance and integration into\nexisting workflows are additional concerns. In this work, we first evaluate the\nperformance of CodeBERT for detecting vulnerable functions in industrial and\nopen-source software. We analyse its cross-domain generalisation when\nfine-tuned on open-source data and tested on industrial data, and vice versa,\nalso exploring strategies for handling class imbalance. Based on these results,\nwe develop AI-DO(Automating vulnerability detection Integration for Developers'\nOperations), a Continuous Integration-Continuous Deployment (CI/CD)-integrated\nrecommender system that uses fine-tuned CodeBERT to detect and localise\nvulnerabilities during code review without disrupting workflows. Finally, we\nassess the tool's perceived usefulness through a survey with the company's IT\nprofessionals. Our results show that models trained on industrial data detect\nvulnerabilities accurately within the same domain but lose performance on\nopen-source code, while a deep learner fine-tuned on open data, with\nappropriate undersampling techniques, improves the detection of\nvulnerabilities.", "AI": {"tldr": "This paper evaluates and adapts deep learning-based vulnerability detection tools for industry, finding that with fine-tuning and integration strategies like undersampling and CI/CD workflows, performance and developer acceptance can be significantly improved.", "motivation": "There is a gap between academic research and industrial adoption of deep learning-based vulnerability detection due to challenges in trustworthiness, legacy systems, workflow integration, and expertise disparities.", "method": "Performance evaluation of CodeBERT for vulnerability detection in both industrial and open-source software, cross-domain generalization analysis, handling class imbalance, and development of a CI/CD-integrated recommender system (AI-DO) with practical survey assessment.", "result": "Industrial-trained models perform well within the same domain but struggle with open-source code. Open data fine-tuning with undersampling enhances vulnerability detection. The AI-DO tool is perceived as useful by IT professionals in the company.", "conclusion": "Effective cross-domain vulnerability detection by deep learning models requires specific training and data strategies. CI/CD integration via practical tools like AI-DO can bridge the research-to-industry gap and gain positive user reception."}}
{"id": "2509.09322", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2509.09322", "abs": "https://arxiv.org/abs/2509.09322", "authors": ["Jacopo Bufalino", "Agathe Blaise", "Stefano Secci"], "title": "ORCA: Unveiling Obscure Containers In The Wild", "comment": null, "summary": "Modern software development increasingly depends on open-source libraries and\nthird-party components, which are often encapsulated into containerized\nenvironments. While improving the development and deployment of applications,\nthis approach introduces security risks, particularly when outdated or\nvulnerable components are inadvertently included in production environments.\nSoftware Composition Analysis (SCA) is a critical process that helps identify\nand manage packages and dependencies inside a container. However, unintentional\nmodifications to the container filesystem can lead to incomplete container\nimages, which compromise the reliability of SCA tools. In this paper, we\nexamine the limitations of both cloud-based and open-source SCA tools when\nfaced with such obscure images. An analysis of 600 popular containers revealed\nthat obscure containers exist in well-known registries and trusted images and\nthat many tools fail to analyze such containers. To mitigate these issues, we\npropose an obscuration-resilient methodology for container analysis and\nintroduce ORCA (Obscuration-Resilient Container Analyzer), its open-source\nimplementation. We reported our findings to all vendors using their appropriate\nchannels. Our results demonstrate that ORCA effectively detects the content of\nobscure containers and achieves a median 40% improvement in file coverage\ncompared to Docker Scout and Syft.", "AI": {"tldr": "Open-source and cloud SCA tools often miss obscure files in container images, leading to security gaps. This paper introduces ORCA, a tool achieving 40% better file coverage on challenging containers, improving reliability and security analysis.", "motivation": "Modern software development relies heavily on open-source libraries and containers, which introduces security risks when vulnerable or outdated components are unintentionally deployed. Existing Software Composition Analysis (SCA) tools struggle to reliably analyze containers with obscure or incompletely modified filesystems.", "method": "The paper conducts an empirical analysis of 600 popular container images to evaluate the effectiveness of cloud-based and open-source SCA tools on obscure container images. It then proposes a new methodology and introduces ORCA, an open-source tool designed to be resilient to filesystem obscuration issues in containers.", "result": "The study finds that obscure containers are prevalent even among trusted registries, and many existing SCA tools fail to fully analyze them. ORCA demonstrates superior performance, achieving a median 40% improvement in file coverage compared to established tools like Docker Scout and Syft.", "conclusion": "Obscure container images pose a significant challenge to the reliability of current SCA tools. The proposed ORCA methodology and tool offer a practical solution by improving the detection and analysis of such containers, thereby enhancing security and dependency management."}}
{"id": "2509.09614", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.09614", "abs": "https://arxiv.org/abs/2509.09614", "authors": ["Jielin Qiu", "Zuxin Liu", "Zhiwei Liu", "Rithesh Murthy", "Jianguo Zhang", "Haolin Chen", "Shiyu Wang", "Ming Zhu", "Liangwei Yang", "Juntao Tan", "Zhepeng Cen", "Cheng Qian", "Shelby Heinecke", "Weiran Yao", "Silvio Savarese", "Caiming Xiong", "Huan Wang"], "title": "LoCoBench: A Benchmark for Long-Context Large Language Models in Complex Software Engineering", "comment": "53 pages", "summary": "The emergence of long-context language models with context windows extending\nto millions of tokens has created new opportunities for sophisticated code\nunderstanding and software development evaluation. We propose LoCoBench, a\ncomprehensive benchmark specifically designed to evaluate long-context LLMs in\nrealistic, complex software development scenarios. Unlike existing code\nevaluation benchmarks that focus on single-function completion or short-context\ntasks, LoCoBench addresses the critical evaluation gap for long-context\ncapabilities that require understanding entire codebases, reasoning across\nmultiple files, and maintaining architectural consistency across large-scale\nsoftware systems. Our benchmark provides 8,000 evaluation scenarios\nsystematically generated across 10 programming languages, with context lengths\nspanning 10K to 1M tokens, a 100x variation that enables precise assessment of\nlong-context performance degradation in realistic software development\nsettings. LoCoBench introduces 8 task categories that capture essential\nlong-context capabilities: architectural understanding, cross-file refactoring,\nmulti-session development, bug investigation, feature implementation, code\ncomprehension, integration testing, and security analysis. Through a 5-phase\npipeline, we create diverse, high-quality scenarios that challenge LLMs to\nreason about complex codebases at unprecedented scale. We introduce a\ncomprehensive evaluation framework with 17 metrics across 4 dimensions,\nincluding 8 new evaluation metrics, combined in a LoCoBench Score (LCBS). Our\nevaluation of state-of-the-art long-context models reveals substantial\nperformance gaps, demonstrating that long-context understanding in complex\nsoftware development represents a significant unsolved challenge that demands\nmore attention. LoCoBench is released at:\nhttps://github.com/SalesforceAIResearch/LoCoBench.", "AI": {"tldr": "LoCoBench is a new benchmark tailored for evaluating large language models' capabilities in understanding and reasoning about entire codebases and complex software systems with long contexts. Initial tests show that even advanced LLMs perform poorly on these challenging, realistic software development tasks, revealing a significant area for improvement in long-context model understanding.", "motivation": "Current code evaluation benchmarks for language models primarily focus on short-context tasks or single-function completions, failing to assess models' abilities in handling entire codebases or reasoning across multiple files. The emergence of long-context LLMs with much larger context windows creates a need for proper evaluation of their abilities in realistic, large-scale software development scenarios.", "method": "The authors propose LoCoBench, a benchmark specifically designed for evaluating long-context LLMs. LoCoBench includes 8,000 evaluation scenarios across 10 programming languages, with context lengths ranging from 10,000 to 1,000,000 tokens. It covers 8 essential long-context task categories and uses a 5-phase pipeline to generate high-quality test cases. The evaluation framework introduces 17 metrics across 4 dimensions, including 8 new metrics, and produces an aggregate LoCoBench Score (LCBS).", "result": "Evaluation of state-of-the-art long-context models with LoCoBench shows significant performance gaps, indicating that these models still struggle with complex, large-scale software development tasks and that long-context understanding remains an unsolved challenge in the field.", "conclusion": "LoCoBench fills a critical gap by providing a comprehensive, realistic benchmark for assessing the long-context abilities of language models in software development. Early results highlight that advancing LLMs\u2019 performance on long-context tasks is a major open research problem."}}
{"id": "2509.09630", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2509.09630", "abs": "https://arxiv.org/abs/2509.09630", "authors": ["Zhenguang Liu", "Lixun Ma", "Zhongzheng Mu", "Chengkun Wei", "Xiaojun Xu", "Yingying Jiao", "Kui Ren"], "title": "I Know Who Clones Your Code: Interpretable Smart Contract Similarity Detection", "comment": null, "summary": "Widespread reuse of open-source code in smart contract development boosts\nprogramming efficiency but significantly amplifies bug propagation across\ncontracts, while dedicated methods for detecting similar smart contract\nfunctions remain very limited. Conventional abstract-syntax-tree (AST) based\nmethods for smart contract similarity detection face challenges in handling\nintricate tree structures, which impedes detailed semantic comparison of code.\nRecent deep-learning based approaches tend to overlook code syntax and\ndetection interpretability, resulting in suboptimal performance.\n  To fill this research gap, we introduce SmartDetector, a novel approach for\ncomputing similarity between smart contract functions, explainable at the\nfine-grained statement level. Technically, SmartDetector decomposes the AST of\na smart contract function into a series of smaller statement trees, each\nreflecting a structural element of the source code. Then, SmartDetector uses a\nclassifier to compute the similarity score of two functions by comparing each\npair of their statement trees. To address the infinite hyperparameter space of\nthe classifier, we mathematically derive a cosine-wise diffusion process to\nefficiently search optimal hyperparameters. Extensive experiments conducted on\nthree large real-world datasets demonstrate that SmartDetector outperforms\ncurrent state-of-the-art methods by an average improvement of 14.01% in\nF1-score, achieving an overall average F1-score of 95.88%.", "AI": {"tldr": "SmartDetector is a novel tool for detecting similar smart contract functions at a fine-grained level. It breaks down function code into smaller trees for better structural analysis and uses an efficient hyperparameter optimization method. The approach outperforms previous methods, achieving an F1-score of 95.88% and a 14% improvement over existing solutions.", "motivation": "The motivation is to address the challenge of bug propagation in smart contracts due to the widespread reuse of open-source code and to improve upon limitations of existing methods for detecting similar smart contract functions, particularly with respect to handling complex syntax structures and achieving interpretability.", "method": "The proposed method, SmartDetector, decomposes the abstract syntax tree (AST) of a smart contract function into smaller statement trees to capture structural code elements. It applies a classifier to compute similarity scores between function pairs, comparing their respective statement trees. The method incorporates a mathematically derived cosine-wise diffusion process to efficiently search for optimal classifier hyperparameters.", "result": "SmartDetector demonstrates superior performance, outperforming state-of-the-art approaches with an average F1-score improvement of 14.01%, and achieves an overall average F1-score of 95.88% on three large real-world datasets.", "conclusion": "SmartDetector effectively enhances similar function detection in smart contracts by enabling fine-grained, interpretable comparisons and overcoming the limitations of AST and deep learning-based existing methods."}}
