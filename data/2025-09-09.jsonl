{"id": "2509.05504", "categories": ["cs.PL", "cs.AR"], "pdf": "https://arxiv.org/pdf/2509.05504", "abs": "https://arxiv.org/abs/2509.05504", "authors": ["Karl Aaron Rudkowski", "Sallar Ahmadi-Pour", "Rolf Drechsler"], "title": "Comparing Methods for the Cross-Level Verification of SystemC Peripherals with Symbolic Execution", "comment": null, "summary": "Virtual Prototypes (VPs) are important tools in modern hardware development.\nAt high abstractions, they are often implemented in SystemC and offer early\nanalysis of increasingly complex designs. These complex designs often combine\none or more processors, interconnects, and peripherals to perform tasks in\nhardware or interact with the environment. Verifying these subsystems is a\nwell-suited task for VPs, as they allow reasoning across different abstraction\nlevels. While modern verification techniques like symbolic execution can be\nseamlessly integrated into VP-based workflows, they require modifications in\nthe SystemC kernel. Hence, existing approaches therefore modify and replace the\nSystemC kernel, or ignore the opportunity of cross-level scenarios completely,\nand would not allow focusing on special challenges of particular subsystems\nlike peripherals. We propose CrosSym and SEFOS, two opposing approaches for a\nversatile symbolic execution of peripherals. CrosSym modifies the SystemC\nkernel, while SEFOS instead modifies a modern symbolic execution engine. Our\nextensive evaluation applies our tools to various peripherals on different\nlevels of abstractions. Both tools extensive sets of features are demonstrated\nfor (1) different verification scenarios, and (2) identifying 300+ mutants. In\ncomparison with each other, SEFOS convinces with the unmodified SystemC kernel\nand peripheral, while CrosSym offers slightly better runtime and memory usage.\nIn comparison to the state-of-the-art, that is limited to Transaction Level\nModelling (TLM), our tools offered comparable runtime, while enabling\ncross-level verification with symbolic execution."}
{"id": "2509.05586", "categories": ["cs.PL", "cs.CC"], "pdf": "https://arxiv.org/pdf/2509.05586", "abs": "https://arxiv.org/abs/2509.05586", "authors": ["Lee Zheng Han", "Umang Mathur"], "title": "Fixed Parameter Tractable Linearizability Monitoring for Stack, Queue and Anagram Agnostic Data Types", "comment": null, "summary": "Verifying linearizability of concurrent data structures is NP-hard, even for\nsimple types. We present fixed-parameter tractable algorithms for monitoring\nstacks, queues, and anagram-agnostic data types (AADTs), parameterized by the\nmaximum concurrency. Our approach leverages frontier graphs and partition\nstates to bound the search space. For AADTs, equivalence of linearizations\nenables monitoring in log-linear time. For stacks, we introduce a grammar-based\nmethod with a sub-cubic reduction to matrix multiplication, and for queues, a\nsplit-sequence transition system supporting efficient dynamic programming.\nThese results unify tractability guarantees for both order-sensitive and\nanagram-agnostic data types under bounded concurrency."}
{"id": "2509.06724", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.06724", "abs": "https://arxiv.org/abs/2509.06724", "authors": ["Florian Kohn", "Arthur Correnson", "Jan Baumeister", "Bernd Finkbeiner"], "title": "Pacing Types: Safe Monitoring of Asynchronous Streams", "comment": null, "summary": "Stream-based monitoring is a real-time safety assurance mechanism for complex\ncyber-physical systems such as unmanned aerial vehicles. In this context, a\nmonitor aggregates streams of input data from sensors and other sources to give\nreal-time statistics and assessments of the system's health. Since monitors are\nsafety-critical components, it is crucial to ensure that they are free of\npotential runtime errors. One of the central challenges in designing reliable\nstream-based monitors is to deal with the asynchronous nature of data streams:\nin concrete applications, the different sensors being monitored produce values\nat different speeds, and it is the monitor's responsibility to correctly react\nto the asynchronous arrival of different streams of values. To ease this\nprocess, modern frameworks for stream-based monitoring such as RTLola feature\nan expressive specification language that allows to finely specify data\nsynchronization policies. While this feature dramatically simplifies the design\nof monitors, it can also lead to subtle runtime errors. To mitigate this issue,\nthis paper presents pacing types, a novel type system implemented in RTLola to\nensure that monitors for asynchronous streams are well-behaved at runtime. We\nformalize the essence of pacing types for a core fragment of RTLola, and\npresent a soundness proof of the pacing type system using a new logical\nrelation."}
{"id": "2509.06752", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2509.06752", "abs": "https://arxiv.org/abs/2509.06752", "authors": ["Amir M. Ben-Amram", "Samir Genaim", "Joël Ouaknine", "James Worrell"], "title": "Termination Analysis of Linear-Constraint Programs", "comment": null, "summary": "This Survey provides an overview of techniques in termination analysis for\nprograms with numerical variables and transitions defined by linear\nconstraints. This subarea of program analysis is challenging due to the\nexistence of undecidable problems, and this Survey systematically explores\napproaches that mitigate this inherent difficulty. These include foundational\ndecidability results, the use of ranking functions, and disjunctive\nwell-founded transition invariants. The Survey also discusses non-termination\nwitnesses, used to prove that a program will not halt. We examine the\nalgorithmic and complexity aspects of these methods, showing how different\napproaches offer a trade-off between expressive power and computational\ncomplexity. The Survey does not discuss how termination analysis is performed\non real-world programming languages, nor does it consider more expressive\nabstract models that include non-linear arithmetic, probabilistic choice, or\nterm rewriting systems."}
{"id": "2509.05372", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.05372", "abs": "https://arxiv.org/abs/2509.05372", "authors": ["Piotr Przymus", "Andreas Happe", "Jürgen Cito"], "title": "Adversarial Bug Reports as a Security Risk in Language Model-Based Automated Program Repair", "comment": null, "summary": "Large Language Model (LLM) - based Automated Program Repair (APR) systems are\nincreasingly integrated into modern software development workflows, offering\nautomated patches in response to natural language bug reports. However, this\nreliance on untrusted user input introduces a novel and underexplored attack\nsurface. In this paper, we investigate the security risks posed by adversarial\nbug reports -- realistic-looking issue submissions crafted to mislead APR\nsystems into producing insecure or harmful code changes. We develop a\ncomprehensive threat model and conduct an empirical study to evaluate the\nvulnerability of state-of-the-art APR systems to such attacks. Our\ndemonstration comprises 51 adversarial bug reports generated across a spectrum\nof strategies, from manual curation to fully automated pipelines. We test these\nagainst leading APR model and assess both pre-repair defenses (e.g., LlamaGuard\nvariants, PromptGuard variants, Granite-Guardian, and custom LLM filters) and\npost-repair detectors (GitHub Copilot, CodeQL). Our findings show that current\ndefenses are insufficient: 90\\% of crafted bug reports triggered\nattacker-aligned patches. The best pre-repair filter blocked only 47\\%, while\npost-repair analysis-often requiring human oversight-was effective in just 58\\%\nof cases. To support scalable security testing, we introduce a prototype\nframework for automating the generation of adversarial bug reports. Our\nanalysis exposes a structural asymmetry: generating adversarial inputs is\ninexpensive, while detecting or mitigating them remains costly and error-prone.\nWe conclude with practical recommendations for improving the robustness of APR\nsystems against adversarial misuse and highlight directions for future work on\ntrustworthy automated repair."}
{"id": "2509.06794", "categories": ["cs.PL", "cs.AR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.06794", "abs": "https://arxiv.org/abs/2509.06794", "authors": ["Shihan Fang", "Hongzheng Chen", "Niansong Zhang", "Jiajie Li", "Han Meng", "Adrian Liu", "Zhiru Zhang"], "title": "Dato: A Task-Based Programming Model for Dataflow Accelerators", "comment": null, "summary": "Recent deep learning workloads increasingly push computational demand beyond\nwhat current memory systems can sustain, with many kernels stalling on data\nmovement rather than computation. While modern dataflow accelerators\nincorporate on-chip streaming to mitigate off-chip bandwidth limitations,\nexisting programming models struggle to harness these capabilities effectively.\nLow-level interfaces provide fine-grained control but impose significant\ndevelopment overhead, whereas high-level tile-based languages abstract away\ncommunication details, restricting optimization and forcing compilers to\nreconstruct the intended dataflow. We present Dato, a Python-embedded,\ntask-based programming model for dataflow accelerators that elevates data\ncommunication and sharding to first-class type constructs. Developers write\nprograms as a graph of tasks connected via explicit stream types, with sharded\ninputs specified using layout types. These tasks are first mapped virtually\nonto the accelerator's spatial fabric, and the compiler then generates a\nphysical mapping that respects hardware constraints. Experimental results on\nboth AMD Ryzen AI NPU and Alveo FPGA devices demonstrate that Dato achieves\nhigh performance while significantly reducing the burden of writing optimized\ncode. On the NPU, Dato attains up to 84% hardware utilization for GEMM and\ndelivers a 2.81x speedup on attention kernels compared to a state-of-the-art\ncommercial framework. On the FPGA, Dato surpasses leading frameworks in\nperformance when generating custom systolic arrays, achieving 98% of the\ntheoretical peak performance."}
{"id": "2509.05394", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.05394", "abs": "https://arxiv.org/abs/2509.05394", "authors": ["Zoltan Toth-Czifra"], "title": "Reverse Browser: Vector-Image-to-Code Generator", "comment": "Submitted to AIWare 2025 ArXiv Track", "summary": "Automating the conversion of user interface design into code (image-to-code\nor image-to-UI) is an active area of software engineering research. However,\nthe state-of-the-art solutions do not achieve high fidelity to the original\ndesign, as evidenced by benchmarks. In this work, I approach the problem\ndifferently: I use vector images instead of bitmaps as model input. I create\nseveral large datasets for training machine learning models. I evaluate the\navailable array of Image Quality Assessment (IQA) algorithms and introduce a\nnew, multi-scale metric. I then train a large open-weights model and discuss\nits limitations."}
{"id": "2509.06845", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06845", "abs": "https://arxiv.org/abs/2509.06845", "authors": ["Tom Lauwaerts", "Maarten Steevens", "Christophe Scholliers"], "title": "MIO: Multiverse Debugging in the Face of Input/Output -- Extended Version with Additional Appendices", "comment": "This extended version provides auxiliary material to the article of\n  the same title that will appear in the ACM Digital Library as part of the\n  PACMPL issue for OOPSLA 2025", "summary": "Debugging non-deterministic programs on microcontrollers is notoriously\nchallenging, especially when bugs manifest in unpredictable, input-dependent\nexecution paths. A recent approach, called multiverse debugging, makes it\neasier to debug non-deterministic programs by allowing programmers to explore\nall potential execution paths. Current multiverse debuggers enable both forward\nand backward traversal of program paths, and some facilitate jumping to any\npreviously visited states, potentially branching into alternative execution\npaths within the state space.\n  Unfortunately, debugging programs that involve input/output operations using\nexisting multiverse debuggers can reveal inaccessible program states, i.e.\nstates which are not encountered during regular execution. This can\nsignificantly hinder the debugging process, as the programmer may spend\nsubstantial time exploring and examining inaccessible program states, or worse,\nmay mistakenly assume a bug is present in the code, when in fact, the issue is\ncaused by the debugger.\n  This paper presents a novel approach to multiverse debugging, which can\naccommodate a broad spectrum of input/output operations. We provide the\nsemantics of our approach and prove the correctness of our debugger, ensuring\nthat despite having support for a wide range of input/output operations the\ndebugger will only explore those program states which can be reached during\nregular execution.\n  We have developed a prototype, called MIO, leveraging the WARDuino\nWebAssembly virtual machine to demonstrate the feasibility and efficiency of\nour techniques. As a demonstration of the approach we highlight a color dial\nbuilt with a Lego Mindstorms motor, and color sensor, providing a tangible\nexample of how our approach enables multiverse debugging for programs running\non an STM32 microcontroller."}
{"id": "2509.05540", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.05540", "abs": "https://arxiv.org/abs/2509.05540", "authors": ["Thiago Barradas", "Aline Paes", "Vânia de Oliveira Neves"], "title": "Combining TSL and LLM to Automate REST API Testing: A Comparative Study", "comment": "10 pages, article computer science, software engineering, software\n  testing, ia, llm", "summary": "The effective execution of tests for REST APIs remains a considerable\nchallenge for development teams, driven by the inherent complexity of\ndistributed systems, the multitude of possible scenarios, and the limited time\navailable for test design. Exhaustive testing of all input combinations is\nimpractical, often resulting in undetected failures, high manual effort, and\nlimited test coverage. To address these issues, we introduce RestTSLLM, an\napproach that uses Test Specification Language (TSL) in conjunction with Large\nLanguage Models (LLMs) to automate the generation of test cases for REST APIs.\nThe approach targets two core challenges: the creation of test scenarios and\nthe definition of appropriate input data. The proposed solution integrates\nprompt engineering techniques with an automated pipeline to evaluate various\nLLMs on their ability to generate tests from OpenAPI specifications. The\nevaluation focused on metrics such as success rate, test coverage, and mutation\nscore, enabling a systematic comparison of model performance. The results\nindicate that the best-performing LLMs - Claude 3.5 Sonnet (Anthropic),\nDeepseek R1 (Deepseek), Qwen 2.5 32b (Alibaba), and Sabia 3 (Maritaca) -\nconsistently produced robust and contextually coherent REST API tests. Among\nthem, Claude 3.5 Sonnet outperformed all other models across every metric,\nemerging in this study as the most suitable model for this task. These findings\nhighlight the potential of LLMs to automate the generation of tests based on\nAPI specifications."}
{"id": "2509.06872", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.06872", "abs": "https://arxiv.org/abs/2509.06872", "authors": ["Zachary Kent", "Ugur Y. Yavuz", "Siddhartha Jayanti", "Stephanie Balzer", "Guy Blelloch"], "title": "Mechanized Metatheory of Forward Reasoning for End-to-End Linearizability Proofs", "comment": null, "summary": "In the past decade, many techniques have been developed to prove\nlinearizability, the gold standard of correctness for concurrent data\nstructures. Intuitively, linearizability requires that every operation on a\nconcurrent data structure appears to take place instantaneously, even when\ninterleaved with other operations. Most recently, Jayanti et al. presented the\nfirst sound and complete \"forward reasoning\" technique for proving\nlinearizability that relates the behavior of a concurrent data structure to a\nreference atomic data structure as time moves forward. This technique can be\nused to produce machine-checked proofs of linearizability in TLA+. However,\nwhile Jayanti et al.'s approach is shown to be sound and complete, a\nmechanization of this important metatheoretic result is still outstanding. As a\nresult, it is not possible to produce verified end-to-end proofs of\nlinearizability. To reduce the size of this trusted computing base, we\nformalize this forward reasoning technique and mechanize proofs of its\nsoundness and completeness in Rocq. As a case study, we use the approach to\nproduce a verified end-to-end proof of linearizability for a simple concurrent\nregister."}
{"id": "2509.05585", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.05585", "abs": "https://arxiv.org/abs/2509.05585", "authors": ["Zhiyuan Zou", "Bangchao Wang", "Peng Liang", "Tingting Bi", "Huan Jin"], "title": "Natural Language-Programming Language Software Traceability Link Recovery Needs More than Textual Similarity", "comment": "45 pages, 5 images, 11 tables, Manuscript submitted to a Journal\n  (2025)", "summary": "In the field of software traceability link recovery (TLR), textual similarity\nhas long been regarded as the core criterion. However, in tasks involving\nnatural language and programming language (NL-PL) artifacts, relying solely on\ntextual similarity is limited by their semantic gap. To this end, we conducted\na large-scale empirical evaluation across various types of TLR tasks, revealing\nthe limitations of textual similarity in NL-PL scenarios. To address these\nlimitations, we propose an approach that incorporates multiple domain-specific\nauxiliary strategies, identified through empirical analysis, into two models:\nthe Heterogeneous Graph Transformer (HGT) via edge types and the prompt-based\nGemini 2.5 Pro via additional input information. We then evaluated our approach\nusing the widely studied requirements-to-code TLR task, a representative case\nof NL-PL TLR. Experimental results show that both the multi-strategy HGT and\nGemini 2.5 Pro models outperformed their original counterparts without strategy\nintegration. Furthermore, compared to the current state-of-the-art method\nHGNNLink, the multi-strategy HGT and Gemini 2.5 Pro models achieved average\nF1-score improvements of 3.68% and 8.84%, respectively, across twelve\nopen-source projects, demonstrating the effectiveness of multi-strategy\nintegration in enhancing overall model performance for the requirements-code\nTLR task."}
{"id": "2509.05596", "categories": ["cs.SE", "cs.SC", "68", "D.3.1; D.2.4"], "pdf": "https://arxiv.org/pdf/2509.05596", "abs": "https://arxiv.org/abs/2509.05596", "authors": ["Soumyadip Bandyopadhyay", "Santonu Sarkar"], "title": "Verifying Correctness of PLC Software during System Evolution using Model Containment Approach", "comment": "31 pages with appendix", "summary": "Upgradation of Programmable Logic Controller (PLC) software is quite common\nto accommodate evolving industrial requirements. Verifying the correctness of\nsuch upgrades remains a significant challenge. In this paper, we propose a\nverification-based approach to ensure the correctness of the existing\nfunctionality in the upgraded version of a PLC software. The method converts\nthe older and the newer versions of the sequential function chart (SFC) into\ntwo Petri net models. We then verify whether one model is contained within\nanother, based on a novel containment checking algorithm grounded in symbolic\npath equivalence. For this purpose, we have developed a home-grown Petri\nnet-based containment checker. Experimental evaluation on 80 real-world\nbenchmarks from the OSCAT library highlights the scalability and effectiveness\nof the framework. We have compared our approach with verifAPS, a popular tool\nused for software upgradation, and observed nearly 4x performance improvement."}
{"id": "2509.05749", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.05749", "abs": "https://arxiv.org/abs/2509.05749", "authors": ["AmirHossein Naghshzan"], "title": "Automating API Documentation with LLMs: A BERTopic Approach", "comment": null, "summary": "Developers rely on API documentation, but official sources are often lengthy,\ncomplex, or incomplete. Many turn to community-driven forums like Stack\nOverflow for practical insights. We propose automating the summarization of\ninformal sources, focusing on Android APIs. Using BERTopic, we extracted\nprevalent topics from 3.6 million Stack Overflow posts and applied extractive\nsummarization techniques to generate concise summaries, including code\nsnippets. A user study with 30 Android developers assessed the summaries for\ncoherence, relevance, informativeness, and satisfaction, showing improved\nproductivity. Integrating formal API knowledge with community-generated content\nenhances documentation, making API resources more accessible and actionable\nwork."}
{"id": "2509.05769", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.05769", "abs": "https://arxiv.org/abs/2509.05769", "authors": ["Edyta Brzychczy", "Urszula Jessen", "Krzysztof Kluza", "Sridhar Sriram", "Manuel Vargas Nettelnstroth"], "title": "IoT Miner: Intelligent Extraction of Event Logs from Sensor Data for Process Mining", "comment": "17 pages, conference draft", "summary": "This paper presents IoT Miner, a novel framework for automatically creating\nhigh-level event logs from raw industrial sensor data to support process\nmining. In many real-world settings, such as mining or manufacturing, standard\nevent logs are unavailable, and sensor data lacks the structure and semantics\nneeded for analysis. IoT Miner addresses this gap using a four-stage pipeline:\ndata preprocessing, unsupervised clustering, large language model (LLM)-based\nlabeling, and event log construction. A key innovation is the use of LLMs to\ngenerate meaningful activity labels from cluster statistics, guided by\ndomain-specific prompts. We evaluate the approach on sensor data from a\nLoad-Haul-Dump (LHD) mining machine and introduce a new metric,\nSimilarity-Weighted Accuracy, to assess labeling quality. Results show that\nricher prompts lead to more accurate and consistent labels. By combining AI\nwith domain-aware data processing, IoT Miner offers a scalable and\ninterpretable method for generating event logs from IoT data, enabling process\nmining in settings where traditional logs are missing."}
{"id": "2509.05881", "categories": ["cs.SE", "cs.AI", "I.2"], "pdf": "https://arxiv.org/pdf/2509.05881", "abs": "https://arxiv.org/abs/2509.05881", "authors": ["Qianheng Zhang", "Song Gao", "Chen Wei", "Yibo Zhao", "Ying Nie", "Ziru Chen", "Shijie Chen", "Yu Su", "Huan Sun"], "title": "GeoAnalystBench: A GeoAI benchmark for assessing large language models for spatial analysis workflow and code generation", "comment": "34 pages, 8 figures", "summary": "Recent advances in large language models (LLMs) have fueled growing interest\nin automating geospatial analysis and GIS workflows, yet their actual\ncapabilities remain uncertain. In this work, we call for rigorous evaluation of\nLLMs on well-defined geoprocessing tasks before making claims about full GIS\nautomation. To this end, we present GeoAnalystBench, a benchmark of 50\nPython-based tasks derived from real-world geospatial problems and carefully\nvalidated by GIS experts. Each task is paired with a minimum deliverable\nproduct, and evaluation covers workflow validity, structural alignment,\nsemantic similarity, and code quality (CodeBLEU). Using this benchmark, we\nassess both proprietary and open source models. Results reveal a clear gap:\nproprietary models such as ChatGPT-4o-mini achieve high validity 95% and\nstronger code alignment (CodeBLEU 0.39), while smaller open source models like\nDeepSeek-R1-7B often generate incomplete or inconsistent workflows (48.5%\nvalidity, 0.272 CodeBLEU). Tasks requiring deeper spatial reasoning, such as\nspatial relationship detection or optimal site selection, remain the most\nchallenging across all models. These findings demonstrate both the promise and\nlimitations of current LLMs in GIS automation and provide a reproducible\nframework to advance GeoAI research with human-in-the-loop support."}
{"id": "2509.05941", "categories": ["cs.SE", "cs.LG", "cs.MA"], "pdf": "https://arxiv.org/pdf/2509.05941", "abs": "https://arxiv.org/abs/2509.05941", "authors": ["Chaoqian Ouyang", "Ling Yue", "Shimin Di", "Libin Zheng", "Shaowu Pan", "Min-Ling Zhang"], "title": "Code2MCP: A Multi-Agent Framework for Automated Transformation of Code Repositories into Model Context Protocol Services", "comment": null, "summary": "The proliferation of Large Language Models (LLMs) has created a significant\nintegration challenge in the AI agent ecosystem, often called the \"$N \\times M$\nproblem,\" where N models require custom integrations for M tools. This\nfragmentation stifles innovation and creates substantial development overhead.\nWhile the Model Context Protocol (MCP) has emerged as a standard to resolve\nthis, its adoption is hindered by the manual effort required to convert the\nvast universe of existing software into MCP-compliant services. This is\nespecially true for the millions of open-source repositories on GitHub, the\nworld's largest collection of functional code. This paper introduces Code2MCP,\na highly automated, agentic framework designed to transform any GitHub\nrepository into a functional MCP service with minimal human intervention. Our\nsystem employs a multi-stage workflow that automates the entire process, from\ncode analysis and environment configuration to service generation and\ndeployment. A key innovation of our framework is an LLM-driven, closed-loop\n\"Run--Review--Fix\" cycle, which enables the system to autonomously debug and\nrepair the code it generates. Code2MCP produces not only deployable services\nbut also comprehensive technical documentation, acting as a catalyst to\naccelerate the MCP ecosystem by systematically unlocking the world's largest\nopen-source code repository and automating the critical last mile of tool\nintegration. The code is open-sourced at\nhttps://github.com/DEFENSE-SEU/MCP-Github-Agent."}
{"id": "2509.05980", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.05980", "abs": "https://arxiv.org/abs/2509.05980", "authors": ["Xingliang Wang", "Baoyi Wang", "Chen Zhi", "Junxiao Han", "Xinkui Zhao", "Jianwei Yin", "Shuiguang Deng"], "title": "GRACE: Graph-Guided Repository-Aware Code Completion through Hierarchical Code Fusion", "comment": null, "summary": "LLMs excel in localized code completion but struggle with repository-level\ntasks due to limited context windows and complex semantic and structural\ndependencies across codebases. While Retrieval-Augmented Generation (RAG)\nmitigates context scarcity by retrieving relevant code snippets, current\napproaches face significant limitations. They overly rely on textual similarity\nfor retrieval, neglecting structural relationships such as call chains and\ninheritance hierarchies, and lose critical structural information by naively\nconcatenating retrieved snippets into text sequences for LLM input. To address\nthese shortcomings, GRACE constructs a multi-level, multi-semantic code graph\nthat unifies file structures, abstract syntax trees, function call graphs,\nclass hierarchies, and data flow graphs to capture both static and dynamic code\nsemantics. For retrieval, GRACE employs a Hybrid Graph Retriever that\nintegrates graph neural network-based structural similarity with textual\nretrieval, refined by a graph attention network-based re-ranker to prioritize\ntopologically relevant subgraphs. To enhance context, GRACE introduces a\nstructural fusion mechanism that merges retrieved subgraphs with the local code\ncontext and preserves essential dependencies like function calls and\ninheritance. Extensive experiments on public repository-level benchmarks\ndemonstrate that GRACE significantly outperforms state-of-the-art methods\nacross all metrics. Using DeepSeek-V3 as the backbone LLM, GRACE surpasses the\nstrongest graph-based RAG baselines by 8.19% EM and 7.51% ES points on every\ndataset. The code is available at\nhttps://anonymous.4open.science/r/grace_icse-C3D5."}
{"id": "2509.05995", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.05995", "abs": "https://arxiv.org/abs/2509.05995", "authors": ["Sharon Guardado", "Risha Parveen", "Zheying Zhang", "Maruf Rayhan", "Nirnaya Tripathi"], "title": "Students' Perception of LLM Use in Requirements Engineering Education: An Empirical Study Across Two Universities", "comment": "Accepted by the 33rd IEEE International Requirements Engineering 2025\n  (RE'25), Valencia, Spain, September 1-5, 2025", "summary": "The integration of Large Language Models (LLMs) in Requirements Engineering\n(RE) education is reshaping pedagogical approaches, seeking to enhance student\nengagement and motivation while providing practical tools to support their\nprofessional future. This study empirically evaluates the impact of integrating\nLLMs in RE coursework. We examined how the guided use of LLMs influenced\nstudents' learning experiences, and what benefits and challenges they perceived\nin using LLMs in RE practices. The study collected survey data from 179\nstudents across two RE courses in two universities. LLMs were integrated into\ncoursework through different instructional formats, i.e., individual\nassignments versus a team-based Agile project. Our findings indicate that LLMs\nimproved students' comprehension of RE concepts, particularly in tasks like\nrequirements elicitation and documentation. However, students raised concerns\nabout LLMs in education, including academic integrity, overreliance on AI, and\nchallenges in integrating AI-generated content into assignments. Students who\nworked on individual assignments perceived that they benefited more than those\nwho worked on team-based assignments, highlighting the importance of contextual\nAI integration. This study offers recommendations for the effective integration\nof LLMs in RE education. It proposes future research directions for balancing\nAI-assisted learning with critical thinking and collaborative practices in RE\ncourses."}
{"id": "2509.06012", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06012", "abs": "https://arxiv.org/abs/2509.06012", "authors": ["Jukka Ruohonen"], "title": "A Rapid Review Regarding the Concept of Legal Requirements in Requirements Engineering", "comment": "Submitted to REFSQ 2026", "summary": "Out of a personal puzzlement, recent peer review comments, and demonstrable\nconfusion in the existing literature, the paper presents a rapid review of the\nconcept of legal requirements (LRs) in requirements engineering (RE) research.\nAccording to reviewing results, a normative understanding of LRs has often been\npresent, although proper definitions and conceptual operationalizations are\nlacking. Some papers also see LRs as functional and others as non-functional\nrequirements. Legal requirements are often characterized as being vague and\ncomplex, requiring a lot of effort to elicit, implement, and validate. These\ncharacterizations supposedly correlate with knowledge gaps among requirements\nengineers. LRs are also seen to often change and overlap. They may be also\nprioritized. According to the literature, they seem to be also reluctantly\nimplemented, often providing only a minimal baseline for other requirements.\nWith these and other observations, the review raises critical arguments about\napparent knowledge gaps, including a lack of empirical evidence backing the\nobservations and enduring conceptual confusion."}
{"id": "2509.06052", "categories": ["cs.SE", "cs.AI", "cs.CR"], "pdf": "https://arxiv.org/pdf/2509.06052", "abs": "https://arxiv.org/abs/2509.06052", "authors": ["Qingyuan Li", "Binchang Li", "Cuiyun Gao", "Shuzheng Gao", "Zongjie Li"], "title": "Empirical Study of Code Large Language Models for Binary Security Patch Detection", "comment": null, "summary": "Security patch detection (SPD) is crucial for maintaining software security,\nas unpatched vulnerabilities can lead to severe security risks. In recent\nyears, numerous learning-based SPD approaches have demonstrated promising\nresults on source code. However, these approaches typically cannot be applied\nto closed-source applications and proprietary systems that constitute a\nsignificant portion of real-world software, as they release patches only with\nbinary files, and the source code is inaccessible. Given the impressive\nperformance of code large language models (LLMs) in code intelligence and\nbinary analysis tasks such as decompilation and compilation optimization, their\npotential for detecting binary security patches remains unexplored, exposing a\nsignificant research gap between their demonstrated low-level code\nunderstanding capabilities and this critical security task. To address this\ngap, we construct a large-scale binary patch dataset containing \\textbf{19,448}\nsamples, with two levels of representation: assembly code and pseudo-code, and\nsystematically evaluate \\textbf{19} code LLMs of varying scales to investigate\ntheir capability in binary SPD tasks. Our initial exploration demonstrates that\ndirectly prompting vanilla code LLMs struggles to accurately identify security\npatches from binary patches, and even state-of-the-art prompting techniques\nfail to mitigate the lack of domain knowledge in binary SPD within vanilla\nmodels. Drawing on the initial findings, we further investigate the fine-tuning\nstrategy for injecting binary SPD domain knowledge into code LLMs through two\nlevels of representation. Experimental results demonstrate that fine-tuned LLMs\nachieve outstanding performance, with the best results obtained on the\npseudo-code representation."}
{"id": "2509.06085", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.06085", "abs": "https://arxiv.org/abs/2509.06085", "authors": ["Jerin Yasmin", "Wenxin Jiang", "James C. Davis", "Yuan Tian"], "title": "Software Dependencies 2.0: An Empirical Study of Reuse and Integration of Pre-Trained Models in Open-Source Projects", "comment": "Submitted to Empirical Software Engineering (EMSE) Journal", "summary": "Pre-trained models (PTMs) are machine learning models that have been trained\nin advance, often on large-scale data, and can be reused for new tasks, thereby\nreducing the need for costly training from scratch. Their widespread adoption\nintroduces a new class of software dependency, which we term Software\nDependencies 2.0, extending beyond conventional libraries to learned behaviors\nembodied in trained models and their associated artifacts. The integration of\nPTMs as software dependencies in real projects remains unclear, potentially\nthreatening maintainability and reliability of modern software systems that\nincreasingly rely on them. Objective: In this study, we investigate Software\nDependencies 2.0 in open-source software (OSS) projects by examining the reuse\nof PTMs, with a focus on how developers manage and integrate these models.\nSpecifically, we seek to understand: (1) how OSS projects structure and\ndocument their PTM dependencies; (2) what stages and organizational patterns\nemerge in the reuse pipelines of PTMs within these projects; and (3) the\ninteractions among PTMs and other learned components across pipeline stages. We\nconduct a mixed-methods analysis of a statistically significant random sample\nof 401 GitHub repositories from the PeaTMOSS dataset (28,575 repositories\nreusing PTMs from Hugging Face and PyTorch Hub). We quantitatively examine PTM\nreuse by identifying patterns and qualitatively investigate how developers\nintegrate and manage these models in practice."}
{"id": "2509.06216", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.06216", "abs": "https://arxiv.org/abs/2509.06216", "authors": ["Ahmed E. Hassan", "Hao Li", "Dayi Lin", "Bram Adams", "Tse-Hsun Chen", "Yutaro Kashiwa", "Dong Qiu"], "title": "Agentic Software Engineering: Foundational Pillars and a Research Roadmap", "comment": null, "summary": "Agentic Software Engineering (SE 3.0) represents a new era where intelligent\nagents are tasked not with simple code generation, but with achieving complex,\ngoal-oriented SE objectives. To harness these new capabilities while ensuring\ntrustworthiness, we must recognize a fundamental duality within the SE field in\nthe Agentic SE era, comprising two symbiotic modalities: SE for Humans and SE\nfor Agents. This duality demands a radical reimagining of the foundational\npillars of SE (actors, processes, tools, and artifacts) which manifest\ndifferently across each modality. We propose two purpose-built workbenches to\nsupport this vision. The Agent Command Environment (ACE) serves as a command\ncenter where humans orchestrate and mentor agent teams, handling outputs such\nas Merge-Readiness Packs (MRPs) and Consultation Request Packs (CRPs). The\nAgent Execution Environment (AEE) is a digital workspace where agents perform\ntasks while invoking human expertise when facing ambiguity or complex\ntrade-offs. This bi-directional partnership, which supports agent-initiated\nhuman callbacks and handovers, gives rise to new, structured engineering\nactivities (i.e., processes) that redefine human-AI collaboration, elevating\nthe practice from agentic coding to true agentic software engineering. This\npaper presents the Structured Agentic Software Engineering (SASE) vision,\noutlining several of the foundational pillars for the future of SE. The paper\nculminates in a research roadmap that identifies a few key challenges and\nopportunities while briefly discussing the resulting impact of this future on\nSE education. Our goal is not to offer a definitive solution, but to provide a\nconceptual scaffold with structured vocabulary to catalyze a community-wide\ndialogue, pushing the SE community to think beyond its classic, human-centric\ntenets toward a disciplined, scalable, and trustworthy agentic future."}
{"id": "2509.06301", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06301", "abs": "https://arxiv.org/abs/2509.06301", "authors": ["Dharun Anandayuvaraj", "Zain Hammadeh", "Andreas Lund", "Alexandra Holloway", "James C. Davis"], "title": "Learning From Software Failures: A Case Study at a National Space Research Center", "comment": null, "summary": "Software failures can have significant consequences, making learning from\nfailures a critical aspect of software engineering. While software\norganizations are recommended to conduct postmortems, the effectiveness and\nadoption of these practices vary widely. Understanding how engineers gather,\ndocument, share, and apply lessons from failures is essential for improving\nreliability and preventing recurrence. High-reliability organizations (HROs)\noften develop software systems where failures carry catastrophic risks,\nrequiring continuous learning to ensure reliability. These organizations\nprovide a valuable setting to examine practices and challenges for learning\nfrom software failures. Such insight could help develop processes and tools to\nimprove reliability and prevent recurrence. However, we lack in-depth industry\nperspectives on the practices and challenges of learning from failures.\n  To address this gap, we conducted a case study through 10 in-depth interviews\nwith research software engineers at a national space research center. We\nexamine how they learn from failures: how they gather, document, share, and\napply lessons. To assess transferability, we include data from 5 additional\ninterviews at other HROs. Our findings provide insight into how engineers learn\nfrom failures in practice. To summarize: (1) failure learning is informal, ad\nhoc, and inconsistently integrated into SDLC; (2) recurring failures persist\ndue to absence of structured processes; and (3) key challenges, including time\nconstraints, knowledge loss from turnover and fragmented documentation, and\nweak process enforcement, undermine systematic learning. Our findings deepen\nunderstanding of how software engineers learn from failures and offer guidance\nfor improving failure management practices."}
{"id": "2509.06324", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06324", "abs": "https://arxiv.org/abs/2509.06324", "authors": ["Zhuohang Shen", "Mohammed Yaseen", "Denini Silva", "Kevin Guan", "Junho Lee", "Marcelo d'Amorim", "Owolabi Legunsen"], "title": "A Generic and Efficient Python Runtime Verification System and its Large-scale Evaluation", "comment": "23 pages, 7 figures", "summary": "Runtime verification (RV) now scales for testing thousands of open-source\nJava projects, helping find hundreds of bugs. The popular Python ecosystem\ncould use such benefits. But, today's Python RV systems are limited to a domain\nor specification logic, or slow. We propose PyMOP, a generic, extensible, and\nefficient RV system for Python. PyMOP supports five logics, implements five\nexisting monitoring algorithms, ships with 73 API specs of Python and\nwidely-used libraries, supports three instrumentation strategies, and users can\neasily add more of these. On 290,133 unit tests in 1,463 GitHub projects, we\nfind mainly that (i) the default monitoring algorithm for Java is often not the\nfastest for Python; (ii) PyMOP is up to 1,168.3x faster than two recent dynamic\nanalysis systems; and (iii) 44 of 121 bugs that PyMOP helped find so far were\nfixed by developers. PyMOP's generality and efficiency position it well as an\nexcellent platform for the next advances on RV for Python."}
{"id": "2509.06429", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06429", "abs": "https://arxiv.org/abs/2509.06429", "authors": ["Mehmet Bilal Er", "Nagehan İlhan", "Umut Kuran"], "title": "Analyzing the Instability of Large Language Models in Automated Bug Injection and Correction", "comment": null, "summary": "The use of Large Language Models (LLMs) in software engineering tasks is\ngrowing, especially in the areas of bug fixing and code generation.\nNevertheless, these models often yield unstable results; when executed at\ndifferent times with the same input, they can generate radically different\ncode. The consistency of LLMs in bug-fixing tasks has not yet been thoroughly\nassessed, despite the fact that this instability has typically been discussed\nin the literature in relation to code generation. The purpose of this study is\nto look into how unstable an LLM like ChatGPT is when it comes to fixing code\nbugs. We examine the structural, syntactic, and functional variations among\nseveral fix recommendations made in response to the same prompt using code\nsamples with various error types. Additionally, we assess how instability is\naffected by the temperature settings (0, 0.5, and 1) used for the model's\ndeterministic operation. For a total of 20 problems in the experimental\nanalysis, the model produced three fix suggestions at each temperature value,\ncomparing nine distinct outputs for each problem. The Syntax Similarity and\nOutput Equivalence Rate (OER) metrics were used to assess the outputs'\nstructural and functional consistency. The results demonstrate that the model's\noutputs become much more unstable and variable as the temperature rises, with\nhigh temperatures showing especially high rates of functional failure.\nAccording to syntax similarity analyses, the suggested fixes show notable\nstructural differences at high temperatures but are fairly similar at low\ntemperatures. The purpose of this study is to provide important methodological\ninsights into how LLM-based error correction systems can be applied more\nconsistently in software development processes while also casting doubt on\ntheir dependability."}
{"id": "2509.06530", "categories": ["cs.SE", "D.2.10"], "pdf": "https://arxiv.org/pdf/2509.06530", "abs": "https://arxiv.org/abs/2509.06530", "authors": ["Sylvain Guérin", "Salvador Martinez", "Ciprian Teodorov"], "title": "Modeling in the Design Multiverse", "comment": null, "summary": "Real-world design processes often involve the evolution and divergence of\ndesign paths (by branching, revising, merging, etc.), especially when multiple\nstakeholders or teams operate concurrently and/or explore different\nalternatives for complex and heterogeneous systems. Unfortunately, this\nvariability in time and space can not be directly managed in current modeling\nspaces but requires resorting to external tools and methodologies.\n  In order to tackle this problem, we introduce the Design Multiverse. The\nDesign Multiverse aims to integrate in the modeling space a selection of\nrevisions and variants, representing snapshots of a design state composed of\nmultiple artifacts. This enables stakeholders to seamlessly trace, analyze, and\nmanage design decisions, system variants, and their interdependencies.\nConcretely, in this paper we present a conceptual definition of the Design\nMultiverse, discuss usage scenarios such as model product lines and\nmodel/metamodel co-evolution, and propose an implementation leveraging the\nmodel federation paradigm."}
{"id": "2509.06688", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06688", "abs": "https://arxiv.org/abs/2509.06688", "authors": ["Heerok Banerjee"], "title": "Design and Implementation of a Domain-specific Language for Modelling Evacuation Scenarios Using Eclipse EMG/GMF Tool", "comment": null, "summary": "Domain-specific languages (DSLs) play a crucial role in resolving internal\ndependencies across enterprises and boosts their upfront business management\nprocesses. Yet, a lot of development is needed to build modelling frameworks\nwhich support graphical interfaces (canvas, pallettes etc.), hierarchical\nstructures and easy implementation to shorten the gap for novice users. In this\npaper, a DSL namely, Bmod is introduced, which can be used to model evacuation\nscenarios. The language is built using Eclipse Modelling Framework (EMF) and\nEclipse Graphical Modelling Framework (GMF). Furthermore, a comparison is also\nshown between Eclipse EMF/GMF and other modelling tools such as AToMPM,\nmetaDepth, Sirius etc with respect to expressiveness, learning curve and\nperformance."}
{"id": "2509.06716", "categories": ["cs.SE", "cs.PF"], "pdf": "https://arxiv.org/pdf/2509.06716", "abs": "https://arxiv.org/abs/2509.06716", "authors": ["Théo Matricon", "Mathieu Acher", "Helge Spieker", "Arnaud Gotlieb"], "title": "Efficiently Ranking Software Variants with Minimal Benchmarks", "comment": null, "summary": "Benchmarking is a common practice in software engineering to assess the\nqualities and performance of software variants, coming from multiple competing\nsystems or from configurations of the same system. Benchmarks are used notably\nto compare and understand variant performance, fine-tune software, detect\nregressions, or design new software systems. The execution of benchmarks to get\na complete picture of software variants is highly costly in terms of\ncomputational resources and time. In this paper, we propose a novel approach\nfor reducing benchmarks while maintaining stable rankings, using test suite\noptimization techniques. That is, we remove instances from the benchmarks while\ntrying to keep the same rankings of the variants on all tests. Our method,\nBISection Sampling, BISS, strategically retains the most critical tests and\napplies a novel divide-and-conquer approach to efficiently sample among\nrelevant remaining tests. We experiment with datasets and use cases from LLM\nleaderboards, SAT competitions, and configurable systems for performance\nmodeling. Our results show that our method outperforms baselines even when\noperating on a subset of variants. Using BISS, we reduce the computational cost\nof the benchmarks on average to 44% and on more than half the benchmarks by up\nto 99% without loss in ranking stability."}
{"id": "2509.06774", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06774", "abs": "https://arxiv.org/abs/2509.06774", "authors": ["Hridoy Sankar Dutta", "Sana Ansari", "Swati Kumari", "Shounak Ravi Bhalerao"], "title": "OpenCoderRank: AI-Driven Technical Assessments Made Easy", "comment": null, "summary": "Organizations and educational institutions use time-bound assessment tasks to\nevaluate coding and problem-solving skills. These assessments measure not only\nthe correctness of the solutions, but also their efficiency. Problem setters\n(educator/interviewer) are responsible for crafting these challenges, carefully\nbalancing difficulty and relevance to create meaningful evaluation experiences.\nConversely, problem solvers (student/interviewee) apply coding efficiency and\nlogical thinking to arrive at correct solutions. In the era of Large Language\nModels (LLMs), LLMs assist problem setters in generating diverse and\nchallenging questions, but they can undermine assessment integrity for problem\nsolvers by providing easy access to solutions. This paper introduces\nOpenCoderRank, an easy-to-use platform designed to simulate technical\nassessments. It acts as a bridge between problem setters and problem solvers,\nhelping solvers prepare for time constraints and unfamiliar problems while\nallowing setters to self-host assessments, offering a no-cost and customizable\nsolution for technical assessments in resource-constrained environments."}
{"id": "2509.06911", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.06911", "abs": "https://arxiv.org/abs/2509.06911", "authors": ["Margarida Ferreira", "Victor Nicolet", "Luan Pham", "Joey Dodds", "Daniel Kroening", "Ines Lynce", "Ruben Martins"], "title": "Hypergraph-Guided Regex Filter Synthesis for Event-Based Anomaly Detection", "comment": null, "summary": "We propose HyGLAD, a novel algorithm that automatically builds a set of\ninterpretable patterns that model event data. These patterns can then be used\nto detect event-based anomalies in a stationary system, where any deviation\nfrom past behavior may indicate malicious activity. The algorithm infers\nequivalence classes of entities with similar behavior observed from the events,\nand then builds regular expressions that capture the values of those entities.\nAs opposed to deep-learning approaches, the regular expressions are directly\ninterpretable, which also translates to interpretable anomalies. We evaluate\nHyGLAD against all 7 unsupervised anomaly detection methods from DeepOD on five\ndatasets from real-world systems. The experimental results show that on average\nHyGLAD outperforms existing deep-learning methods while being an order of\nmagnitude more efficient in training and inference (single CPU vs GPU).\nPrecision improved by 1.2x and recall by 1.3x compared to the second-best\nbaseline."}
{"id": "2509.06845", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06845", "abs": "https://arxiv.org/abs/2509.06845", "authors": ["Tom Lauwaerts", "Maarten Steevens", "Christophe Scholliers"], "title": "MIO: Multiverse Debugging in the Face of Input/Output -- Extended Version with Additional Appendices", "comment": "This extended version provides auxiliary material to the article of\n  the same title that will appear in the ACM Digital Library as part of the\n  PACMPL issue for OOPSLA 2025", "summary": "Debugging non-deterministic programs on microcontrollers is notoriously\nchallenging, especially when bugs manifest in unpredictable, input-dependent\nexecution paths. A recent approach, called multiverse debugging, makes it\neasier to debug non-deterministic programs by allowing programmers to explore\nall potential execution paths. Current multiverse debuggers enable both forward\nand backward traversal of program paths, and some facilitate jumping to any\npreviously visited states, potentially branching into alternative execution\npaths within the state space.\n  Unfortunately, debugging programs that involve input/output operations using\nexisting multiverse debuggers can reveal inaccessible program states, i.e.\nstates which are not encountered during regular execution. This can\nsignificantly hinder the debugging process, as the programmer may spend\nsubstantial time exploring and examining inaccessible program states, or worse,\nmay mistakenly assume a bug is present in the code, when in fact, the issue is\ncaused by the debugger.\n  This paper presents a novel approach to multiverse debugging, which can\naccommodate a broad spectrum of input/output operations. We provide the\nsemantics of our approach and prove the correctness of our debugger, ensuring\nthat despite having support for a wide range of input/output operations the\ndebugger will only explore those program states which can be reached during\nregular execution.\n  We have developed a prototype, called MIO, leveraging the WARDuino\nWebAssembly virtual machine to demonstrate the feasibility and efficiency of\nour techniques. As a demonstration of the approach we highlight a color dial\nbuilt with a Lego Mindstorms motor, and color sensor, providing a tangible\nexample of how our approach enables multiverse debugging for programs running\non an STM32 microcontroller."}
