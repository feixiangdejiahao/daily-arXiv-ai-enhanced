<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 18]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [How Software Engineers Engage with AI: A Pragmatic Process Model and Decision Framework Grounded in Industry Observations](https://arxiv.org/abs/2507.17930)
*Vahid Garousi,Zafar Jafarov*

Main category: cs.SE

TL;DR: This paper presents models and frameworks based on industry observations to guide software engineers in the effective, practical use of AI tools, addressing the challenges and decision points in real-world AI-assisted development.


<details>
  <summary>Details</summary>
Motivation: AI tools are increasingly integrated into Software Engineering, introducing new ways of working (like 'vibe coding'), but there is limited understanding of how engineers interact with, evaluate, and manage these AI-assisted processes in practice.

Method: The paper is based on practitioner reports and direct observations in three industry settings in Turkiye and Azerbaijan. It develops models and frameworks from real-world experiences to capture and analyze how engineers use AI tools.

Result: The authors present a pragmatic process model outlining core activities in AI-assisted SE (like prompt design, inspection, fallback, and refinement) and introduce a 2D decision framework that helps developers weigh effort and output quality. These are demonstrated with examples from industry settings.

Conclusion: The process model and decision framework provide structured, lightweight guidance for engineers, supporting more thoughtful and effective use of AI tools in Software Engineering. This work enhances practical understanding and management of human-AI collaboration in industrial contexts.

Abstract: Artificial Intelligence (AI) has the potential to transform Software
Engineering (SE) by enhancing productivity, efficiency, and decision support.
Tools like GitHub Copilot and ChatGPT have given rise to "vibe coding"-an
exploratory, prompt-driven development style. Yet, how software engineers
engage with these tools in daily tasks, especially in deciding whether to
trust, refine, or reject AI-generated outputs, remains underexplored. This
paper presents two complementary contributions. First, a pragmatic process
model capturing real-world AI-assisted SE activities, including prompt design,
inspection, fallback, and refinement. Second, a 2D decision framework that
could help developers reason about trade-offs between effort saved and output
quality. Grounded in practitioner reports and direct observations in three
industry settings across Turkiye and Azerbaijan, our work illustrates how
engineers navigate AI use with human oversight. These models offer structured,
lightweight guidance to support more deliberate and effective use of AI tools
in SE, contributing to ongoing discussions on practical human-AI collaboration.

</details>


### [2] [Use as Directed? A Comparison of Software Tools Intended to Check Rigor and Transparency of Published Work](https://arxiv.org/abs/2507.17991)
*Peter Eckmann,Adrian Barnett,Alexandra Bannach-Brown,Elisa Pilar Bascunan Atria,Guillaume Cabanac,Louise Delwen Owen Franzen,Małgorzata Anna Gazda,Kaitlyn Hair,James Howison,Halil Kilicoglu,Cyril Labbe,Sarah McCann,Vladislav Nachev,Martijn Roelandse,Maia Salholz-Hillel,Robert Schulz,Gerben ter Riet,Colby Vorland,Anita Bandrowski,Tracey Weissgerber*

Main category: cs.SE

TL;DR: The paper compares 11 automated tools for scientific reporting rigor, finding certain tools excel at specific tasks while combining tools improves overall performance. Recommendations for future tool development are provided.


<details>
  <summary>Details</summary>
Motivation: There is a reproducibility crisis in science partly due to insufficient standardization and transparency in scientific reporting. Existing checklists are underused or inadequately enforced, and automated tools intended to help are growing but need evaluation.

Method: The authors conducted a broad comparison involving 11 automated tools designed to check scientific rigor. These tools were tested across 9 different rigor criteria established by the ScreenIT group.

Result: Some tools performed significantly better for specific criteria, such as open data detection, while in other cases, combining multiple tools improved detection accuracy beyond any single tool. Areas where tool developers should improve were also identified.

Conclusion: The study provides recommendations and insights for stakeholders developing tools for rigor and transparency detection in scientific reporting. It highlights both the value of combining multiple tools and the need for focused improvement in specific areas.

Abstract: The causes of the reproducibility crisis include lack of standardization and
transparency in scientific reporting. Checklists such as ARRIVE and CONSORT
seek to improve transparency, but they are not always followed by authors and
peer review often fails to identify missing items. To address these issues,
there are several automated tools that have been designed to check different
rigor criteria. We have conducted a broad comparison of 11 automated tools
across 9 different rigor criteria from the ScreenIT group. We found some
criteria, including detecting open data, where the combination of tools showed
a clear winner, a tool which performed much better than other tools. In other
cases, including detection of inclusion and exclusion criteria, the combination
of tools exceeded the performance of any one tool. We also identified key areas
where tool developers should focus their effort to make their tool maximally
useful. We conclude with a set of insights and recommendations for stakeholders
in the development of rigor and transparency detection tools. The code and data
for the study is available at https://github.com/PeterEckmann1/tool-comparison.

</details>


### [3] [An Empirical Study of GenAI Adoption in Open-Source Game Development: Tools, Tasks, and Developer Challenges](https://arxiv.org/abs/2507.18029)
*Xiang Echo Chen,Wenhan Zhu,Guoshuai Albert Shi,Michael W. Godfrey*

Main category: cs.SE

TL;DR: This paper analyzes GitHub discussions to compare how generative AI, traditional AI, and non-AI tools are used and integrated in open-source game development. It finds GenAI brings distinct opportunities and challenges, and its impact is different from traditional AI approaches.


<details>
  <summary>Details</summary>
Motivation: Generative AI (GenAI) is rapidly influencing game design and development, offering new potential for content creation and design ideation. However, there is little empirical knowledge about how GenAI is actually used and integrated by developers, particularly in open-source communities. The paper aims to fill this gap in understanding.

Method: The study collects and analyzes issue discussions from GitHub open-source game repositories that mention AI-related topics. It uses open card sorting and thematic analysis on a stratified sample of these issues to label and categorize them. The comparison is made between issues involving GenAI, traditional AI (TradAI), and non-AI (NonAI) topics to understand differences in usage, concerns, and integration.

Result: The comparative analysis reveals distinct patterns in how GenAI is discussed, adopted, and integrated compared to TradAI and NonAI. These results highlight the unique opportunities, workflows, and challenges GenAI introduces to open-source game development, as well as developers' specific concerns and pain points.

Conclusion: GenAI is reshaping open-source game development in unique ways compared to traditional and non-AI approaches. The integration of GenAI introduces new workflows and challenges, making it important to understand its use in practical, real-world settings. This paper aids understanding by providing empirical insights from GitHub issue discussions in the open-source community.

Abstract: The growing capabilities of generative AI (GenAI) have begun to reshape how
games are designed and developed, offering new tools for content creation,
gameplay simulation, and design ideation. While prior research has explored
traditional uses of AI in games, such as controlling agents or generating
procedural content. There is limited empirical understanding of how GenAI is
adopted by developers in real-world contexts, especially within the open-source
community. This study aims to explore how GenAI technologies are discussed,
adopted, and integrated into open-source game development by analyzing issue
discussions on GitHub. We investigate the tools, tasks, and challenges
associated with GenAI by comparing GenAI-related issues to those involving
traditional AI (TradAI) and NonAI topics. Our goal is to uncover how GenAI
differs from other approaches in terms of usage patterns, developer concerns,
and integration practices. To address this objective, we construct a dataset of
open-source game repositories that discuss AI-related topics. We apply open
card sorting and thematic analysis to a stratified sample of GitHub issues,
labelling each by type and content. These annotations enable comparative
analysis across GenAI, TradAI, and NonAI groups, and provide insight into how
GenAI is shaping the workflows and pain points of open-source game developers.

</details>


### [4] [Your ATs to Ts: MITRE ATT&CK Attack Technique to P-SSCRM Task Mapping](https://arxiv.org/abs/2507.18037)
*Sivana Hamer,Jacob Bowen,Md Nazmul Haque,Chris Madden,Laurie Williams*

Main category: cs.SE

TL;DR: The paper provides a strategic mapping between software supply chain risk management tasks and MITRE ATT&CK attack techniques, helping organizations mitigate threats and bridge multiple security frameworks.


<details>
  <summary>Details</summary>
Motivation: Software supply chain attacks are increasingly common and organizations need practical ways to mitigate these threats by connecting recommended risk management tasks to concrete adversarial techniques.

Method: The authors conducted mapping using four independent strategies to align P-SSCRM tasks with MITRE ATT&CK attack techniques and established connections between these and tasks from ten other frameworks.

Result: A comprehensive mapping was produced, allowing organizations to see which P-SSCRM tasks help mitigate specific ATT&CK techniques and how these tasks relate to other government and industry frameworks.

Conclusion: This mapping serves as an actionable resource for organizations to enhance proactive software supply chain risk management and supports interoperability between multiple security frameworks.

Abstract: The MITRE Adversarial Tactics, Techniques and Common Knowledge (MITRE ATT&CK)
Attack Technique to Proactive Software Supply Chain Risk Management Framework
(P-SSCRM) Task mapping described in this document helps software organizations
to determine how different tasks mitigate the attack techniques of software
supply chain attacks. The mapping was created through four independent
strategies to find agreed-upon mappings. Because each P-SSCRM task is mapped to
one or more tasks from the 10 frameworks, the mapping we provide is also a
mapping between MITRE ATT&CK and other prominent government and industry
frameworks.

</details>


### [5] [Factors Impacting Faculty Adoption of Project-Based Learning in Computing Education: a Survey](https://arxiv.org/abs/2507.18039)
*Ahmad D. Suleiman,Yiming Tang,Daqing Hou*

Main category: cs.SE

TL;DR: Adopting project-based learning in computing education faces faculty barriers like lack of support, time, and training. Systemic institutional resources, peer collaboration, and incentives are key to overcoming these and facilitating sustained use of PjBL.


<details>
  <summary>Details</summary>
Motivation: Project-based learning (PjBL) holds significant promise for enhancing key student skills in software engineering and computing education, yet its adoption by faculty is inconsistent. Understanding the factors that influence its integration is crucial to help bridge gaps in pedagogy and student outcomes.

Method: The study used a mixed-methods approach, surveying 80 computing faculty through an online instrument composed of both closed-ended and open-ended questions. Quantitative data were analyzed statistically, while qualitative responses were evaluated via thematic analysis.

Result: The research found that, although faculty widely value PjBL, its uptake is selective due to barriers like limited institutional support (time, funding, teaching assistants), difficulties in project design and management, and insufficient training. PjBL adoption is more successful when faculty can collaborate with peers, access professional development, and have institutional incentives. Obtaining projects from research, industry, and colleagues also facilitates adoption.

Conclusion: To effectively scale and sustain PjBL practices in computing curricula, institutions must provide comprehensive support to faculty, including resources, incentives, and collaborative opportunities. Such systemic support is essential to overcome existing barriers and realize the pedagogical benefits of PjBL.

Abstract: This research full paper investigates the factors influencing computing
educators' adoption of project-based learning (PjBL) in software engineering
and computing curricula. Recognized as a student-centered pedagogical approach,
PjBL has the potential to enhance student motivation, engagement, critical
thinking, collaboration, and problem-solving skills. Despite these benefits,
faculty adoption remains inconsistent due to challenges such as insufficient
institutional support, time constraints, limited training opportunities,
designing or sourcing projects, and aligning them with course objectives. This
research explores these barriers and investigates the strategies and resources
that facilitate a successful adoption. Using a mixed-methods approach, data
from 80 computing faculty were collected through an online survey comprising
closed-ended questions to quantify barriers, enablers, and resource needs,
along with an open-ended question to gather qualitative insights. Quantitative
data were analyzed using statistical methods, while qualitative responses
underwent thematic analysis. Results reveal that while PjBL is widely valued,
its adoption is often selective and impacted by challenges in planning and
managing the learning process, designing suitable projects, and a lack of
institutional support, such as time, funding, and teaching assistants. Faculty
are more likely to adopt or sustain PjBL when they have access to peer
collaboration, professional development, and institutional incentives. In
addition, sourcing projects from research, industry partnerships, and borrowing
from peers emerged as key facilitators for new projects. These findings
underscore the need for systemic support structures to empower faculty to
experiment with and scale PjBL practices.

</details>


### [6] [An Empirical Study of Complexity, Heterogeneity, and Compliance of GitHub Actions Workflows](https://arxiv.org/abs/2507.18062)
*Edward Abrokwah,Taher A. Ghaleb*

Main category: cs.SE

TL;DR: The paper empirically examines thousands of GitHub Actions CI workflows in open-source projects (Java, Python, C++), finding recurring complexity, compliance gaps with best practices, and language-specific patterns. It calls for better guidelines and documentation to help practitioners create simpler, more effective CI pipelines.


<details>
  <summary>Details</summary>
Motivation: Continuous Integration (CI) is essential for rapid, collaborative software development, with GitHub Actions (GHA) as a leading platform. However, there is a lack of empirical understanding regarding how actual open-source GHA workflows align with recommended best practices, and whether their complexity adheres to CI's simplicity goals.

Method: The study analyzes a large dataset of GHA workflows from open-source repositories written in Java, Python, and C++. It investigates the workflows’ structure, complexity, recurring and heterogeneous patterns, and evaluates their compliance with GHA best practices. Comparisons across programming languages are performed as well.

Result: The analysis uncovers both strong adherence to and deviations from best practices in open-source GHA workflows. It identifies unnecessary complexity, various structuring patterns, compliance levels, and programming language-specific differences. Areas for improvement are highlighted.

Conclusion: There is significant variation in GHA workflow structures and complexity. While some workflows follow best practices, many diverge, creating opportunities for improvement in documentation and guidelines. The results suggest the need for clearer guidance to simplify CI workflows and improve adherence.

Abstract: Continuous Integration (CI) has evolved from a tooling strategy to a
fundamental mindset in modern CI engineering. It enables teams to develop,
test, and deliver software rapidly and collaboratively. Among CI services,
GitHub Actions (GHA) has emerged as a dominant service due to its deep
integration with GitHub and a vast ecosystem of reusable workflow actions.
Although GHA provides official documentation and community-supported best
practices, there appears to be limited empirical understanding of how
open-source real-world CI workflows align with such practices. Many workflows
might be unnecessarily complex and not aligned with the simplicity goals of CI
practices. This study will investigate the structure, complexity,
heterogeneity, and compliance of GHA workflows in open-source software
repositories. Using a large dataset of GHA workflows from Java, Python, and C++
repositories, our goal is to (a) identify workflow complexities, (b) analyze
recurring and heterogeneous structuring patterns, (c) assess compliance with
GHA best practices, and (d) uncover differences in CI pipeline design across
programming languages. Our findings are expected to reveal both areas of strong
adherence to best practices and areas for improvement where needed. These
insights will also have implications for CI services, as they will highlight
the need for clearer guidelines and comprehensive examples in CI documentation.

</details>


### [7] [Identifier Name Similarities: An Exploratory Study](https://arxiv.org/abs/2507.18081)
*Carol Wong,Mai Abe,Silvia De Benedictis,Marissa Halim,Anthony Peruma*

Main category: cs.SE

TL;DR: This paper presents an exploratory study that introduces a preliminary taxonomy categorizing types of identifier name similarity in codebases, aiming to support future analysis of how such similarities impact code comprehension and collaboration.


<details>
  <summary>Details</summary>
Motivation: Identifier names are crucial for code understanding, but similar or poorly chosen names increase cognitive load and reduce code quality and collaboration. Previous work has not systematically categorized forms of name similarity and their effects.

Method: The study is exploratory and involves developing a preliminary taxonomy that categorizes different forms of identifier name similarity in software projects.

Result: The preliminary taxonomy of identifier name similarity was introduced, which can be used as a basis for further research.

Conclusion: The initial taxonomy helps researchers analyze and evaluate how identifier name similarity affects code comprehension, maintainability, and collaboration among developers. It also enables future refinement and expansion.

Abstract: Identifier names, which comprise a significant portion of the codebase, are
the cornerstone of effective program comprehension. However, research has shown
that poorly chosen names can significantly increase cognitive load and hinder
collaboration. Even names that appear readable in isolation may lead to
misunderstandings in contexts when they closely resemble other names in either
structure or functionality. In this exploratory study, we present our
preliminary findings on the occurrence of identifier name similarity in
software projects through the development of a taxonomy that categorizes
different forms of identifier name similarity. We envision our initial taxonomy
providing researchers with a platform to analyze and evaluate the impact of
identifier name similarity on code comprehension, maintainability, and
collaboration among developers, while also allowing for further refinement and
expansion of the taxonomy.

</details>


### [8] [Understanding the Supply Chain and Risks of Large Language Model Applications](https://arxiv.org/abs/2507.18105)
*Yujie Ma,Lili Quan,Xiaofei Xie,Qiang Hu,Jiongchi Yu,Yao Zhang,Sen Chen*

Main category: cs.SE

TL;DR: Authors curated a novel large dataset to map and analyze the complex supply chain of LLM applications, revealing extensive interdependencies and numerous security vulnerabilities. Their work offers the first comprehensive benchmark and guidance for improving the security of LLM supply chains.


<details>
  <summary>Details</summary>
Motivation: As LLM-based systems become widespread, their complex dependencies (models, datasets, libraries, infrastructure) introduce significant security risks that are currently understudied due to a lack of comprehensive benchmarking datasets.

Method: The authors constructed a large-scale dataset from 3,859 real LLM applications, mapping interdependencies between 109,211 models, 2,474 datasets, and 9,862 libraries. They analyzed supply chain components, fine-tuning paths, reuse patterns, and security incidents based on 1,555 known risk issues from public vulnerability data.

Result: The study discovered deeply nested dependencies within LLM supply chains and widespread vulnerabilities throughout various components, especially libraries. Security issues are prevalent at multiple layers, highlighting systemic risks rather than isolated ones.

Conclusion: There is an urgent need for systematic, supply-chain-wide security evaluation in LLM systems. The new benchmark dataset enables further research and provides practical recommendations for building safer and more trustworthy LLM-based software.

Abstract: The rise of Large Language Models (LLMs) has led to the widespread deployment
of LLM-based systems across diverse domains. As these systems proliferate,
understanding the risks associated with their complex supply chains is
increasingly important. LLM-based systems are not standalone as they rely on
interconnected supply chains involving pretrained models, third-party
libraries, datasets, and infrastructure. Yet, most risk assessments narrowly
focus on model or data level, overlooking broader supply chain vulnerabilities.
While recent studies have begun to address LLM supply chain risks, there
remains a lack of benchmarks for systematic research.
  To address this gap, we introduce the first comprehensive dataset for
analyzing and benchmarking LLM supply chain security. We collect 3,859
real-world LLM applications and perform interdependency analysis, identifying
109,211 models, 2,474 datasets, and 9,862 libraries. We extract model
fine-tuning paths, dataset reuse, and library reliance, mapping the ecosystem's
structure. To evaluate security, we gather 1,555 risk-related issues-50 for
applications, 325 for models, 18 for datasets, and 1,229 for libraries from
public vulnerability databases.
  Using this dataset, we empirically analyze component dependencies and risks.
Our findings reveal deeply nested dependencies in LLM applications and
significant vulnerabilities across the supply chain, underscoring the need for
comprehensive security analysis. We conclude with practical recommendations to
guide researchers and developers toward safer, more trustworthy LLM-enabled
systems.

</details>


### [9] [NoCode-bench: A Benchmark for Evaluating Natural Language-Driven Feature Addition](https://arxiv.org/abs/2507.18130)
*Le Deng,Zhonghao Jiang,Jialun Cao,Michael Pradel,Zhongxin Liu*

Main category: cs.SE

TL;DR: NoCode-bench evaluates LLMs on real-world natural language-driven feature addition tasks and finds that current LLMs have low success rates, revealing significant challenges before no-code development can be reliably achieved with NL and LLMs.


<details>
  <summary>Details</summary>
Motivation: Natural language-driven no-code development enables users to create software using plain language instead of code, making development more accessible. While large language models (LLMs) show promise in this area, there is a need to benchmark their real-world effectiveness in translating natural language specifications into working features.

Method: The authors introduce NoCode-bench, a benchmark suite with 634 tasks from 10 real-world projects, each task pairing software documentation updates (in natural language) with matching code implementations and test cases. They also provide a subset of 114 human-verified instances. LLMs are evaluated on their ability to perform NL-driven feature additions using these benchmarks.

Result: The best performing LLM achieves a task success rate of only 15.79%, indicating significant difficulties, particularly with cross-file edits, understanding large codebases, and utilizing tools.

Conclusion: Current large language models are not yet sufficiently effective for fully natural language-driven no-code software development. NoCode-bench provides a valuable foundation for future research into bridging this gap.

Abstract: Natural language-driven no-code development allows users to specify software
functionality using natural language (NL) instead of editing source code,
promising increased productivity and democratized development. Large language
models (LLMs) show potential in enabling this paradigm. In this context,
software documentation acts as an NL specification for functionality. This work
introduces NoCode-bench, a benchmark designed to evaluate LLMs on real-world
NL-driven feature addition tasks, consisting of 634 tasks across 10 projects
and 114k code changes. Each task pairs documentation updates with corresponding
code implementations, validated by developer-written test cases. A subset of
114 high-quality, human-verified instances, NoCode-bench Verified, ensures
reliable evaluation. Our experiments reveal that, despite high token usage, the
best LLMs achieve a task success rate of only 15.79%, highlighting challenges
in cross-file editing, codebase understanding, and tool calling. These findings
indicate that LLMs are not yet ready for fully NL-driven no-code development.
NoCode-bench lays the foundation for future advances in this area.

</details>


### [10] [SMECS: A Software Metadata Extraction and Curation Software](https://arxiv.org/abs/2507.18159)
*Stephan Ferenz,Aida Jafarbigloo,Oliver Werth,Astrid Nieße*

Main category: cs.SE

TL;DR: SMECS is a tool that streamlines the creation and curation of research software metadata, making it easier for researchers to comply with FAIR principles by extracting information from sources like GitHub and presenting it in an easy-to-use interface.


<details>
  <summary>Details</summary>
Motivation: Creating high-quality metadata is essential for adopting FAIR principles for research software, but it is often resource-intensive and burdensome for researchers and software engineers.

Method: The authors developed SMECS (Software Metadata Extraction and Curation Software) to extract metadata from online repositories (like GitHub), present it through an interactive and user-friendly interface, and allow export as a CodeMeta file. Usability experiments were conducted to evaluate the tool.

Result: Usability experiments demonstrated that SMECS offers a satisfactory user experience. The tool simplifies metadata extraction and curation, supporting the FAIRification of research software.

Conclusion: SMECS effectively supports the creation, extraction, and curation of research software metadata, making it easier to follow FAIR principles through a simplified and user-friendly workflow.

Abstract: Metadata play a crucial role in adopting the FAIR principles for research
software and enables findability and reusability. However, creating
high-quality metadata can be resource-intensive for researchers and research
software engineers. To address this challenge, we developed the Software
Metadata Extraction and Curation Software (SMECS) which integrates the
extraction of metadata from existing sources together with a user-friendly
interface for metadata curation. SMECS extracts metadata from online
repositories such as GitHub and presents it to researchers through an
interactive interface for further curation and export as a CodeMeta file. The
usability of SMECS was evaluated through usability experiments which confirmed
that SMECS provides a satisfactory user experience. SMECS supports the
FAIRification of research software by simplifying metadata creation.

</details>


### [11] [GenAI for Automotive Software Development: From Requirements to Wheels](https://arxiv.org/abs/2507.18223)
*Nenad Petrovic,Fengjunjie Pan,Vahid Zolfaghari,Krzysztof Lebioda,Andre Schamschurko,Alois Knoll*

Main category: cs.SE

TL;DR: This paper presents a GenAI-based method using LLMs, MDE, and RAG to automate development and testing of automotive ADAS software, leading to faster compliance and reduced development times.


<details>
  <summary>Details</summary>
Motivation: The motivation is to streamline and automate the development of automotive software, especially for autonomous and ADAS functions, to reduce development and testing time and improve compliance.

Method: The paper proposes a workflow utilizing Large Language Models (LLMs) for model-based summarization of requirements, code generation for test scenarios (Python) and target platforms (C++), and requirements consistency checking with Model-Driven Engineering (MDE). Retrieval Augmented Generation (RAG) is used to improve the quality of test scenarios by incorporating autonomous driving regulations.

Result: The approach results in automated generation of simulation environments and implementation code based on requirements, with improved requirements consistency and incorporation of regulatory knowledge, leading to faster compliance, reduced re-engineering cycles, and decreased development/testing time.

Conclusion: A GenAI-driven workflow that leverages LLMs and RAG can significantly accelerate and automate the development and testing of ADAS software, ensuring faster compliance and reduced manual effort.

Abstract: This paper introduces a GenAI-empowered approach to automated development of
automotive software, with emphasis on autonomous and Advanced Driver Assistance
Systems (ADAS) capabilities. The process starts with requirements as input,
while the main generated outputs are test scenario code for simulation
environment, together with implementation of desired ADAS capabilities
targeting hardware platform of the vehicle connected to testbench. Moreover, we
introduce additional steps for requirements consistency checking leveraging
Model-Driven Engineering (MDE). In the proposed workflow, Large Language Models
(LLMs) are used for model-based summarization of requirements (Ecore metamodel,
XMI model instance and OCL constraint creation), test scenario generation,
simulation code (Python) and target platform code generation (C++).
Additionally, Retrieval Augmented Generation (RAG) is adopted to enhance test
scenario generation from autonomous driving regulations-related documents. Our
approach aims shorter compliance and re-engineering cycles, as well as reduced
development and testing time when it comes to ADAS-related capabilities.

</details>


### [12] [An Empirical Study on Embodied Artificial Intelligence Robot (EAIR) Software Bugs](https://arxiv.org/abs/2507.18267)
*Zeqin Liao,Zibin Zheng,Peifan Reng,Henglong Liang,Zixu Gao,Zhixiang Chen,Wei Li,Yuhong Nan*

Main category: cs.SE

TL;DR: The paper systematically studies 885 bugs across 80 Embodied AI Robot systems, classifies their symptoms, causes, and affected modules, and identifies several EAIR-specific failure patterns. It offers insights and resources that can improve understanding and management of bugs in EAIR software.


<details>
  <summary>Details</summary>
Motivation: There is a lack of comprehensive understanding of bugs affecting Embodied Artificial Intelligence Robots (EAIR) systems, which impedes the development of effective debugging and repair techniques for these systems.

Method: The authors performed a systematic study by collecting and analyzing 885 bugs from 80 EAIR system projects. They classified these bugs according to their symptoms, underlying causes, and affected system modules.

Result: The study categorized 18 underlying causes, 15 symptoms, and 13 modules affected by EAIR system bugs. It identified 8 symptoms and 8 causes specific to EAIR systems, largely related to AI-agent reasoning and decision-making. A mapping between causes and modules was also established to target diagnostic efforts more effectively.

Conclusion: This work provides the first in-depth taxonomy and analysis of EAIR system bugs, highlighting EAIR-specific symptoms and causes. The findings inform future research and practice by illuminating the unique challenges of EAIR system debugging and offering a resource for targeting bug prediction, detection, and repair.

Abstract: Embodied Artificial Intelligence Robots (EAIR) is an emerging and rapidly
evolving technological domain. Ensuring their program correctness is
fundamental to their successful deployment. However, a general and in-depth
understanding of EAIR system bugs remains lacking, which hinders the
development of practices and techniques to tackle EAIR system bugs.
  To bridge this gap, we conducted the first systematic study of 885 EAIR
system bugs collected from 80 EAIR system projects to investigate their
symptoms, underlying causes, and module distribution. Our analysis takes
considerable effort, which classifies these bugs into 18 underlying causes, 15
distinct symptoms, and identifies 13 affected modules. It reveals several new
interesting findings and implications which help shed light on future research
on tackling or repairing EAIR system bugs. First, among the 15 identified
symptoms, our findings highlight 8 symptoms specific to EAIR systems, which is
characterized by severe functional failures and potential physical hazards.
Second, within the 18 underlying causes, we define 8 EAIR-specific causes, the
majority of which stem from the intricate issues of AI- agent reasoning and
decision making. Finally, to facilitate precise and efficient bug prediction,
detection, and repair, we constructed a mapping between underlying causes and
the modules in which they most frequently occur, which enables researchers to
focus diagnostic efforts on the modules most susceptible to specific bug types.

</details>


### [13] [Scheduzz: Constraint-based Fuzz Driver Generation with Dual Scheduling](https://arxiv.org/abs/2507.18289)
*Yan Li,Wenzhang Yang,Yuekun Wang,Jian Gao,Shaohua Wang,Yinxing Xue,Lijun Zhang*

Main category: cs.SE

TL;DR: Scheduzz uses LLMs and a dual scheduling framework to automatically generate and efficiently execute intelligent fuzz drivers, leading to better code coverage and bug discovery in libraries than previous techniques.


<details>
  <summary>Details</summary>
Motivation: Fuzzing libraries is difficult because it requires deep understanding of usage conventions and significant manual effort to create effective fuzz drivers. Existing automated approaches often generate irrational drivers due to lack of adherence to correct usage patterns, wasting resources and generating false positives.

Method: The authors propose Scheduzz, an LLM-based fuzzing technique that leverages large language models to understand proper library usage and extract API combination constraints. It introduces a dual scheduling framework that models driver generation and fuzzing as an online optimization problem, optimizing which fuzz drivers to generate and execute for efficient resource use.

Result: Scheduzz was evaluated on 33 real-world libraries, showing significant reduction in computational overhead and outperforming prior tools like UTopia, CKGFuzzer, Promptfuzz, and OSS-Fuzz in code coverage. Scheduzz achieved up to 1.89x better coverage and discovered 33 new bugs, 3 of which received CVEs.

Conclusion: Scheduzz advances automated library fuzzing by using LLMs to capture correct usage and a scheduling framework to optimize fuzz driver generation and execution. This approach both improves code coverage and uncovers new vulnerabilities, offering a substantial improvement in efficiency and effectiveness over existing methods.

Abstract: Fuzzing a library requires experts to understand the library usage well and
craft high-quality fuzz drivers, which is tricky and tedious. Therefore, many
techniques have been proposed to automatically generate fuzz drivers. However,
they fail to generate rational fuzz drivers due to the lack of adherence to
proper library usage conventions, such as ensuring a resource is closed after
being opened. To make things worse, existing library fuzzing techniques
unconditionally execute each driver, resulting in numerous irrational drivers
that waste computational resources while contributing little coverage and
generating false positive bug reports.
  To tackle these challenges, we propose a novel automatic library fuzzing
technique, Scheduzz, an LLM-based library fuzzing technique. It leverages LLMs
to understand rational usage of libraries and extract API combination
constraints. To optimize computational resource utilization, a dual scheduling
framework is implemented to efficiently manage API combinations and fuzz
drivers. The framework models driver generation and the corresponding fuzzing
campaign as an online optimization problem. Within the scheduling loop,
multiple API combinations are selected to generate fuzz drivers, while
simultaneously, various optimized fuzz drivers are scheduled for execution or
suspension.
  We implemented Scheduzz and evaluated it in 33 real-world libraries. Compared
to baseline approaches, Scheduzz significantly reduces computational overhead
and outperforms UTopia on 16 out of 21 libraries. It achieves 1.62x, 1.50x, and
1.89x higher overall coverage than the state-of-the-art techniques CKGFuzzer,
Promptfuzz, and the handcrafted project OSS-Fuzz, respectively. In addition,
Scheduzz discovered 33 previously unknown bugs in these well-tested libraries,
3 of which have been assigned CVEs.

</details>


### [14] [YATE: The Role of Test Repair in LLM-Based Unit Test Generation](https://arxiv.org/abs/2507.18316)
*Michael Konstantinou,Renzo Degiovanni,Jie M. Zhang,Mark Harman,Mike Papadakis*

Main category: cs.SE

TL;DR: YATE repairs incorrect LLM-generated tests using static analysis and re-prompting, leading to much higher code coverage and mutant kill rates compared with existing approaches at no additional cost.


<details>
  <summary>Details</summary>
Motivation: Current language model-based test generation can produce many incorrect tests, which are typically discarded. However, these incorrect tests can contain valuable information and serve as seeds for further test generation if they can be repaired.

Method: The authors propose YATE, a technique that repairs incorrect tests generated by LLMs using rule-based static analysis and re-prompting. YATE is evaluated on 6 open-source projects, and its performance is compared against four other LLM-based methods.

Result: YATE produces tests that achieve 22% higher line coverage, 20% higher branch coverage, and kill 20% more mutants compared to other LLM-based methods, with similar resource usage. On average, YATE's tests cover 32.06% more lines and kill 21.77% more mutants than using a plain LLM-based method.

Conclusion: YATE significantly improves the effectiveness of automated test generation by salvaging and repairing initially incorrect tests, outperforming existing LLM-based methods in code coverage and mutation killing without increased cost.

Abstract: Recent advances in automated test generation utilises language models to
produce unit tests. While effective, language models tend to generate many
incorrect tests with respect to both syntax and semantics. Although such
incorrect tests can be easily detected and discarded, they constitute a "missed
opportunity" -- if fixed, they are often valuable as they directly add testing
value (they effectively target the underlying program logic to be tested) and
indirectly form good seeds for generating additional tests. To this end, we
propose a simple technique for repairing some of these incorrect tests through
a combination of rule-based static analysis and re-prompting. We evaluate this
simple approach, named YATE, on a set of 6 open-source projects and show that
it can effectively produce tests that cover on average 32.06% more lines and
kill 21.77% more mutants than a plain LLM-based method. We also compare YATE
with four other LLM-based methods, namely HITS, SYMPROMPT, TESTSPARK and
COVERUP and show that it produces tests that cover substantially more code.
YATE achieves 22% higher line coverage, 20% higher branch coverage and kill 20%
more mutants at a comparable cost (number of calls to LLMs).

</details>


### [15] [Gotta catch 'em all! Towards File Localisation from Issues at Large](https://arxiv.org/abs/2507.18319)
*Jesse Maarleveld,Jiapan Guo,Daniel Feitosa*

Main category: cs.SE

TL;DR: The paper presents a dataset pipeline and baseline results for general issue file localisation, showing that bug-specific methods work poorly on broader issues. It highlights the importance of project-specific tuning and the need for general-purpose localisation models.


<details>
  <summary>Details</summary>
Motivation: Bug localisation has been primarily focused on bugs, with most research filtering out other types of issues. The authors are motivated by a need to generalise file localisation techniques to cover all kinds of issues, aiming to broaden the applicability and usefulness of localisation tools for software projects.

Method: The authors propose a data pipeline for creating issue file localisation datasets that can handle complex branching and merging. They also establish a baseline performance evaluation using traditional information retrieval techniques and conduct statistical analysis to assess the effect of known biases in bug localisation on the broader issue localisation task.

Result: They find that models built using bug-specific heuristics do not perform well on broader, general issue types. There are measurable, though small, performance differences across different issue types. The effect of identifiers on performance is generally small. Many findings are project-dependent, suggesting a need for approaches that can be customised to specific projects.

Conclusion: Current models tailored to bugs do not generalise well to other issue types, and specific project characteristics significantly influence localisation performance. Future research should focus on developing models and approaches tuned to general issues and adaptable to project-specific needs.

Abstract: Bug localisation, the study of developing methods to localise the files
requiring changes to resolve bugs, has been researched for a long time to
develop methods capable of saving developers' time. Recently, researchers are
starting to consider issues outside of bugs. Nevertheless, most existing
research into file localisation from issues focusses on bugs or uses other
selection methods to ensure only certain types of issues are considered as part
of the focus of the work. Our goal is to work on all issues at large, without
any specific selection.
  In this work, we provide a data pipeline for the creation of issue file
localisation datasets, capable of dealing with arbitrary branching and merging
practices. We provide a baseline performance evaluation for the file
localisation problem using traditional information retrieval approaches.
Finally, we use statistical analysis to investigate the influence of biases
known in the bug localisation community on our dataset.
  Our results show that methods designed using bug-specific heuristics perform
poorly on general issue types, indicating a need for research into general
purpose models. Furthermore, we find that there are small, but statistically
significant differences in performance between different issue types. Finally,
we find that the presence of identifiers have a small effect on performance for
most issue types. Many results are project-dependent, encouraging the
development of methods which can be tuned to project-specific characteristics.

</details>


### [16] [FMI Meets SystemC: A Framework for Cross-Tool Virtual Prototyping](https://arxiv.org/abs/2507.18339)
*Nils Bosbach,Meik Schmidt,Lukas Jünger,Matthias Berthold,Rainer Leupers*

Main category: cs.SE

TL;DR: The paper introduces a framework that integrates SystemC-based virtual platforms with the FMI co-simulation standard, enabling realistic environmental interaction during software testing. This approach enhances test coverage and accelerates certification, even before physical hardware is available.


<details>
  <summary>Details</summary>
Motivation: As systems grow in complexity, comprehensive testing and virtual prototyping require the integration of multiple simulation tools covering both hardware and environmental aspects. SystemC TLM is a standard for creating virtual platforms for control software development, but lacks native support for the FMI co-simulation standard, limiting its interoperability in broader environments.

Method: The authors introduce a framework that enables control and interaction between SystemC-based Virtual Platforms (VPs) and external tools using the Functional Mock-up Interface (FMI). This is demonstrated via a case study involving a simulated temperature sensor in SystemC, which receives real-time data from an external source via FMI.

Result: The proposed framework successfully allows unmodified target software to run on a VP and interact with realistic environmental input through FMI. This facilitates extensive software testing and streamlines the verification process, enabling earlier certifications (such as ISO 26262) once hardware is available.

Conclusion: Integrating FMI into SystemC-based virtual platforms addresses a key limitation, broadening the scope for system-level co-simulation, enhancing test and verification processes, and supporting faster certification procedures by allowing comprehensive testing before hardware availability.

Abstract: As systems become more complex, the demand for thorough testing and virtual
prototyping grows. To simulate whole systems, multiple tools are usually needed
to cover different parts. These parts include the hardware of a system and the
environment with which the system interacts. The Functional Mock-up Interface
(FMI) standard for co-simulation can be used to connect these tools.
  The control part of modern systems is usually a computing unit, such as a
System-on-a-Chip (SoC) or Microcontroller Unit (MCU), which executes software
from a connected memory and interacts with peripherals. To develop software
without requiring access to physical hardware, full-system simulators, the
so-called Virtual Platforms (VPs), are commonly used. The IEEE-standardized
framework for VP development is SystemC TLM. SystemC provides interfaces and
concepts that enable modular design and model exchange. However, SystemC lacks
native FMI support, which limits the integration into broader co-simulation
environments.
  This paper presents a novel framework to control and interact with
SystemC-based VPs using the FMI. We present a case study showing how a
simulated temperature sensor in a SystemC simulation can obtain temperature
values from an external tool via FMI. This approach allows the unmodified
target software to run on the VP and receive realistic environmental input data
such as temperature, velocity, or acceleration values from other tools. Thus,
extensive software testing and verification is enabled. By having tests ready
and the software pre-tested using a VP once the physical hardware is available,
certifications like ISO 26262 can be done earlier.

</details>


### [17] [Automated Code Review Using Large Language Models with Symbolic Reasoning](https://arxiv.org/abs/2507.18476)
*Busra Icoz,Goksel Biricik*

Main category: cs.SE

TL;DR: Integrating symbolic reasoning with LLMs significantly improves automated code review, making it more accurate and efficient than current LLM-based solutions alone.


<details>
  <summary>Details</summary>
Motivation: Manual code review is subjective and time-consuming. Automation is suitable but existing AI, including Large Language Models (LLMs), lacks sufficient logical reasoning for effective code review.

Method: This study proposes a hybrid approach that integrates symbolic reasoning techniques with LLMs. The approach was tested on the CodexGlue dataset and compared models like CodeT5, CodeBERT, and GraphCodeBERT to evaluate the impact of symbolic reasoning and prompting.

Result: The results demonstrate that integrating symbolic reasoning with LLMs enhances the accuracy and efficiency of automated code review compared to using LLMs alone.

Conclusion: Combining symbolic reasoning with LLMs overcomes prior limitations of LLMs in logical reasoning, offering a more effective automated code review solution.

Abstract: Code review is one of the key processes in the software development lifecycle
and is essential to maintain code quality. However, manual code review is
subjective and time consuming. Given its rule-based nature, code review is well
suited for automation. In recent years, significant efforts have been made to
automate this process with the help of artificial intelligence. Recent
developments in Large Language Models (LLMs) have also emerged as a promising
tool in this area, but these models often lack the logical reasoning
capabilities needed to fully understand and evaluate code. To overcome this
limitation, this study proposes a hybrid approach that integrates symbolic
reasoning techniques with LLMs to automate the code review process. We tested
our approach using the CodexGlue dataset, comparing several models, including
CodeT5, CodeBERT, and GraphCodeBERT, to assess the effectiveness of combining
symbolic reasoning and prompting techniques with LLMs. Our results show that
this approach improves the accuracy and efficiency of automated code review.

</details>


### [18] [A Deep Dive into Retrieval-Augmented Generation for Code Completion: Experience on WeChat](https://arxiv.org/abs/2507.18515)
*Zezhou Yang,Ting Peng,Cuiyun Gao,Chaozheng Wang,Hailiang Huang,Yuetang Deng*

Main category: cs.SE

TL;DR: This study shows that retrieval-augmented generation (RAG) methods enhance code completion in large-scale proprietary codebases like WeChat, with similarity-based and combined lexical/semantic retrieval approaches yielding the best results for LLM-based code completion.


<details>
  <summary>Details</summary>
Motivation: Recent advances in large language models (LLMs) have greatly improved code completion, an essential task for software engineering. Retrieval-augmented generation (RAG) has shown promise in enhancing code completion by integrating relevant code context. Most prior research, however, focuses on public/open-source code, while challenges and effectiveness in large proprietary (closed-source) codebases remain underexplored.

Method: The study conducts an extensive empirical evaluation of RAG methods (identifier-based and similarity-based) on WeChat's massive industrial codebase, using 26 open-source LLMs (0.5B to 671B parameters). Different retrieval techniques, such as lexical (BM25) and semantic (GTE-Qwen), are assessed. The analysis examines their performance in 1,669 internal repositories. Additionally, a developer survey evaluates the practical utility of these methods in real-world settings.

Result: Both identifier-based and similarity-based RAG methods are effective for closed-source codebases, with similarity-based RAG performing better. Advanced retrieval techniques (lexical BM25, semantic GTE-Qwen) further boost the effectiveness of similarity-based RAG. Combining both retrieval approaches yields the best results, as they offer complementary strengths.

Conclusion: RAG methods significantly improve code completion even in proprietary, large-scale codebases. The best performance is achieved by combining lexical and semantic retrieval techniques. These findings are validated by both experimental metrics and developer feedback, confirming the practical utility of RAG-augmented code completion in real-world software engineering.

Abstract: Code completion, a crucial task in software engineering that enhances
developer productivity, has seen substantial improvements with the rapid
advancement of large language models (LLMs). In recent years,
retrieval-augmented generation (RAG) has emerged as a promising method to
enhance the code completion capabilities of LLMs, which leverages relevant
context from codebases without requiring model retraining. While existing
studies have demonstrated the effectiveness of RAG on public repositories and
benchmarks, the potential distribution shift between open-source and
closed-source codebases presents unique challenges that remain unexplored. To
mitigate the gap, we conduct an empirical study to investigate the performance
of widely-used RAG methods for code completion in the industrial-scale codebase
of WeChat, one of the largest proprietary software systems. Specifically, we
extensively explore two main types of RAG methods, namely identifier-based RAG
and similarity-based RAG, across 26 open-source LLMs ranging from 0.5B to 671B
parameters. For a more comprehensive analysis, we employ different retrieval
techniques for similarity-based RAG, including lexical and semantic retrieval.
Based on 1,669 internal repositories, we achieve several key findings: (1) both
RAG methods demonstrate effectiveness in closed-source repositories, with
similarity-based RAG showing superior performance, (2) the effectiveness of
similarity-based RAG improves with more advanced retrieval techniques, where
BM25 (lexical retrieval) and GTE-Qwen (semantic retrieval) achieve superior
performance, and (3) the combination of lexical and semantic retrieval
techniques yields optimal results, demonstrating complementary strengths.
Furthermore, we conduct a developer survey to validate the practical utility of
RAG methods in real-world development environments.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [19] [Higher-Order Behavioural Conformances via Fibrations](https://arxiv.org/abs/2507.18509)
*Henning Urbat*

Main category: cs.PL

TL;DR: The paper introduces a powerful categorical framework that generalizes Howe's method for proving that behavioural conformance (like bisimilarity or behavioural metrics) is a congruence in higher-order and probabilistic languages, offering a more uniform and broadly applicable approach than prior methods.


<details>
  <summary>Details</summary>
Motivation: Coinductive methods are essential for verifying behavioural equivalence in higher-order languages. Newer languages with quantitative features (such as probabilistic programming languages) require more refined notions of behavioural conformance, like behavioural distance. Establishing these conformance relations as program congruences is complex and traditionally hinges on intricate proof techniques like Howe's method, which need careful, language-specific adaptation.

Method: The authors propose a uniform categorical framework for Howe's method, abstracts the language's operational semantics via Abstract Higher-Order Specifications (AHOS), and models behavioural conformance relations using fibrations over the base category. This general approach allows for addressing both different languages and different kinds of behavioural conformance (e.g., relations, metrics) within a single theoretical structure.

Result: The main result is a general congruence theorem: Given suitable categorical and operational conditions, the largest behavioural conformance (such as bisimilarity or specific behavioural metrics) is always a congruence for languages represented via AHOS. The framework is demonstrated by showing congruence properties of bisimilarity and behavioural pseudometrics, specifically for probabilistic higher-order languages.

Conclusion: This work delivers a highly general and uniform theoretical framework, showing that congruence of behavioural conformance can be systematically established for a wide class of higher-order languages—including those with quantitative or probabilistic features—using categorical techniques. This subsumes and generalizes earlier, more ad hoc approaches.

Abstract: Coinduction is a widely used technique for establishing behavioural
equivalence of programs in higher-order languages. In recent years, the rise of
languages with quantitative (e.g.~probabilistic) features has led to extensions
of coinductive methods to more refined types of behavioural conformances, most
notably notions of behavioural distance. To guarantee soundness of coinductive
reasoning, one needs to show that the behavioural conformance at hand forms a
program congruence, i.e. it is suitably compatible with the operations of the
language. This is usually achieved by a complex proof technique known as
\emph{Howe's method}, which needs to be carefully adapted to both the specific
language and the targeted notion of behavioural conformance. We develop a
uniform categorical approach to Howe's method that features two orthogonal
dimensions of abstraction: (1) the underlying higher-order language is modelled
by an \emph{abstract higher-order specification} (AHOS), a novel and very
general categorical account of operational semantics, and (2) notions of
behavioural conformance (such as relations or metrics) are modelled via
fibrations over the base category of an AHOS. Our main result is a fundamental
congruence theorem at this level of generality: Under natural conditions on the
categorical ingredients and the operational rules of a language modelled by an
AHOS, the greatest behavioural (bi)conformance on its operational model forms a
congruence. We illustrate our theory by deriving congruence of bisimilarity and
behavioural pseudometrics for probabilistic higher-order languages.

</details>
