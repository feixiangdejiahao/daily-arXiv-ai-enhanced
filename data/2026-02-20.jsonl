{"id": "2602.16748", "categories": ["cs.SE", "cs.ET"], "pdf": "https://arxiv.org/pdf/2602.16748", "abs": "https://arxiv.org/abs/2602.16748", "authors": ["Md Asiful Islam", "Shanto Jouerder", "Md Sabit As Sami", "Afia Jahin Prema"], "title": "A Construction-Phase Digital Twin Framework for Quality Assurance and Decision Support in Civil Infrastructure Projects", "comment": null, "summary": "Quality assurance (QA) during construction often relies on inspection records and laboratory test results that become available days or weeks after work is completed. On large highway and bridge projects, this delay limits early intervention and increases the risk of rework, schedule impacts, and fragmented documentation. This study presents a construction-phase digital twin framework designed to support element-level QA and readiness-based decision making during active construction. The framework links inspection records, material production and placement data, early-age sensing, and predictive strength models to individual construction elements. By integrating these data streams, the system represents the evolving quality state of each element and supports structured release or hold decisions before standard-age test results are available. The approach does not replace established inspection and testing procedures. Instead, it supplements existing workflows by improving traceability and enabling earlier, data-informed quality assessments. Practical considerations related to data integration, contractual constraints, and implementation challenges are also discussed. The proposed framework provides a structured pathway for transitioning construction QA from delayed, document-driven review toward proactive, element-level decision support during construction."}
{"id": "2602.16819", "categories": ["cs.SE", "cs.CL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2602.16819", "abs": "https://arxiv.org/abs/2602.16819", "authors": ["Yiqing Xie", "Emmy Liu", "Gaokai Zhang", "Nachiket Kotalwar", "Shubham Gandhi", "Sathwik Acharya", "Xingyao Wang", "Carolyn Rose", "Graham Neubig", "Daniel Fried"], "title": "Hybrid-Gym: Training Coding Agents to Generalize Across Tasks", "comment": null, "summary": "When assessing the quality of coding agents, predominant benchmarks focus on solving single issues on GitHub, such as SWE-Bench. In contrast, in real use, these agents solve more various and complex tasks that involve other skills such as exploring codebases, testing software, and designing architecture. In this paper, we first characterize some transferable skills that are shared across diverse tasks by decomposing trajectories into fine-grained components, and derive a set of principles for designing auxiliary training tasks to teach language models these skills. Guided by these principles, we propose a training environment, Hybrid-Gym, consisting of a set of scalable synthetic tasks, such as function localization and dependency search. Experiments show that agents trained on our synthetic tasks effectively generalize to diverse real-world tasks that are not present in training, improving a base model by 25.4% absolute gain on SWE-Bench Verified, 7.9% on SWT-Bench Verified, and 5.1% on Commit-0 Lite. Hybrid-Gym also complements datasets built for the downstream tasks (e.g., improving SWE-Play by 4.9% on SWT-Bench Verified). Code available at: https://github.com/yiqingxyq/Hybrid-Gym."}
{"id": "2602.16997", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2602.16997", "abs": "https://arxiv.org/abs/2602.16997", "authors": ["Diego Firmenich", "Leandro Antonelli", "Bruno Pazos", "Fabricio Lozada", "Leonardo Morales"], "title": "Exploring LLMs for User Story Extraction from Mockups", "comment": "14 pages, 6 figures. Preprint of the paper published in the 28th Workshop on Requirements Engineering (WER 2025)", "summary": "User stories are one of the most widely used artifacts in the software industry to define functional requirements. In parallel, the use of high-fidelity mockups facilitates end-user participation in defining their needs. In this work, we explore how combining these techniques with large language models (LLMs) enables agile and automated generation of user stories from mockups. To this end, we present a case study that analyzes the ability of LLMs to extract user stories from high-fidelity mockups, both with and without the inclusion of a glossary of the Language Extended Lexicon (LEL) in the prompts. Our results demonstrate that incorporating the LEL significantly enhances the accuracy and suitability of the generated user stories. This approach represents a step forward in the integration of AI into requirements engineering, with the potential to improve communication between users and developers."}
{"id": "2602.17018", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2602.17018", "abs": "https://arxiv.org/abs/2602.17018", "authors": ["Giovanni Rosa", "David Moreno-Lumbreras", "Raula Gaikovina Kula"], "title": "Not Only for Developers: Exploring Plugin Maintenance for Knowledge-Centric Communities", "comment": "Accepted to SANER2026", "summary": "The adoption of third-party libraries has become integral to modern software development, leading to large ecosystems such as PyPI, NPM, and Maven, where contributors typically share the technical expertise to sustain extensions. In communities that are not exclusively composed of developers, however, maintaining plugin ecosystems can present different challenges. In this early results paper, we study Obsidian, a knowledge--centric platform whose community is focused on writing, organization, and creativity--has built a substantial plugin ecosystem despite not being developer--centric. We investigate what kinds of plugins exist within this hybrid ecosystem and establish a foundation for understanding how they are maintained. Using repository mining and LLM-based topic modeling on a representative sample of 396 plugins, we identify six topics related to knowledge management and tooling, which is (i) dynamic editing and organization, (ii) interface and layouts, (iii) creative writing and productivity, (iv) knowledge sync solutions, (v) linking and script tools, and (vi) workflow enhancements tools. Furthermore, analysis of the Pull Requests from these plugins show that much software evolution has been performed on these ecosystem. These findings suggest that even in mixed communities, plugin ecosystems can develop recognizable engineering structures, motivating future work that highlight three different research directions with six research questions related to the health and sustainability of these non-developer ecosystems."}
{"id": "2602.16809", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2602.16809", "abs": "https://arxiv.org/abs/2602.16809", "authors": ["Paulo R. Pereira", "Jose N. Oliveira"], "title": "Haskell meets Evariste", "comment": null, "summary": "Since its birth as a new scientific body of knowledge in the late 1950s, computer programming has become a fundamental skill needed in many other disciplines. However, programming is not easy, it is prone to errors and code re-use is key for productivity. This calls for high-quality documentation in software libraries, which is quite often not the case. Taking a few Haskell functions available from the Hackage repository as case-studies, and comparing their descriptions with similar functions in other languages, this paper shows how clarity and good conceptual design can be achieved by following a so-called easy-hard-split formal strategy that is quite general and productive, even if used informally. This strategy is easy to use in functional programming and can be applied to both program analysis and synthesis."}
{"id": "2602.17037", "categories": ["cs.SE", "cs.AI", "cs.HC", "cs.PL"], "pdf": "https://arxiv.org/pdf/2602.17037", "abs": "https://arxiv.org/abs/2602.17037", "authors": ["Rahul Nanda", "Chandra Maddila", "Smriti Jha", "Euna Mehnaz Khan", "Matteo Paltenghi", "Satish Chandra"], "title": "Wink: Recovering from Misbehaviors in Coding Agents", "comment": null, "summary": "Autonomous coding agents, powered by large language models (LLMs), are increasingly being adopted in the software industry to automate complex engineering tasks. However, these agents are prone to a wide range of misbehaviors, such as deviating from the user's instructions, getting stuck in repetitive loops, or failing to use tools correctly. These failures disrupt the development workflow and often require resource-intensive manual intervention. In this paper, we present a system for automatically recovering from agentic misbehaviors at scale. We first introduce a taxonomy of misbehaviors grounded in an analysis of production traffic, identifying three primary categories: Specification Drift, Reasoning Problems, and Tool Call Failures, which we find occur in about 30% of all agent trajectories.\n  To address these issues, we developed a lightweight, asynchronous self-intervention system named Wink. Wink observes agent trajectories and provides targeted course-correction guidance to nudge the agent back to a productive path. We evaluated our system on over 10,000 real world agent trajectories and found that it successfully resolves 90% of the misbehaviors that require a single intervention. Furthermore, a live A/B test in our production environment demonstrated that our system leads to a statistically significant reduction in Tool Call Failures, Tokens per Session and Engineer Interventions per Session. We present our experience designing and deploying this system, offering insights into the challenges of building resilient agentic systems at scale."}
{"id": "2602.16913", "categories": ["cs.PL", "cs.AI", "cs.LO"], "pdf": "https://arxiv.org/pdf/2602.16913", "abs": "https://arxiv.org/abs/2602.16913", "authors": ["Ivan Lanese", "Germán Vidal"], "title": "A Reversible Semantics for Janus", "comment": "Submitted for publication", "summary": "Janus is a paradigmatic example of reversible programming language. Indeed, Janus programs can be executed backwards as well as forwards. However, its small-step semantics (useful, e.g., for debugging or as a basis for extensions with concurrency primitives) is not reversible, since it loses information while computing forwards. E.g., it does not satisfy the Loop Lemma, stating that any reduction has an inverse, a main property of reversibility in process calculi, where small-step semantics is commonly used. We present here a novel small-step semantics which is actually reversible, while remaining equivalent to the previous one. It involves the non-trivial challenge of defining a semantics based on a \"program counter\" for a high-level programming language."}
{"id": "2602.17091", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2602.17091", "abs": "https://arxiv.org/abs/2602.17091", "authors": ["Kan Watanabe", "Tatsuya Shirai", "Yutaro Kashiwa", "Hajimu Iida"], "title": "What to Cut? Predicting Unnecessary Methods in Agentic Code Generation", "comment": null, "summary": "Agentic Coding, powered by autonomous agents such as GitHub Copilot and Cursor, enables developers to generate code, tests, and pull requests from natural language instructions alone. While this accelerates implementation, it produces larger volumes of code per pull request, shifting the burden from implementers to reviewers. In practice, a notable portion of AI-generated code is eventually deleted during review, yet reviewers must still examine such code before deciding to remove it. No prior work has explored methods to help reviewers efficiently identify code that will be removed.In this paper, we propose a prediction model that identifies functions likely to be deleted during PR review. Our results show that functions deleted for different reasons exhibit distinct characteristics, and our model achieves an AUC of 87.1%. These findings suggest that predictive approaches can help reviewers prioritize their efforts on essential code."}
{"id": "2602.16981", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2602.16981", "abs": "https://arxiv.org/abs/2602.16981", "authors": ["Jasper Geer", "Fox Huston", "Jeffrey S. Foster"], "title": "Mason: Type- and Name-Guided Program Synthesis", "comment": null, "summary": "Object-oriented programs tend to be written using many common coding idioms, such as those captured by design patterns. While design patterns are useful, implementing them is often tedious and repetitive, requiring boilerplate code that distracts the programmer from more essential details. In this paper, we introduce Mason, a tool that synthesizes object-oriented programs from partial program pieces, and we apply it to automatically insert design patterns into programs. At the core of Mason is a novel technique we call type- and name-guided synthesis, in which an enumerative solver traverses a partial program to generate typing constraints; discharges constraints via program transformations guided by the names of constrained types and members; and backtracks when a constraint is violated or a candidate program fails unit tests. We also introduce two extensions to Mason: a non-local backtracking heuristic that uses execution traces, and a language of patterns that impose syntactic restrictions on missing names. We evaluate Mason on a suite of benchmarks to which Mason must add various well-known design patterns implemented as a library of program pieces. We find that Mason performs well when very few candidate programs satisfy its typing constraints and that our extensions can improve Mason's performance significantly when this is not the case. We believe that Mason takes an important step forward in synthesizing multi-class object-oriented programs using design patterns."}
{"id": "2602.17112", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2602.17112", "abs": "https://arxiv.org/abs/2602.17112", "authors": ["Arjun Ashok", "Nafiz Imtiaz Khan", "Swati Singhvi", "Stefan Stanciulescu", "Zhouhao Wang", "Vladimir Filkov"], "title": "Multi-Ecosystem Modeling of OSS Project Sustainability", "comment": "42 pages, 11 figures", "summary": "Many OSS projects join foundations such as Apache, Eclipse, and OSGeo, to aid their immediate plans and improve long-term prospects by getting governance advice, incubation support, and community-building mechanisms. But foundations differ in their policies, funding models, and support strategies. Moreover, since projects joining these foundations are diverse, coming at different lifecycle stages and having different needs, it can be challenging to decide on the appropriate project-foundation match and on the project-specific plan for sustainability.\n  Here, we present an empirical study and quantitative analysis of the sustainability of incubator projects in the Apache, Eclipse, and OSGeo foundations, and, additionally, of OSS projects from GitHub outside of foundations. We develop foundation-specific sustainability models and a project triage, based on projects' sociotechnical trace profiles, and demonstrate their effectiveness across the foundations. Our results show that our models with triage can effectively forecast sustainability outcomes not only within but across foundations. In addition, the generalizability of the framework allows us to apply the approach to GitHub projects outside the foundations. We complement our findings with actionable recovery strategies from previous work and apply them to case studies of failed incubator projects. Our study highlights the value of sociotechnical frameworks in characterizing and addressing software project sustainability issues."}
{"id": "2602.17131", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2602.17131", "abs": "https://arxiv.org/abs/2602.17131", "authors": ["Yuki Takei", "Toshiaki Aoki", "Chaiyong Ragkhitwetsagul"], "title": "Quantifying Competitive Relationships Among Open-Source Software Projects", "comment": "12 pages, 3 figures, 7 tables. Accepted at MSR 2026", "summary": "Throughout the history of software, evolution has occurred in cycles of rise and fall driven by competition, and open-source software (OSS) is no exception. This cycle is accelerating, particularly in rapidly evolving domains such as web development and deep learning. However, the impact of competitive relationships among OSS projects on their survival remains unclear, and there are risks of losing a competitive edge to rivals. To address this, this study proposes a new automated method called ``Mutual Impact Analysis of OSS (MIAO)'' to quantify these competitive relationships. The proposed method employs a structural vector autoregressive model and impulse response functions, normally used in macroeconomic analysis, to analyze the interactions among OSS projects. In an empirical analysis involving mining and analyzing 187 OSS project groups, MIAO identified projects that were forced to cease development owing to competitive influences with up to 81\\% accuracy, and the resulting features supported predictive experiments that anticipate cessation one year ahead with up to 77\\% accuracy. This suggests that MIAO could be a valuable tool for OSS project maintainers to understand the dynamics of OSS ecosystems and predict the rise and fall of OSS projects."}
{"id": "2602.17183", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2602.17183", "abs": "https://arxiv.org/abs/2602.17183", "authors": ["Kishan Maharaj", "Nandakishore Menon", "Ashita Saxena", "Srikanth Tamilselvam"], "title": "Robustness and Reasoning Fidelity of Large Language Models in Long-Context Code Question Answering", "comment": "11 pages, 4 Figures, 5 Tables, Work in Progress", "summary": "Large language models (LLMs) increasingly assist software engineering tasks that require reasoning over long code contexts, yet their robustness under varying input conditions remains unclear. We conduct a systematic study of long-context code question answering using controlled ablations that test sensitivity to answer format, distractors, and context scale. Extending LongCodeBench Python dataset with new COBOL and Java question-answer sets, we evaluate state-of-the-art models under three settings: (i) shuffled multiple-choice options, (ii) open-ended questions and (iii) needle-in-a-haystack contexts containing relevant and adversarially irrelevant information. Results show substantial performance drops in both shuffled multiple-choice options and open-ended questions, and brittle behavior in the presence of irrelevant cues. Our findings highlight limitations of current long-context evaluations and provide a broader benchmark for assessing code reasoning in both legacy and modern systems."}
{"id": "2602.17193", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2602.17193", "abs": "https://arxiv.org/abs/2602.17193", "authors": ["Juho Vepsäläinen"], "title": "The Case for HTML First Web Development", "comment": "28 pages, 5 figures, 5 tables, preprint", "summary": "Since its introduction in the early 90s, the web has become the largest application platform available globally. HyperText Markup Language (HTML) has been an essential part of the web since the beginning, as it allows defining webpages in a tree-like manner, including semantics and content. Although the web was never meant to be an application platform, it evolved as such, especially since the early 2000s, as web application frameworks became available. While the emergence of frameworks made it easier than ever to develop complex applications, it also put HTML on the back burner. As web standards caught up, especially with milestones such as HTML5, the gap between the web platform and frameworks was reduced. HTML First development emphasizes this shift and puts focus on literally using HTML first when possible, while encouraging minimalism familiar from the early days of the web. It seems HTML-oriented web development can provide clear benefits to developers, especially when it is combined with comple- mentary approaches, such as embracing hypermedia and moving a large part of application logic to the server side. In the context of the htmx project, it was observed that moving towards HTML can reduce the size of a codebase greatly while leading to maintenance and development benefits due to the increased conceptual simplicity. Holotype-based comparisons for content-oriented websites show performance benefits, and the same observation was confirmed by a small case study where the Yle website was converted to follow HTML First principles. In short, the HTML First approach seems to have clear advantages for web developers, while there are open questions related to the magnitude of the benefits and the alignment with the recent trend of AI-driven web development."}
{"id": "2602.17237", "categories": ["cs.SE", "cs.FL"], "pdf": "https://arxiv.org/pdf/2602.17237", "abs": "https://arxiv.org/abs/2602.17237", "authors": ["Tannaz Zameni", "Petra van den Bos", "Arend Rensink"], "title": "Disjunction Composition of BDD Transition Systems for Model-Based Testing", "comment": "Technical report with proofs", "summary": "We introduce a compositional approach to model-based test generation in Behavior-Driven Development (BDD). BDD is an agile methodology in which system behavior is specified through textual scenarios that, in our approach, are translated into transition systems used for model-based testing. This paper formally defines disjunction composition, to combine BDD transition systems that represent alternative system behaviors. Disjunction composition allows for modeling and testing the integrated behavior while ensuring that the testing power of the original set of scenarios is preserved. This is proved using a symbolic semantics for BDD transition systems, with the property that the symbolic equivalence of two BDD transition systems guarantees that they fail the same test cases. Also, we demonstrate the potential of disjunction composition by applying the composition in an industrial case study."}
{"id": "2602.17320", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2602.17320", "abs": "https://arxiv.org/abs/2602.17320", "authors": ["Stefano Lambiase", "Manuel De Stefano", "Fabio Palomba", "Filomena Ferrucci", "Andrea De Lucia"], "title": "Socio-Technical Well-Being of Quantum Software Communities: An Overview on Community Smells", "comment": null, "summary": "Quantum computing has gained significant attention due to its potential to solve computational problems beyond the capabilities of classical computers. With major corporations and academic institutions investing in quantum hardware and software, there has been a rise in the development of quantum-enabled systems, particularly within open-source communities. However, despite the promising nature of quantum technologies, these communities face critical socio-technical challenges, including the emergence of socio-technical anti-patterns known as community smells. These anti-patterns, prevalent in open-source environments, have the potential to negatively impact both product quality and community health by introducing technical debt and amplifying architectural and code smells. Despite the importance of these socio-technical factors, there remains a scarcity of research investigating their influence within quantum open-source communities. This work aims to address this gap by providing a first step in analyzing the socio-technical well-being of quantum communities through a cross-sectional study. By understanding the socio-technical dynamics at play, it is expected that foundational knowledge can be established to mitigate the risks associated with community smells and ensure the long-term sustainability of open-source quantum initiatives."}
{"id": "2602.17365", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2602.17365", "abs": "https://arxiv.org/abs/2602.17365", "authors": ["Yiming Guan", "Rui Yu", "John Zhang", "Lu Wang", "Chaoyun Zhang", "Liqun Li", "Bo Qiao", "Si Qin", "He Huang", "Fangkai Yang", "Pu Zhao", "Lukas Wutschitz", "Samuel Kessler", "Huseyin A Inan", "Robert Sim", "Saravan Rajmohan", "Qingwei Lin", "Dongmei Zhang"], "title": "Computer-Using World Model", "comment": "35 pages, 7 figures", "summary": "Agents operating in complex software environments benefit from reasoning about the consequences of their actions, as even a single incorrect user interface (UI) operation can derail long, artifact-preserving workflows. This challenge is particularly acute for computer-using scenarios, where real execution does not support counterfactual exploration, making large-scale trial-and-error learning and planning impractical despite the environment being fully digital and deterministic. We introduce the Computer-Using World Model (CUWM), a world model for desktop software that predicts the next UI state given the current state and a candidate action. CUWM adopts a two-stage factorization of UI dynamics: it first predicts a textual description of agent-relevant state changes, and then realizes these changes visually to synthesize the next screenshot. CUWM is trained on offline UI transitions collected from agents interacting with real Microsoft Office applications, and further refined with a lightweight reinforcement learning stage that aligns textual transition predictions with the structural requirements of computer-using environments. We evaluate CUWM via test-time action search, where a frozen agent uses the world model to simulate and compare candidate actions before execution. Across a range of Office tasks, world-model-guided test-time scaling improves decision quality and execution robustness."}
{"id": "2602.17426", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2602.17426", "abs": "https://arxiv.org/abs/2602.17426", "authors": ["Marco Autili", "Gianluca Filippone", "Mashal Afzal Memon", "Patrizio Pelliccione"], "title": "The Runtime Dimension of Ethics in Self-Adaptive Systems", "comment": null, "summary": "Self-adaptive systems increasingly operate in close interaction with humans, often sharing the same physical or virtual environments and making decisions with ethical implications at runtime. Current approaches typically encode ethics as fixed, rule-based constraints or as a single chosen ethical theory embedded at design time. This overlooks a fundamental property of human-system interaction settings: ethical preferences vary across individuals and groups, evolve with context, and may conflict, while still needing to remain within a legally and regulatorily defined hard-ethics envelope (e.g., safety and compliance constraints). This paper advocates a shift from static ethical rules to runtime ethical reasoning for self-adaptive systems, where ethical preferences are treated as runtime requirements that must be elicited, represented, and continuously revised as stakeholders and situations change. We argue that satisfying such requirements demands explicit ethics-based negotiation to manage ethical trade-offs among multiple humans who interact with, are represented by, or are affected by a system. We identify key challenges, ethical uncertainty, conflicts among ethical values (including human, societal, and environmental drivers), and multi-dimensional/multi-party/multi-driver negotiation, and outline research directions and questions toward ethically self-adaptive systems."}
{"id": "2602.17498", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2602.17498", "abs": "https://arxiv.org/abs/2602.17498", "authors": ["Julian Frattini", "Quim Motger"], "title": "Towards a Software Reference Architecture for Natural Language Processing Tools in Requirements Engineering", "comment": null, "summary": "Natural Language Processing (NLP) tools support requirements engineering (RE) tasks like requirements elicitation, classification, and validation. However, they are often developed from scratch despite functional overlaps, and abandoned after publication. This lack of interoperability and maintenance incurs unnecessary development effort, impedes tool comparison and benchmarking, complicates documentation, and diminishes the long-term sustainability of NLP4RE tools. To address these issues, we postulate a vision to transition from monolithic NLP4RE tools to an ecosystem of reusable, interoperable modules. We outline a research roadmap towards a software reference architecture (SRA) to realize this vision, elaborated following a standard methodological framework for SRA development. As an initial step, we conducted a stakeholder-driven focus group session to elicit generic system requirements for NLP4RE tools. This activity resulted in 36 key system requirements, further motivating the need for a dedicated SRA. Overall, the proposed vision, roadmap, and initial contribution pave the way towards improved development, reuse, and long-term maintenance of NLP4RE tools."}
