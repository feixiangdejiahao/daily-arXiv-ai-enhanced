<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 42]
- [cs.PL](#cs.PL) [Total: 5]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [ScaleCall - Agentic Tool Calling at Scale for Fintech: Challenges, Methods, and Deployment Insights](https://arxiv.org/abs/2511.00074)
*Richard Osuagwu,Thomas Cook,Maraim Masoud,Koustav Ghosal,Riccardo Mattivi*

Main category: cs.SE

TL;DR: The paper investigates and compares multiple tool retrieval approaches for LLM-powered systems in fintech, building a practical framework (ScaleCall) and showing that the best method depends on the specific enterprise context, regulatory needs, and tool complexities. Results guide future enterprise LLM application design.


<details>
  <summary>Details</summary>
Motivation: Despite the strong tool-calling capabilities of Large Language Models (LLMs), deploying them in regulated enterprise environments like fintech is challenging due to regulatory, technical, and operational requirements as well as complexities in managing large, overlapping toolsets.

Method: The paper develops and deploys ScaleCall, a prototype tool-calling framework within Mastercard for orchestrating internal APIs and automating workflows. Various tool retrieval methods are systematically evaluated, including embedding-based retrieval, prompt-based listwise ranking, and hybrid techniques, using enterprise-derived benchmarks.

Result: Embedding-based methods yielded superior latency for large tool repositories, while listwise ranking provided better disambiguation for overlapping functionalities. Hybrid approaches showed potential in specific situations. The framework was successfully validated in Mastercard's regulated environment.

Conclusion: The study highlights that there is no one-size-fits-all algorithmic solution for enterprise tool retrieval; effectiveness depends on domain-specific requirements. Practical insights are provided for balancing retrieval accuracy, computational efficiency, and operational needs in regulated industries.

Abstract: While Large Language Models (LLMs) excel at tool calling, deploying these
capabilities in regulated enterprise environments such as fintech presents
unique challenges due to on-premises constraints, regulatory compliance
requirements, and the need to disambiguate large, functionally overlapping
toolsets. In this paper, we present a comprehensive study of tool retrieval
methods for enterprise environments through the development and deployment of
ScaleCall, a prototype tool-calling framework within Mastercard designed for
orchestrating internal APIs and automating data engineering workflows. We
systematically evaluate embedding-based retrieval, prompt-based listwise
ranking, and hybrid approaches, revealing that method effectiveness depends
heavily on domain-specific factors rather than inherent algorithmic
superiority. Through empirical investigation on enterprise-derived benchmarks,
we find that embedding-based methods offer superior latency for large tool
repositories, while listwise ranking provides better disambiguation for
overlapping functionalities, with hybrid approaches showing promise in specific
contexts. We integrate our findings into ScaleCall's flexible architecture and
validate the framework through real-world deployment in Mastercard's regulated
environment. Our work provides practical insights into the trade-offs between
retrieval accuracy, computational efficiency, and operational requirements,
contributing to the understanding of tool-calling system design for enterprise
applications in regulated industries.

</details>


### [2] [Adding New Capability in Existing Scientific Application with LLM Assistance](https://arxiv.org/abs/2511.00087)
*Anshu Dubey,Akash Dhruv*

Main category: cs.SE

TL;DR: This paper proposes a method to use LLMs and an enhanced version of Code-Scribe to help write code from scratch for new algorithms, addressing the limitation of LLMs when generating code for algorithms with no prior training data examples.


<details>
  <summary>Details</summary>
Motivation: While large language models have demonstrated impressive abilities for code generation, a largely overlooked challenge is generating code for entirely new algorithms that lack training examples. This paper addresses that gap.

Method: The authors introduce a new methodology for generating code from scratch for novel algorithms with the help of large language models (LLMs). They also enhance an existing code-translation tool, Code-Scribe, to better support this new code generation scenario.

Result: The paper presents a workflow leveraging LLMs and improved code-translation tools for the challenging problem of coding new, previously unseen algorithms. Specific implementation or evaluation details are not given in the abstract.

Conclusion: Using LLMs, combined with specialized tooling (Code-Scribe), provides a promising approach for writing code for novel algorithms that do not exist in LLM training data.

Abstract: With the emergence and rapid evolution of large language models (LLM),
automating coding tasks has become an im- portant research topic. Many efforts
are underway and liter- ature abounds about the efficacy of models and their
ability to generate code. A less explored aspect of code generation is for new
algorithms, where the training data-set would not have included any previous
example of similar code. In this paper we propose a new methodology for writing
code from scratch for a new algorithm using LLM assistance, and describe
enhancement of a previously developed code- translation tool, Code-Scribe, for
new code generation.

</details>


### [3] [Inferring multiple helper Dafny assertions with LLMs](https://arxiv.org/abs/2511.00125)
*Álvaro Silva,Alexandra Mendes,Ruben Martins*

Main category: cs.SE

TL;DR: The paper introduces DAISY, a tool that uses large language models to automatically add missing helper assertions in Dafny programs, greatly reducing manual effort and helping make formal verification more accessible.


<details>
  <summary>Details</summary>
Motivation: The Dafny verifier needs many manual helper assertions, which creates a significant barrier to its adoption. There's a need to ease this process and lower the manual effort required to use Dafny for formal verification.

Method: The authors investigate using Large Language Models (LLMs) to automatically infer missing helper assertions in Dafny programs. They extend the DafnyBench benchmark to create datasets with varying numbers of missing assertions, introduce an assertion taxonomy, and develop a hybrid approach that combines LLM predictions with error-message heuristics. This method is implemented as a new tool called DAISY.

Result: DAISY successfully verifies 63.4% of programs with one missing assertion and 31.7% with multiple missing assertions. The study also finds that many programs can be verified with fewer assertions than originally present, implying that multiple proof repair strategies are valid.

Conclusion: Automated inference of helper assertions using LLMs, as realized in DAISY, significantly reduces the manual proof effort in Dafny. This approach improves the scalability and accessibility of formal verification, moving toward more widespread adoption.

Abstract: The Dafny verifier provides strong correctness guarantees but often requires
numerous manual helper assertions, creating a significant barrier to adoption.
We investigate the use of Large Language Models (LLMs) to automatically infer
missing helper assertions in Dafny programs, with a primary focus on cases
involving multiple missing assertions. To support this study, we extend the
DafnyBench benchmark with curated datasets where one, two, or all assertions
are removed, and we introduce a taxonomy of assertion types to analyze
inference difficulty. Our approach refines fault localization through a hybrid
method that combines LLM predictions with error-message heuristics. We
implement this approach in a new tool called DAISY (Dafny Assertion Inference
SYstem). While our focus is on multiple missing assertions, we also evaluate
DAISY on single-assertion cases. DAISY verifies 63.4% of programs with one
missing assertion and 31.7% with multiple missing assertions. Notably, many
programs can be verified with fewer assertions than originally present,
highlighting that proofs often admit multiple valid repair strategies and that
recovering every original assertion is unnecessary. These results demonstrate
that automated assertion inference can substantially reduce proof engineering
effort and represent a step toward more scalable and accessible formal
verification.

</details>


### [4] [What a diff makes: automating code migration with large language models](https://arxiv.org/abs/2511.00160)
*Katherine A. Rosenfeld,Cliff C. Kerr,Jessica Lundin*

Main category: cs.SE

TL;DR: The paper shows that using LLMs with diff contexts improves automated code migration for software dependencies, outperforming standard methods. Their open-source tool AIMigrate achieved notable accuracy in real-world migrations, offering valuable support for dependency updates.


<details>
  <summary>Details</summary>
Motivation: Software stacks frequently change, causing compatibility issues for dependent projects. Addressing code migration due to updates is critical for software reliability and maintainability.

Method: The paper investigates leveraging Large Language Models (LLMs) for automating code migration when dependencies undergo semantic version changes. Contexts containing diffs are compared against out-of-the-box LLMs and code-based contexts using metrics like test coverage and change comparisons. The authors also introduce a dataset and an open-source Python tool called AIMigrate.

Result: Contexts with diffs significantly enhance migration performance, sometimes outperforming code-only approaches. In a case study of migrating TYPHOIDSIM to a new version of STARSIM, AIMigrate correctly identified 65% of required changes in one run and 80% with multiple runs, with 47% of changes being perfectly generated.

Conclusion: LLMs can substantially assist in code migration tasks, especially when utilizing context-rich information like diffs. Tools like AIMigrate show promise in automating dependency upgrade processes.

Abstract: Modern software programs are built on stacks that are often undergoing
changes that introduce updates and improvements, but may also break any project
that depends upon them. In this paper we explore the use of Large Language
Models (LLMs) for code migration, specifically the problem of maintaining
compatibility with a dependency as it undergoes major and minor semantic
version changes. We demonstrate, using metrics such as test coverage and change
comparisons, that contexts containing diffs can significantly improve
performance against out of the box LLMs and, in some cases, perform better than
using code. We provide a dataset to assist in further development of this
problem area, as well as an open-source Python package, AIMigrate, that can be
used to assist with migrating code bases. In a real-world migration of
TYPHOIDSIM between STARSIM versions, AIMigrate correctly identified 65% of
required changes in a single run, increasing to 80% with multiple runs, with
47% of changes generated perfectly.

</details>


### [5] [Understanding Code Agent Behaviour: An Empirical Study of Success and Failure Trajectories](https://arxiv.org/abs/2511.00197)
*Oorja Majgaonkar,Zhiwei Fei,Xiang Li,Federica Sarro,He Ye*

Main category: cs.SE

TL;DR: This paper analyzes the detailed behaviors of leading code-generating LLM agents on software tasks, showing that their problem-solving paths and strategies hold the key to both their successes and failures. Understanding these trajectories can help design better, more reliable AI agents for software engineering.


<details>
  <summary>Details</summary>
Motivation: There is a growing use of Large Language Model (LLM) agents in complex software engineering, but their problem-solving processes are not well understood beyond whether they succeed or fail. Understanding their behaviors and trajectories can help improve their effectiveness and interpretability.

Method: The paper conducts an empirical study by analyzing execution traces (trajectories) from three advanced code agents—OpenHands, SWE-agent, and Prometheus—using the SWE-Bench benchmark. Both successful and failed attempts at issue resolution are examined for patterns and strategies.

Result: The study finds that successful agent strategies include defensive programming and context gathering, which are effective in varying circumstances. Failed attempts have longer, more variable trajectories, and the nature of these failures differs across agents. Importantly, most trajectories (even failures) accurately localize faults, but overall success depends more on making approximately correct code changes than exact ones.

Conclusion: Trajectory analysis offers valuable insights into LLM agent behavior, revealing actionable strategies and failure patterns. This helps pave the way for more interpretable and robust autonomous software engineering agents by moving beyond simple success/failure definitions.

Abstract: The increasing deployment of Large Language Model (LLM) agents for complex
software engineering tasks has created a need to understand their
problem-solving behaviours beyond simple success metrics. While these agents
demonstrate impressive capabilities in automated issue resolution, their
decision-making processes remain largely opaque. This paper presents an
empirical study of agent trajectories, namely the execution traces capturing
the steps agents take when attempting to resolve software issues. We analyse
trajectories from three state-of-the-art code agents (OpenHands, SWE-agent, and
Prometheus) on the SWE-Bench benchmark, examining both successful and failed
attempts. Our investigation reveals several key insights into agent behaviour.
First, we identify how distinct problem-solving strategies, such as defensive
programming and context gathering, enable success in different scenarios.
Second, we find that failed trajectories are consistently longer and exhibit
higher variance than successful ones, with failure patterns differing
significantly between agents. Third, our fault localisation analysis shows that
while most trajectories correctly identify problematic files (72-81\% even in
failures), success depends more on achieving approximate rather than exact code
modifications. These and other findings unveiled by our study, provide a
foundation for understanding agent behaviour through trajectory analysis,
contributing to the development of more robust and interpretable autonomous
software engineering systems.

</details>


### [6] [Position: Vibe Coding Needs Vibe Reasoning: Improving Vibe Coding with Formal Verification](https://arxiv.org/abs/2511.00202)
*Jacqueline Mitchell,Yasser Shaaban*

Main category: cs.SE

TL;DR: Vibe coding with LLMs suffers from code inconsistency and technical problems due to poor management of evolving constraints. This paper suggests that integrating formal verification through a dedicated side-car system can overcome these issues and lead to more dependable software development.


<details>
  <summary>Details</summary>
Motivation: Vibe coding with LLMs is increasingly popular, but developers face issues like technical debt, security problems, and unreliable code results. The motivation is to address these pitfalls caused by the disconnect between iterative human constraints and LLMs' focus on immediate user commands.

Method: The paper proposes a new 'side-car system' integrated throughout vibe coding, which autoformalizes specifications, validates outputs against targets, provides actionable feedback to the LLM, and allows developers to intuitively adjust specifications.

Result: The implementation of the proposed side-car system aims to improve reliability and mitigate technical pitfalls in vibe coding by systematically reconciling human-imposed constraints and verification using formal methods.

Conclusion: Using formal methods, delivered via a seamless side-car system, can substantially reduce the pitfalls of vibe coding with LLMs and make the process more reliable, maintainable, and secure than current approaches.

Abstract: ``Vibe coding'' -- the practice of developing software through iteratively
conversing with a large language model (LLM) -- has exploded in popularity
within the last year. However, developers report key limitations including the
accumulation of technical debt, security issues, and code churn to achieve
satisfactory results. We argue that these pitfalls result from LLMs' inability
to reconcile accumulating human-imposed constraints during vibe coding, with
developers inadvertently failing to resolve contradictions because LLMs
prioritize user commands over code consistency. Given LLMs' receptiveness to
verification-based feedback, we argue that formal methods can mitigate these
pitfalls, making vibe coding more reliable. However, we posit that integrating
formal methods must transcend existing approaches that combine formal methods
and LLMs. We advocate for a side-car system throughout the vibe coding process
which: (1) \emph{Autoformalizes} specifications (2) Validates against targets,
(3) Delivers \emph{actionable} feedback to the LLM, and (4) Allows intuitive
developer influence on specifications.

</details>


### [7] [DocPrism: Local Categorization and External Filtering to Identify Relevant Code-Documentation Inconsistencies](https://arxiv.org/abs/2511.00215)
*Xiaomeng Xu,Zahin Wahab,Reid Holmes,Caroline Lemieux*

Main category: cs.SE

TL;DR: DocPrism is a multi-language tool that uses LLMs to spot code-documentation inconsistencies. By adding a novel LCEF filtering method, it significantly improves accuracy and reduces false alarms. It works well across various languages and doesn't need fine-tuning.


<details>
  <summary>Details</summary>
Motivation: Code-documentation inconsistencies frequently occur in software projects and can result in developer confusion and increase the risk of software errors, hence there is a need for effective tools that detect and explain such inconsistencies.

Method: The paper introduces DocPrism, a tool that uses a standard LLM to detect code-documentation inconsistencies in multiple languages. To address the challenge of high false positive rates in LLM-based detection, the authors propose the Local Categorization, External Filtering (LCEF) methodology, which leverages the LLM's local completion skills and applies external filtering to reduce misclassifications.

Result: Using LCEF, DocPrism reduced the inconsistency flag rate from 98% to 14% in ablation studies and raised detection accuracy from 14% to 94%. In wider evaluation across Python, TypeScript, C++, and Java, DocPrism maintained a low flag rate (15%) and achieved a precision score of 0.62 without any fine-tuning.

Conclusion: DocPrism demonstrates the effectiveness of combining LLMs with the LCEF methodology to accurately detect code-documentation inconsistencies across several programming languages, greatly reducing false positives with high accuracy and without needing fine-tuning.

Abstract: Code-documentation inconsistencies are common and undesirable: they can lead
to developer misunderstandings and software defects. This paper introduces
DocPrism, a multi-language, code-documentation inconsistency detection tool.
DocPrism uses a standard large language model (LLM) to analyze and explain
inconsistencies. Plain use of LLMs for this task yield unacceptably high false
positive rates: LLMs identify natural gaps between high-level documentation and
detailed code implementations as inconsistencies. We introduce and apply the
Local Categorization, External Filtering (LCEF) methodology to reduce false
positives. LCEF relies on the LLM's local completion skills rather than its
long-term reasoning skills. In our ablation study, LCEF reduces DocPrism's
inconsistency flag rate from 98% to 14%, and increases accuracy from 14% to
94%. On a broad evaluation across Python, TypeScript, C++, and Java, DocPrism
maintains a low flag rate of 15%, and achieves a precision of 0.62 without
performing any fine-tuning.

</details>


### [8] [LLM-Driven Cost-Effective Requirements Change Impact Analysis](https://arxiv.org/abs/2511.00262)
*Romina Etezadi,Sallam Abualhaija,Chetan Arora,Lionel Briand*

Main category: cs.SE

TL;DR: Manual impact analysis of requirements is inefficient and error-prone. ProReFiCIA, an LLM-powered system, automatically detects impacted requirements with high recall (>93%) and minimal review effort, making requirements change management much more effective.


<details>
  <summary>Details</summary>
Motivation: Manual identification of impacted requirements after changes in the software development process is error-prone and resource-intensive due to budget and human limitations. This can cause overlooked requirements and serious issues in subsequent development stages.

Method: The authors propose ProReFiCIA, a Large Language Model (LLM)-based automatic approach to identify impacted requirements, experimenting with several LLMs and customized prompts to optimize performance.

Result: ProReFiCIA achieves a recall of 93.3% on a benchmark dataset and 95.8% on a new industry dataset. It requires engineers to review only 2.1% to 8.5% of all requirements, minimizing effort.

Conclusion: ProReFiCIA is highly effective in automatically identifying impacted requirements with low manual effort, leveraging the capabilities of LLMs. This approach can substantially improve requirements traceability and change management in software engineering.

Abstract: Requirements are inherently subject to changes throughout the software
development lifecycle. Within the limited budget available to requirements
engineers, manually identifying the impact of such changes on other
requirements is both error-prone and effort-intensive. That might lead to
overlooked impacted requirements, which, if not properly managed, can cause
serious issues in the downstream tasks. Inspired by the growing potential of
large language models (LLMs) across diverse domains, we propose ProReFiCIA, an
LLM-driven approach for automatically identifying the impacted requirements
when changes occur. We conduct an extensive evaluation of ProReFiCIA using
several LLMs and prompts variants tailored to this task. Using the best
combination of an LLM and a prompt variant, ProReFiCIA achieves a recall of
93.3% on a benchmark dataset and 95.8% on a newly created industry dataset,
demonstrating its strong effectiveness in identifying impacted requirements.
Further, the cost of applying ProReFiCIA remains small, as the engineer only
needs to review the generated results, which represent between 2.1% and 8.5% of
the entire set of requirements.

</details>


### [9] [Human-AI Programming Role Optimization: Developing a Personality-Driven Self-Determination Framework](https://arxiv.org/abs/2511.00417)
*Marcel Valovy*

Main category: cs.SE

TL;DR: Optimizing software development team roles based on personality traits, using the ROMA framework, substantially increases motivation and collaboration when working with AI. The work offers practical, standards-aligned tools to implement this approach, validated through extensive research.


<details>
  <summary>Details</summary>
Motivation: As AI becomes increasingly embedded in software development, there is a need to understand and optimize how developers and AI systems work together. The goal is to maximize developer motivation, satisfaction, and productivity by aligning human roles with inherent personality traits.

Method: The dissertation employs Design Science Research over five iterative cycles, involving 200 experimental participants and 46 interviewees. It develops and validates the Role Optimization Motivation Alignment (ROMA) framework, combining self-determination theory and personality psychology.

Result: The study empirically demonstrates that aligning programming roles with individual personality traits greatly increases motivation (by 23% for professionals and up to 65% for undergraduates) and improves team dynamics. Five personality archetypes and their preferred collaborative AI roles are identified, and their assignment modes are shown to be crucial for satisfaction.

Conclusion: Personality-driven role assignment in human-AI software development teams significantly boosts motivation and team functioning. The research delivers an empirically-backed framework, a taxonomy for AI collaboration tailored to personalities, and an extension to ISO/IEC 29110 for small entities to utilize personality-based role optimization.

Abstract: As artificial intelligence transforms software development, a critical
question emerges: how can developers and AI systems collaborate most
effectively? This dissertation optimizes human-AI programming roles through
self-determination theory and personality psychology, introducing the Role
Optimization Motivation Alignment (ROMA) framework.
  Through Design Science Research spanning five cycles, this work establishes
empirically-validated connections between personality traits, programming role
preferences, and collaborative outcomes, engaging 200 experimental participants
and 46 interview respondents.
  Key findings demonstrate that personality-driven role optimization
significantly enhances self-determination and team dynamics, yielding 23%
average motivation increases among professionals and up to 65% among
undergraduates. Five distinct personality archetypes emerge: The Explorer (high
Openness/low Agreeableness), The Orchestrator (high
Extraversion/Agreeableness), The Craftsperson (high Neuroticism/low
Extraversion), The Architect (high Conscientiousness), and The Adapter
(balanced profile). Each exhibits distinct preferences for programming roles
(Co-Pilot, Co-Navigator, Agent), with assignment modes proving crucial for
satisfaction.
  The dissertation contributes: (1) an empirically-validated framework linking
personality traits to role preferences and self-determination outcomes; (2) a
taxonomy of AI collaboration modalities mapped to personality profiles while
preserving human agency; and (3) an ISO/IEC 29110 extension enabling Very Small
Entities to implement personality-driven role optimization within established
standards.
  Keywords: artificial intelligence, human-computer interaction, behavioral
software engineering, self-determination theory, personality psychology,
phenomenology, intrinsic motivation, pair programming, design science research,
ISO/IEC 29110

</details>


### [10] [SmartDoc: A Context-Aware Agentic Method Comment Generation Plugin](https://arxiv.org/abs/2511.00450)
*Vahid Etemadi,Gregorio Robles*

Main category: cs.SE

TL;DR: SmartDoc, an IntelliJ plugin, uses AI and method call context to generate precise comments for Java methods, achieving high accuracy (BERTScore 0.80-0.90), thus aiding maintenance tasks.


<details>
  <summary>Details</summary>
Motivation: Software maintenance requires extensive program comprehension for activities like bug fixing and refactoring. Reading complete method bodies is challenging for developers, so precise, contextual comments are needed to aid understanding.

Method: The authors developed SmartDoc, an IntelliJ IDEA plugin that uses AI to generate context-aware method comments. It builds a call graph of nested methods using DFS and incorporates their contents to enrich LLM (Large Language Model) prompts for comment generation. The plugin supports parallel updates and shares memory to optimize performance.

Result: SmartDoc was tested on Java codebases. Its generated comments were compared against ground truth using BERTScore, BLEU, and ROUGE-1 metrics. The plugin achieved promising accuracy, with BERTScore values between 0.80 and 0.90 for precision, recall, and F1.

Conclusion: SmartDoc effectively generates accurate, context-aware comments for Java methods, streamlining software maintenance tasks by improving code comprehension.

Abstract: Context: The software maintenance phase involves many activities such as code
refactoring, bug fixing, code review or testing. Program comprehension is key
to all these activities, as it demands developers to grasp the knowledge (e.g.,
implementation details) required to modify the codebase. Methods as main
building blocks in a program can offer developers this knowledge source for
code comprehension. However, reading entire method statements can be
challenging, which necessitates precise and up-to-date comments. Objective: We
propose a solution as an IntelliJ IDEA plugin, named SmartDoc, that assists
developers in generating context-aware method comments. Method: This plugin
acts as an Artificial Intelligence (AI) agent that has its own memory and is
augmented by target methods' context. When a request is initiated by the
end-user, the method content and all its nested method calls are used in the
comment generation. At the beginning, these nested methods are visited and a
call graph is generated. This graph is then traversed using depth-first search
(DFS), enabling the provision of full-context to enrich Large Language Model
(LLM) prompts. Result: The product is a software, as a plugin, developed for
Java codebase and installable on IntelliJ IDEA. This plugin can serve
concurrently for methods whose comments are being updated , and it shares
memory across all flows to avoid redundant calls. o measure the accuracy of
this solution, a dedicated test case is run to record SmartDoc generated
comments and their corresponding ground truth. For each collected result-set,
three metrics are computed, BERTScore, BLEU and ROUGE-1. These metrics will
determine how accurate the generated comments are in comparison to the ground
truth. Result: The obtained accuracy, in terms of the precision, recall and F1,
is promising, and lies in the range of 0.80 to 0.90 for BERTScore.

</details>


### [11] [Hidden in Plain Sight: Where Developers Confess Self-Admitted Technical Debt](https://arxiv.org/abs/2511.01529)
*Murali Sridharan,Mikel Robredo,Leevi Rantala,Matteo Esposito,Valentina Lenarduzzi,Mika Mantyla*

Main category: cs.SE

TL;DR: This paper analyzes over 225,000 instances of self-admitted technical debt in Java repositories, finding that SATD often occurs around definitions, conditionals, and exception handling, and serves as a marker of developer awareness during complex changes, not just neglect.


<details>
  <summary>Details</summary>
Motivation: Detecting Self-Admitted Technical Debt (SATD) is essential for effective software maintenance, but prior research has largely ignored the specific code regions affected by SATD. This paper aims to bridge that gap by directly connecting SATD comments to their associated code constructs.

Method: The authors utilized the PENTACET dataset, which includes SATD-related comments from over 9000 Java open source repositories. They quantitatively analyzed where SATD occurs most frequently and which types of code constructs are most often affected by these comments.

Result: Through examining over 225,000 SATD comments, the study discovered that SATD is most frequently found in inline code adjacent to definitions, conditional statements, and exception handling sections. These are areas where developers experience uncertainty and must make trade-offs.

Conclusion: SATD comments primarily signal developers' awareness and intentional communication around uncertain or complex code changes, rather than simply reflecting carelessness or neglect. The study deepens understanding of where and why SATD surfaces in code, informing better maintenance practices.

Abstract: Context. Detecting Self-Admitted Technical Debt (SATD) is crucial for
proactive software maintenance. Previous research has primarily targeted
detecting and prioritizing SATD, with little focus on the source code afflicted
with SATD. Our goal in this work is to connect the SATD comments with source
code constructs that surround them.
  Method. We leverage the extensive SATD dataset PENTACET, containing code
comments from over 9000 Java Open Source Software (OSS) repositories. We
quantitatively infer where SATD most commonly occurs and which code
constructs/statements it most frequently affects.
  Results and Conclusions. Our large-scale study links over 225,000 SATD
comments to their surrounding code, showing that SATD mainly arises in inline
code near definitions, conditionals, and exception handling, where developers
face uncertainty and trade-offs, revealing it as an intentional signal of
awareness during change rather than mere neglect.

</details>


### [12] [A Big Step Forward? A User-Centric Examination of iOS App Privacy Report and Enhancements](https://arxiv.org/abs/2511.00467)
*Liu Wang,Dong Wang,Shidong Pan,Zheng Jiang,Haoyu Wang,Yi Wang*

Main category: cs.SE

TL;DR: Apple's App Privacy Report aims to improve app data transparency but falls short in user clarity and practical impact. The paper identifies shortcomings and proposes new technical enhancements, demonstrating their effectiveness in helping users better understand how apps access and use their data.


<details>
  <summary>Details</summary>
Motivation: The massive use of mobile apps makes understanding their data practices crucial. Apple's App Privacy Report aims to increase transparency and user control, but its real-world impact and limitations are not yet fully understood.

Method: The study involved a systematic assessment of the App Privacy Report, the synthesis of LLM-enabled and multi-technique enhancements, and comprehensive evaluations from both system and user perspectives, including a structured focus group study with twelve iOS users.

Result: The focus group highlighted limited practical impact of the App Privacy Report due to missing details, particularly around data access purpose and domain description. The researchers developed enhancements—a purpose inference framework and domain clarification pipeline—and showed these improvements benefit users.

Conclusion: The App Privacy Report in its current form has limited effectiveness for informing users about app data practices. The proposed enhancements improve clarity and user understanding, offering practical insights to refine privacy mechanisms and guide future research.

Abstract: The prevalent engagement with mobile apps underscores the importance of
understanding their data practices. Transparency plays a crucial role in this
context, ensuring users to be informed and give consent before any data access
occurs. Apple introduced a new feature since iOS 15.2, App Privacy Report, to
inform users about detailed insights into apps' data access and sharing. This
feature continues Apple's trend of privacy-focused innovations (following
Privacy Nutrition Labels), and has been marketed as a big step forward in user
privacy. However, its real-world impacts on user privacy and control remain
unexamined. We thus proposed an end-to-end study involving systematic
assessment of the App Privacy Report's real-world benefits and limitations,
LLM-enabled and multi-technique synthesized enhancements, and comprehensive
evaluation from both system and user perspectives. Through a structured focus
group study with twelve everyday iOS users, we explored their experiences,
understanding, and perceptions of the feature, suggesting its limited practical
impact resulting from missing important details. We identified two primary user
concerns: the clarity of data access purpose and domain description. In
response, we proposed enhancements including a purpose inference framework and
domain clarification pipeline. We demonstrated the effectiveness and benefits
of such enhancements for mobile app users. This work provides practical
insights that could help enhance user privacy transparency and discusses areas
for future research.

</details>


### [13] [Issue-Oriented Agent-Based Framework for Automated Review Comment Generation](https://arxiv.org/abs/2511.00517)
*Shuochuan Li,Dong Wang,Patanamon Thongtanunam,Zan Wang,Jiuqiao Yu,Junjie Chen*

Main category: cs.SE

TL;DR: RevAgent is a new multi-agent framework for automated code review comments. It uses category-specific agents and a critic agent to generate more accurate, informative, and context-aware review comments than state-of-the-art methods. It outperforms others in both automatic and human assessments, especially for complex scenarios, and offers good efficiency.


<details>
  <summary>Details</summary>
Motivation: Current automated code review comment generation methods use a single model to identify multiple types of coding issues, resulting in poor handling of diverse issue categories and uninformative comments, especially in complex cases such as bug fixes.

Method: The authors propose RevAgent, an agent-based framework that decomposes the code review comment generation into three stages: (1) multiple issue-specific agents generate candidate comments from distinct perspectives, (2) a critic agent selects the most suitable comment, and (3) agents are fine-tuned on category-specific datasets for specialization.

Result: RevAgent surpasses leading PLM and LLM baselines with notable improvements across four key metrics (BLEU, ROUGE-L, METEOR, SBERT). It provides higher accuracy for issue-category identification, particularly in complex scenarios, and human evaluations confirm its practical utility and readability of comments. RevAgent balances performance and efficiency well.

Conclusion: RevAgent, with its issue-oriented multi-agent design, effectively enhances automated code review comment generation in terms of quality, relevance, and efficiency, outperforming existing single-model approaches.

Abstract: Code review (CR) is a crucial practice for ensuring software quality. Various
automated review comment generation techniques have been proposed to streamline
the labor-intensive process. However, existing approaches heavily rely on a
single model to identify various issues within the code, limiting the model's
ability to handle the diverse, issue-specific nature of code changes and
leading to non-informative comments, especially in complex scenarios such as
bug fixes. To address these limitations, we propose RevAgent, a novel
agent-based issue-oriented framework, decomposes the task into three stages:
(1) Generation Stage, where five category-specific commentator agents analyze
code changes from distinct issue perspectives and generate candidate comments;
(2) Discrimination Stage, where a critic agent selects the most appropriate
issue-comment pair; and (3) Training Stage, where all agents are fine-tuned on
curated, category-specific data to enhance task specialization. Evaluation
results show that RevAgent significantly outperforms state-of-the-art PLM- and
LLM-based baselines, with improvements of 12.90\%, 10.87\%, 6.32\%, and 8.57\%
on BLEU, ROUGE-L, METEOR, and SBERT, respectively. It also achieves relatively
higher accuracy in issue-category identification, particularly for challenging
scenarios. Human evaluations further validate the practicality of RevAgent in
generating accurate, readable, and context-aware review comments. Moreover,
RevAgent delivers a favorable trade-off between performance and efficiency.

</details>


### [14] [HIP-LLM: A Hierarchical Imprecise Probability Approach to Reliability Assessment of Large Language Models](https://arxiv.org/abs/2511.00527)
*Robab Aghazadeh-Chakherlou,Qing Guo,Siddartha Khastgir,Peter Popov,Xiaoge Zhang,Xingyu Zhao*

Main category: cs.SE

TL;DR: HIP-LLM proposes a hierarchical imprecise probability framework to better assess LLM reliability in real-world use, outperforming standard benchmark approaches and offering a public implementation.


<details>
  <summary>Details</summary>
Motivation: Traditional benchmark methods for evaluating LLMs only yield descriptive accuracy metrics, lacking probabilistic characterization of reliability under real-world operational profiles. There is a need for rigorous reliability assessment methods for practical deployment.

Method: The paper develops HIP-LLM, a Hierarchical Imprecise Probability model that represents reliability through hierarchical subdomain dependencies, incorporates imprecise priors for epistemic uncertainty, and Operational Profiles to model actual usage contexts. It performs multi-level inference and derives posterior reliability envelopes.

Result: Experiments on multiple benchmark datasets show HIP-LLM delivers improved reliability estimation and standardization compared with existing techniques. The framework, along with code, is made publicly available.

Conclusion: HIP-LLM framework provides more accurate and standardized reliability assessment for LLMs compared to existing benchmark-based and state-of-the-art methods.

Abstract: Large Language Models (LLMs) are increasingly deployed across diverse
domains, raising the need for rigorous reliability assessment methods. Existing
benchmark-based evaluations primarily offer descriptive statistics of model
accuracy over datasets, providing limited insight into the probabilistic
behavior of LLMs under real operational conditions. This paper introduces
HIP-LLM, a Hierarchical Imprecise Probability framework for modeling and
inferring LLM reliability. Building upon the foundations of software
reliability engineering, HIP-LLM defines LLM reliability as the probability of
failure-free operation over a specified number of future tasks under a given
Operational Profile (OP). HIP-LLM represents dependencies across (sub-)domains
hierarchically, enabling multi-level inference from subdomain to system-level
reliability. HIP-LLM embeds imprecise priors to capture epistemic uncertainty
and incorporates OPs to reflect usage contexts. It derives posterior
reliability envelopes that quantify uncertainty across priors and data.
Experiments on multiple benchmark datasets demonstrate that HIP-LLM offers a
more accurate and standardized reliability characterization than existing
benchmark and state-of-the-art approaches. A publicly accessible repository of
HIP-LLM is provided.

</details>


### [15] [Employee Performance when Implementing Agile Practices in an IT Workforce](https://arxiv.org/abs/2511.00528)
*Muhammad Hamid Raza Mookadam,Ridewaan Hanslo*

Main category: cs.SE

TL;DR: This study finds that agile practices generally boost employee performance in South African IT, especially in teamwork, planning, and well-being, but overcoming adoption and cultural challenges is essential for maximizing results.


<details>
  <summary>Details</summary>
Motivation: Agile methodologies are widely adopted globally in IT, but there is little research on how they affect employee performance specifically in the African, and more precisely, South African IT context. Existing studies do not comprehensively address local factors or challenges.

Method: The study utilizes an interpretivist mono-method qualitative approach. Researchers conducted seventeen semi-structured interviews with agile practitioners from diverse roles in the South African IT sector to gather in-depth insights.

Result: Agile practices significantly influence employee performance, particularly in improving planning, communication, employee development, well-being, collaboration, team culture, and progress. Despite these positives, challenges such as adoption issues, team engagement difficulties, leadership gaps, and resistance to the agile mindset impede effectiveness. Addressing these obstacles and increasing support for employees could further enhance performance outcomes.

Conclusion: Agile practices have a substantial positive impact on employee performance in South Africa’s IT workforce. However, to fully realize the benefits, issues related to implementation and employee support must be tackled.

Abstract: Adoption of agile practices has increased in IT workforces. However, there is
a lack of comprehensive studies in the African context on employee performance
when implementing agile practices. This study addresses this gap by exploring
employee performance in agile environments for IT workforces in South Africa.
An interpretivist mono-method qualitative approach was used, with the use of
interviews as a research strategy. Seventeen semi-structured interviews were
conducted with agile practitioners from various roles. Our results indicated
that agile practices influence employee performance significantly, with
participants reporting on aspects which included planning, communication,
employee development and well-being, collaboration, team culture and progress.
Additionally, our results reported obstacles when using agile practices that
included adoption, team engagement, leadership and instilling an agile mindset.
Agile practices influence employee performance in IT workforces by fostering
improved team dynamics, enhanced collaboration, improved efficiencies, risk
management, planning, continuous improvement, learning, personal development
and well-being. Conclusively, our findings suggest that if agile challenges are
addressed and additional support is provided, employee performance can be
significantly improved.

</details>


### [16] [GDPR-Bench-Android: A Benchmark for Evaluating Automated GDPR Compliance Detection in Android](https://arxiv.org/abs/2511.00619)
*Huaijin Ran,Haoyi Zhang,Xunzhu Tang*

Main category: cs.SE

TL;DR: The paper introduces GDPR-Bench-Android, a large annotated dataset for benchmarking GDPR violation detection methods in Android apps. It evaluates 11 automated approaches, finding that performance varies by task and method—no single method dominates. The work provides key insights and resources for progressing automated GDPR compliance detection.


<details>
  <summary>Details</summary>
Motivation: Detecting violations of the EU GDPR in software source code is important for data protection but lacks comprehensive automated tools and benchmarks, especially for Android applications.

Method: The authors present GDPR-Bench-Android, a dataset with 1951 manually annotated violation instances from 15 open-source repositories, mapped to 23 GDPR articles. They offer granular annotations (file, module, line) and propose two evaluation tasks: violation localization (Accuracy@k metric) and snippet-level multi-label classification (macro-F1 and precision metrics). Eleven methods are benchmarked, including eight LLMs, a Formal-AST baseline, a RAG method, and an agentic ReAct method.

Result: No single approach excels at all tasks. ReAct agent is best at file-level localization, Qwen2.5-72B is best at line-level, while Formal-AST's performance is low. For multi-label classification, Claude-Sonnet-4.5 leads on Macro-F1 and RAG on Macro-Precision. Results show that different methods have specific strengths depending on the task.

Conclusion: GDPR-Bench-Android enables thorough, fair benchmarking of automated GDPR detection methods, revealing clear task-dependent strengths and weaknesses. This resource is essential for guiding further research and development for GDPR compliance automation in Android apps.

Abstract: Automating the detection of EU General Data Protection Regulation (GDPR)
violations in source code is a critical but underexplored challenge. We
introduce \textbf{GDPR-Bench-Android}, the first comprehensive benchmark for
evaluating diverse automated methods for GDPR compliance detection in Android
applications. It contains \textbf{1951} manually annotated violation instances
from \textbf{15} open-source repositories, covering 23 GDPR articles at file-,
module-, and line-level granularities. To enable a multi-paradigm evaluation,
we contribute \textbf{Formal-AST}, a novel, source-code-native formal method
that serves as a deterministic baseline. We define two tasks: (1)
\emph{multi-granularity violation localization}, evaluated via
Accuracy@\textit{k}; and (2) \emph{snippet-level multi-label classification},
assessed by macro-F1 and other classification metrics. We benchmark 11 methods,
including eight state-of-the-art LLMs, our Formal-AST analyzer, a
retrieval-augmented (RAG) method, and an agentic (ReAct) method. Our findings
reveal that no single paradigm excels across all tasks. For Task 1, the ReAct
agent achieves the highest file-level Accuracy@1 (17.38%), while the
Qwen2.5-72B LLM leads at the line level (61.60%), in stark contrast to the
Formal-AST method's 1.86%. For the difficult multi-label Task 2, the
Claude-Sonnet-4.5 LLM achieves the best Macro-F1 (5.75%), while the RAG method
yields the highest Macro-Precision (7.10%). These results highlight the
task-dependent strengths of different automated approaches and underscore the
value of our benchmark in diagnosing their capabilities. All resources are
available at: https://github.com/Haoyi-Zhang/GDPR-Bench-Android.

</details>


### [17] [Can Large Language Models Detect Real-World Android Software Compliance Violations?](https://arxiv.org/abs/2511.00624)
*Haoyi Zhang,Huaijin Ran,Xunzhu Tang*

Main category: cs.SE

TL;DR: CompliBench is a new evaluation benchmark for detecting compliance violations in Android apps using LLMs, featuring tailored tasks and metrics for regulatory requirements. Testing with top models shows it improves assessment accuracy, paving the way for smarter compliance tools.


<details>
  <summary>Details</summary>
Motivation: Existing Large Language Models (LLMs) have shown promise in software engineering tasks but struggle with detecting compliance violations in Android apps across different legal frameworks, necessitating better evaluation tools.

Method: CompliBench is introduced as a novel evaluation framework to assess LLMs on compliance violation detection. It defines two tasks: one focused on retrieval and localization of problematic code, and another on multi-label judgment for legal implications. New composite metrics are introduced to evaluate cross-granularity stability and jurisdictional consistency.

Result: Through experiments with six models (including GPT-4O and Claude-3.5), CompliBench was shown to improve compliance detection. Claude-3.5-sonnet-20241022 achieved the best performance, highlighting the effectiveness of the framework.

Conclusion: CompliBench offers a more thorough method for evaluating LLMs in compliance tasks, addressing gaps in current metrics and providing a foundation for future improvements in data protection compliance tools.

Abstract: The rapid development of Large Language Models (LLMs) has transformed
software engineering, showing promise in tasks like code generation, bug
detection, and compliance checking. However, current models struggle to detect
compliance violations in Android applications across diverse legal frameworks.
We propose \emph{CompliBench}, a novel evaluation framework for assessing LLMs'
ability to detect compliance violations under regulations like LGPD, PDPA, and
PIPEDA. The framework defines two tasks: Task 1 evaluates \emph{retrieval and
localization} at file, module, and line granularities, and Task 2 assesses
\emph{multi-label judgment} for code snippets. These tasks mirror the audit
process, where auditors locate problematic code and determine implicated
provisions. Traditional metrics fail to capture important aspects like
cross-granularity stability and jurisdictional consistency. Thus, we introduce
stability-aware composites (SGS, RCS, CRGS, and OCS) for a more comprehensive
assessment. Experiments with six models, including GPT-4O and Claude-3.5, show
\emph{CompliBench} improves compliance detection, with
Claude-3.5-sonnet-20241022 achieving the highest OCS score (0.3295), and
Gemini-2.5-pro the lowest (0.0538). This work demonstrates \emph{CompliBench}'s
potential for improving LLM performance in compliance tasks and provides a
foundation for future tools aligned with data protection standards. Our project
is available at https://github.com/Haoyi-Zhang/CompliBench.

</details>


### [18] [Lessons Learned from the Use of Generative AI in Engineering and Quality Assurance of a WEB System for Healthcare](https://arxiv.org/abs/2511.00658)
*Guilherme H. Travassos,Sabrina Rocha,Rodrigo Feitosa,Felipe Assis,Patricia Goncalves,Andre Gheventer,Larissa Galeno,Arthur Sasse,Julio Cesar Guimaraes,Carlos Brito,Joao Pedro Wieland*

Main category: cs.SE

TL;DR: Generative AI is being explored in software development for clinical trials; although results are not yet definitive due to technological immaturity and ongoing research, the team's insights and documented learning journey offer practical suggestions for organizations aiming to enhance software quality with generative AI.


<details>
  <summary>Details</summary>
Motivation: Generative AI technologies are rapidly evolving and impacting various work activities, including software engineering. The potential to enhance productivity and quality in software development motivates the exploration of its application, despite limited conclusive research and technological maturity.

Method: The authors incorporated generative AI technologies in the development process of a web-based software system intended for clinical trials. They documented an experience report covering the team's learning journey, focusing on project management, requirements specification, design, development, and quality assurance.

Result: There is no definitive technological evidence yet of significant process evolution, but the team's experiences yielded useful results and insights. These suggestions and results may benefit other software organizations looking to innovate their practices with generative AI to improve software quality.

Conclusion: While the use of generative AI in software engineering, especially in clinical trial systems, is still immature and lacks conclusive evidence for substantial improvement, early experiences and observations provide valuable guidance for other organizations seeking to innovate.

Abstract: The advances and availability of technologies involving Generative Artificial
Intelligence (AI) are evolving clearly and explicitly, driving immediate
changes in various work activities. Software Engineering (SE) is no exception
and stands to benefit from these new technologies, enhancing productivity and
quality in its software development processes. However, although the use of
Generative AI in SE practices is still in its early stages, considering the
lack of conclusive results from ongoing research and the limited technological
maturity, we have chosen to incorporate these technologies in the development
of a web-based software system to be used in clinical trials by a thoracic
diseases research group at our university. For this reason, we decided to share
this experience report documenting our development team's learning journey in
using Generative AI during the software development process. Project
management, requirements specification, design, development, and quality
assurance activities form the scope of observation. Although we do not yet have
definitive technological evidence to evolve our development process
significantly, the results obtained and the suggestions shared here represent
valuable insights for software organizations seeking to innovate their
development practices to achieve software quality with generative AI.

</details>


### [19] [Repairing Responsive Layout Failures Using Retrieval Augmented Generation](https://arxiv.org/abs/2511.00678)
*Tasmia Zerin,Moumita Asad,B. M. Mainul Hossain,Kazi Sakib*

Main category: cs.SE

TL;DR: Responsive layout failures (RLFs) in websites are difficult to fix manually. This paper proposes an automated repair approach (ReDeFix) that uses LLMs and Stack Overflow expertise to guide CSS repairs, achieving 88% accuracy and producing visually pleasing results.


<details>
  <summary>Details</summary>
Motivation: Responsive websites often suffer from distorted layouts on certain screen sizes, called Responsive Layout Failures (RLFs), and current manual repair methods are tedious and inefficient.

Method: The paper introduces ReDeFix, a Retrieval-Augmented Generation (RAG) approach that uses Large Language Models (LLMs) and incorporates relevant domain-specific knowledge from Stack Overflow discussions to generate prompts for automated CSS repairs.

Result: ReDeFix achieves 88% accuracy in repairing RLFs. The study also finds that the generated CSS patches result in visually correct layouts that preserve aesthetic quality, as confirmed by software engineers.

Conclusion: ReDeFix efficiently automates the repair of responsive layout failures using LLMs and crowdsourced CSS knowledge, providing accurate and aesthetically pleasing fixes with high reliability.

Abstract: Responsive websites frequently experience distorted layouts at specific
screen sizes, called Responsive Layout Failures (RLFs). Manually repairing
these RLFs involves tedious trial-and-error adjustments of HTML elements and
CSS properties. In this study, an automated repair approach, leveraging LLM
combined with domain-specific knowledge is proposed. The approach is named
ReDeFix, a Retrieval-Augmented Generation (RAG)-based solution that utilizes
Stack Overflow (SO) discussions to guide LLM on CSS repairs. By augmenting
relevant SO knowledge with RLF-specific contexts, ReDeFix creates a prompt that
is sent to the LLM to generate CSS patches. Evaluation demonstrates that our
approach achieves an 88\% accuracy in repairing RLFs. Furthermore, a study from
software engineers reveals that generated repairs produce visually correct
layouts while maintaining aesthetics.

</details>


### [20] [An Empirical Investigation of the Experiences of Dyslexic Software Engineers](https://arxiv.org/abs/2511.00706)
*Marcos Vinicius Cruz,Pragya Verma,Grischa Liebel*

Main category: cs.SE

TL;DR: Dyslexic software engineers face initial learning challenges in programming, but excel at SE tasks once they overcome these. They benefit from SE support tools and display strengths in creativity and visual thinking. Future research should focus on improving code accessibility for dyslexic professionals.


<details>
  <summary>Details</summary>
Motivation: There is little research on the experiences of dyslexic software engineers and how their strengths and difficulties interact in software engineering tasks. The study aims to fill this gap.

Method: A qualitative study using the Socio-Technical Grounded Theory method. Data were collected from 10 interviews with dyslexic software engineers, 3 blog posts, and 153 Reddit posts.

Result: Dyslexic software engineers mainly struggle at the programming learning stage, but are able to succeed and excel at many tasks once past this hurdle. Support tools like code completion and linters are especially helpful. Dyslexic individuals show strengths in visual thinking and creativity.

Conclusion: Dyslexic software engineers experience unique challenges mainly during learning, but possess valuable strengths that aid success in SE. Support tools mitigate difficulties, and further research into code understandability for dyslexic individuals is needed.

Abstract: Dyslexia is a common learning disorder that primarily impairs an individual's
reading and writing abilities. In adults, dyslexia can affect both professional
and personal lives, often leading to mental challenges and difficulties
acquiring and keeping work. In Software Engineering (SE), reading and writing
difficulties appear to pose substantial challenges for core tasks such as
programming. However, initial studies indicate that these challenges may not
significantly affect their performance compared to non-dyslexic colleagues.
Conversely, strengths associated with dyslexia could be particularly valuable
in areas like programming and design. However, there is currently no work that
explores the experiences of dyslexic software engineers, and puts their
strengths into relation with their difficulties. To address this, we present a
qualitative study of the experiences of dyslexic individuals in SE. We followed
the basic stage of the Socio-Technical Grounded Theory method and base our
findings on data collected through 10 interviews with dyslexic software
engineers, 3 blog posts and 153 posts on the social media platform Reddit. We
find that dyslexic software engineers especially struggle at the programming
learning stage, but can succeed and indeed excel at many SE tasks once they
master this step. Common SE-specific support tools, such as code completion and
linters are especially useful to these individuals and mitigate many of the
experienced difficulties. Finally, dyslexic software engineers exhibit
strengths in areas such as visual thinking and creativity. Our findings have
implications to SE practice and motivate several areas of future research in
SE, such as investigating what makes code less/more understandable to dyslexic
individuals.

</details>


### [21] [A Systematic Literature Review of Code Hallucinations in LLMs: Characterization, Mitigation Methods, Challenges, and Future Directions for Reliable AI](https://arxiv.org/abs/2511.00776)
*Cuiyun Gao,Guodong Fan,Chun Yong Chong,Shizhan Chen,Chao Liu,David Lo,Zibin Zheng,Qing Liao*

Main category: cs.SE

TL;DR: This survey analyzes the causes, challenges, mitigation strategies, and evaluation methods for model hallucination in code-oriented large language models. It finds unique issues for code, reviews the latest research, and calls for better benchmarks and targeted solutions.


<details>
  <summary>Details</summary>
Motivation: Model hallucination poses severe risks in applying Large Language Models (LLMs) to code intelligence tasks, which are increasingly critical in modern software engineering. Understanding and reducing hallucinations in this domain is vital for the safe and reliable automation of coding tasks.

Method: The paper conducts a systematic survey of 60 papers, defining hallucination in code-oriented LLMs, analyzing its causes, reviewing mitigation strategies across both NLP and code domains, assessing code-specific challenges and detection methods, and summarizing current evaluation benchmarks.

Result: The survey clarifies primary causes of hallucination (e.g., data noise, exposure bias, insufficient semantic grounding), compares mitigation approaches (e.g., knowledge-enhanced generation, constrained decoding, post-editing), identifies unique challenges for code intelligence (syntax, type systems, library dependencies), discusses how tasks like program analysis help in detection and mitigation, and highlights the limitations of current evaluation benchmarks.

Conclusion: Current approaches to LLM hallucination in code are varied but not sufficient. There are unique challenges in code intelligence compared to general NLP, and more targeted mitigation strategies along with improved hallucination-specific evaluation benchmarks are needed for practical, reliable use.

Abstract: Model hallucination is one of the most critical challenges faced by Large
Language Models (LLMs), especially in high-stakes code intelligence tasks. As
LLMs become increasingly integrated into software engineering tasks,
understanding and mitigating hallucination in code becomes essential. In this
survey, we provide a systematic review of hallucination phenomena in
code-oriented LLMs from four key perspectives. First, we begin by surveying 60
papers to define hallucination in the context of code and summarize its primary
causes, such as data noise, exposure bias, and insufficient semantic grounding,
while also tracing recent trends in literature across natural language
processing (NLP) and software engineering communities. Second, we review model
hallucination surveys in a broader span and summarize representative
hallucination mitigation strategies, such as knowledge-enhanced generation,
constrained decoding, and post-editing. Third, we review approaches targeted
for code intelligence and highlight code-specific challenges that aggravate
hallucination, including syntax sensitivity, strict type systems, and
dependence on external libraries. Meanwhile, we analyze how emerging code
intelligence tasks, e.g., program analysis, symbolic execution, and unit
testing, are utilized to detect and mitigate hallucinations. Fourth, we
summarize current evaluation benchmarks, ranging from static metrics to dynamic
checks, e.g., compilation and execution correctness, and emphasize the need for
hallucination-oriented benchmarks.

</details>


### [22] [Can Language Models Go Beyond Coding? Assessing the Capability of Language Models to Build Real-World Systems](https://arxiv.org/abs/2511.00780)
*Chenyu Zhao,Shenglin Zhang,Zeshun Huang,Weilin Jin,Yongqian Sun,Dan Pei,Chaoyun Zhang,Qingwei Lin,Chetan Bansal,Saravan Rajmohan,Minghua Ma*

Main category: cs.SE

TL;DR: Build-bench is a new benchmark to test how well LLMs fix build failures during software migration across CPU architectures. Studying 268 real failed builds, the tool finds current LLMs have a top 63% success rate, and provides the first systematic way to evaluate and improve LLM-assisted software repair in complex, real-world scenarios.


<details>
  <summary>Details</summary>
Motivation: Large language models (LLMs) are increasingly used in software engineering, but their effectiveness in repairing software during migration between different instruction set architectures (ISAs) has been underexplored. This task is complex due to dependencies, toolchains, and build verification requirements.

Method: The paper introduces Build-bench, a benchmark suite that evaluates LLMs' abilities to repair build failures caused by cross-ISA migration. It collects 268 real failed software packages and uses auxiliary tools for structure extraction, content extraction, modification, and automated build verification. The repair is modeled as an iterative process, where models receive feedback from build logs and attempts to improve repairs.

Result: When tested on six major LLMs, Build-bench finds a maximum build success rate of 63%. The study also observes significant differences in how various LLMs utilize supporting tools during the repair process.

Conclusion: Build-bench enables systematic, reproducible, architecture-aware evaluation of LLM-based repair tools in real build environments, filling a crucial gap in benchmarking LLMs for cross-ISA software migration.

Abstract: Large language models (LLMs) have shown growing potential in software
engineering, yet few benchmarks evaluate their ability to repair software
during migration across instruction set architectures (ISAs). Cross-ISA
migration, such as between x86_64 and aarch64, requires handling complex
dependencies, heterogeneous toolchains, and long build logs while ensuring
executable verification. To address this challenge, we present Build-bench, an
end-to-end benchmark that systematically evaluates the capability of LLMs to
repair build failures in cross-ISA settings. Build-bench collects 268
real-world failed packages and integrates auxiliary tools including Structure
Extraction, File Content Extraction, Content Modification, and Build
Verification to support autonomous, tool-augmented reasoning. The repair
process operates in an iterative loop where, upon failure, the model receives
updated build logs and previous repair outcomes to refine subsequent attempts.
Through a comparative evaluation of six representative LLMs, Build-bench
reveals that current models achieve a maximum build success rate of 63% and
tool usage patterns differ significantly across models. By coupling real build
environments with verifiable outcomes, Build-bench establishes the first
architecture-aware benchmark for studying LLM-based software build and repair.

</details>


### [23] [GrowthHacker: Automated Off-Policy Evaluation Optimization Using Code-Modifying LLM Agents](https://arxiv.org/abs/2511.00802)
*Jie JW Wu,Ayanda Patrick Herlihy,Ahmad Saleem Mirza,Ali Afoud,Fatemeh Fard*

Main category: cs.SE

TL;DR: This paper proposes GrowthHacker, a benchmark framework that uses LLM-based agents to optimize code for off-policy evaluation. The two_agent system reliably enhances OPE performance on large datasets, outperforming baseline methods and other agent frameworks, indicating a promising future for scalable agentic optimization in data-driven industries.


<details>
  <summary>Details</summary>
Motivation: Online A/B testing, although crucial for evaluating new technologies, is resource-intensive, risks negative user impact, and requires long data collection periods. Off-policy evaluation (OPE) offers an alternative using logged data, which is especially valuable in domains where online testing is costly or risky. Leveraging advances in Large Language Models (LLMs) and agentic AI for optimizing OPE has received little attention.

Method: The authors introduce GrowthHacker, a benchmark with agent and baseline methods applied to large-scale real-world datasets. The approach involves iterative code optimization, result evaluation, and repeated improvement cycles. Protocols and baselines for OPE are established using Open Bandit Pipeline and Scope-RL datasets. The two_agent framework is developed to reduce system complexity while maintaining optimization effectiveness.

Result: The two_agent framework achieved 100% reliability and demonstrated the highest average improvement of 106.7% among positive outcomes. Both two_agent and CrewAI frameworks attained a 45% success rate, exceeding AutoGen’s 34%.

Conclusion: LLM-based agents can serve as automated 'growth hackers' to improve OPE systems efficiently, supporting scalable and more effective data-driven decision making in production environments.

Abstract: With the software industry shifting toward a data-driven culture, online A/B
testing is a key tool for evaluating new technologies. However, deploying such
experiments requires substantial resources, may negatively impact users, and
involves long data collection periods. To address this, \textit{off-policy
evaluation (OPE)}, or offline A/B testing, uses logged data to assess
technologies and is fundamental in Reinforcement Learning, making it crucial in
domains where online testing is costly or risky, such as healthcare,
recommender systems, education, dialog systems, and robotics. Despite advances
in coding LLMs and agentic AI, little is known about leveraging them to
optimize OPE results. We investigate whether LLMs and LLM-based agents can
improve OPE performance via code optimization. We propose
\textit{GrowthHacker}, a benchmark with agent and baseline methods on
large-scale real-world datasets, which iteratively optimizes code, evaluates
results, and begins new optimization cycles. We collected datasets, established
protocols, implemented baselines for OPE on the Open Bandit Pipeline
(OBP)~\cite{saito2021openbanditdatasetpipeline} and
Scope-RL~\cite{kiyohara2023scope}, and developed the \textit{two_agent}
framework, which reduces system complexity while preserving optimization
effectiveness. Results show the two_agent framework achieves 100% reliability
and the highest average improvement of 106.7% among positive outcomes. Both
two_agent and CrewAI reach 45% success rates, outperforming AutoGen's 34%.
These findings demonstrate the feasibility of LLM-based agents as automated
"growth hackers" to enhance OPE systems, with implications for scaling
data-driven decision-making in production.

</details>


### [24] [CodeClash: Benchmarking Goal-Oriented Software Engineering](https://arxiv.org/abs/2511.00839)
*John Yang,Kilian Lieret,Joyce Yang,Carlos E. Jimenez,Ofir Press,Ludwig Schmidt,Diyi Yang*

Main category: cs.SE

TL;DR: CodeClash, a new benchmark for language models, tests their ability to autonomously build codebases toward open-ended goals. Eight models competed in thousands of rounds, but all showed fundamental weaknesses in strategy and code maintenance, being consistently outperformed by expert humans. The benchmark sets the stage for better evaluation and development of autonomous coding agents.


<details>
  <summary>Details</summary>
Motivation: Existing code evaluation benchmarks for LMs focus on isolated, well-defined tasks, which does not reflect the high-level, open-ended goals of real-world software development. There is a need to assess whether LMs can autonomously and iteratively develop code toward complex objectives without explicit step-by-step guidance.

Method: The authors introduce CodeClash, a benchmark where LMs compete in multi-round tournaments to build and improve codebases with competitive objectives. Each round includes two phases: code editing and direct competition in a code arena. Models self-decide how to enhance their codebases, aiming to maximize specific objectives. The benchmark involves running 1,680 tournaments (25,200 rounds) across six competitive arenas, evaluating eight different LMs.

Result: Models demonstrated diverse approaches to code development, but exhibited significant limitations in strategic reasoning and long-term maintenance. As projects progressed, codebases generated by LMs became increasingly disorganized and redundant. Top-performing LMs consistently failed to surpass expert human programmers in every round.

Conclusion: Current language models, even at their best, are notably deficient in autonomous, goal-oriented software development tasks. They struggle particularly with strategic planning and maintaining clean codebases over time. The open-source CodeClash benchmark provides a new standard for evaluating these capabilities and exposes key areas for improvement in future LMs.

Abstract: Current benchmarks for coding evaluate language models (LMs) on concrete,
well-specified tasks such as fixing specific bugs or writing targeted tests.
However, human programmers do not spend all day incessantly addressing isolated
tasks. Instead, real-world software development is grounded in the pursuit of
high-level goals, like improving user retention or reducing costs. Evaluating
whether LMs can also iteratively develop code to better accomplish open-ended
objectives without any explicit guidance remains an open challenge. To address
this, we introduce CodeClash, a benchmark where LMs compete in multi-round
tournaments to build the best codebase for achieving a competitive objective.
Each round proceeds in two phases: agents edit their code, then their codebases
compete head-to-head in a code arena that determines winners based on
objectives like score maximization, resource acquisition, or survival. Whether
it's writing notes, scrutinizing documentation, analyzing competition logs, or
creating test suites, models must decide for themselves how to improve their
codebases both absolutely and against their opponents. We run 1680 tournaments
(25,200 rounds total) to evaluate 8 LMs across 6 arenas. Our results reveal
that while models exhibit diverse development styles, they share fundamental
limitations in strategic reasoning. Models also struggle with long-term
codebase maintenance, as repositories become progressively messy and redundant.
These limitations are stark: top models lose every round against expert human
programmers. We open-source CodeClash to advance the study of autonomous,
goal-oriented code development.

</details>


### [25] [A Comprehensive Empirical Evaluation of Agent Frameworks on Code-centric Software Engineering Tasks](https://arxiv.org/abs/2511.00872)
*Zhuowen Yin,Cuifeng Gao,Chunsong Fan,Wenzhang Yang,Yinxing Xue,Lijun Zhang*

Main category: cs.SE

TL;DR: This paper compares seven agent frameworks for software engineering tasks, revealing varied strengths in effectiveness, efficiency, and cost. No framework is best overall; trade-offs exist, informing future adoption and research.


<details>
  <summary>Details</summary>
Motivation: Traditional automation and LLM-based systems have limited scope in handling complex software engineering tasks, often focusing only on specific or isolated problem areas. There's a need for a holistic understanding of how agent frameworks perform across diverse, realistic scenarios.

Method: A comprehensive empirical study was conducted comparing seven general-purpose agent frameworks on three representative code-centric tasks: software development, vulnerability detection, and program repair. Standard benchmarks were used to ensure fair evaluation, and agent performance was analyzed from perspectives of effectiveness, efficiency, and overhead.

Result: The study identified distinct patterns and trade-offs among agents. Overall effectiveness was moderate; AgentOrchestra showed longest task trajectories and most corrections (high overhead), while OpenHands excelled in reflective reasoning. Software development was the most costly in terms of token consumption, but GPTswarm was the most cost-efficient. Detailed cross-analysis explained how effectiveness and efficiency interrelate.

Conclusion: Agents present promising, but varied, capabilities for software engineering tasks. Understanding their trade-offs in effectiveness, efficiency, and cost is crucial for both practical deployment and guiding research towards more efficient agent designs.

Abstract: Unlike traditional automation tools or static LLM-based systems, agents
combine decision-making and tool utilization to accomplish complex tasks,
showing great potential in software engineering. However, existing studies
largely focus on specific tasks or isolated aspects, providing an incomplete
picture of agents' practical capabilities. To address this, we conduct a
comprehensive empirical study evaluating seven general-purpose agent frameworks
across three representative code-centric tasks: software development,
vulnerability detection, and program repair. Each task is assessed using
standard, widely adopted benchmarks to ensure objective and comparable
evaluation. Agent performance is systematically analyzed from three
complementary perspectives: effectiveness (task success), efficiency (execution
process), and overhead (token consumption). Our findings reveal distinct
capability patterns and trade-offs among the evaluated frameworks. In terms of
effectiveness, agents achieve moderate overall performance. Regarding
efficiency, AgentOrchestra tends to exhibit the longest trajectories and the
most correction attempts due to coordination overhead, whereas OpenHands
demonstrate stronger reflective reasoning abilities. For overhead, software
development incurs the highest monetary cost, while GPTswarm remains the most
cost-efficient. Furthermore, we conduct an in-depth cross-analysis of the
relationship between effectiveness and efficiency, exploring the underlying
reasons behind their interplay. These findings guide both practical adoption
and future research toward more efficient software engineering agents.

</details>


### [26] [Sustainability of Machine Learning-Enabled Systems: The Machine Learning Practitioner's Perspective](https://arxiv.org/abs/2511.00901)
*Vincenzo De Martino,Stefano Lambiase,Fabiano Pecorelli,Willem-Jan van den Heuvel,Filomena Ferrucci,Fabio Palomba*

Main category: cs.SE

TL;DR: Software sustainability in ML systems is recognized but poorly implemented, mainly due to missing guidelines, measurement tools, and regulations. This study—via interviews and surveys—reveals practitioners understand sustainability broadly but struggle to apply it. More structure and support are needed to close the awareness-implementation gap.


<details>
  <summary>Details</summary>
Motivation: There is a growing recognition of the importance of software sustainability—including environmental, social, and economic dimensions—in ML-enabled systems, but its practical integration and management remain underexplored. Existing research mostly focuses on environmental aspects, neglecting other key sustainability concerns and real-world practitioner challenges.

Method: The authors conducted a mixed-methods empirical study, including qualitative interviews with eight experienced ML engineers and a large-scale quantitative survey of 203 ML practitioners, to explore how sustainability is perceived, described, and managed in ML workflows.

Result: The study found a significant gap between practitioners' awareness of sustainability and its practical implementation. Key challenges include the lack of structured guidelines, measurement frameworks, and regulatory support for systematically integrating sustainability into ML-enabled system development.

Conclusion: There is an urgent need for clearer guidelines, standardized measurement frameworks, and better regulatory support to bridge the gap between awareness and actionable sustainability in ML-enabled systems. Addressing these needs will help practitioners systematically integrate diverse sustainability concerns into their workflows.

Abstract: Software sustainability is a key multifaceted non-functional requirement that
encompasses environmental, social, and economic concerns, yet its integration
into the development of Machine Learning (ML)-enabled systems remains an open
challenge. While previous research has explored high-level sustainability
principles and policy recommendations, limited empirical evidence exists on how
sustainability is practically managed in ML workflows. Existing studies
predominantly focus on environmental sustainability, e.g., carbon footprint
reduction, while missing the broader spectrum of sustainability dimensions and
the challenges practitioners face in real-world settings. To address this gap,
we conduct an empirical study to characterize sustainability in ML-enabled
systems from a practitioner's perspective. We investigate (1) how ML engineers
perceive and describe sustainability, (2) the software engineering practices
they adopt to support it, and (3) the key challenges hindering its adoption. We
first perform a qualitative analysis based on interviews with eight experienced
ML engineers, followed by a large-scale quantitative survey with 203 ML
practitioners. Our key findings reveal a significant disconnection between
sustainability awareness and its systematic implementation, highlighting the
need for more structured guidelines, measurement frameworks, and regulatory
support.

</details>


### [27] [Empirical Derivations from an Evolving Test Suite](https://arxiv.org/abs/2511.00915)
*Jukka Ruohonen,Abhishek Tiwari*

Main category: cs.SE

TL;DR: This paper analyzes NetBSD's test suite over more than a decade, finding its coverage has expanded and failure rates have remained largely stable. Kernel and code changes are not strong long-term predictors of failures. The work provides exploratory insights into the management and stability of large, continuously evolving test suites.


<details>
  <summary>Details</summary>
Motivation: The motivation is to understand the effectiveness and stability of the NetBSD operating system's automated test suite over a long period. This study seeks to empirically analyze how test coverage and failure rates evolve in a large-scale, continuously growing software test suite.

Method: The paper uses a longitudinal empirical analysis, examining test suite records and results from the early 2010s to late 2025. It analyzes the frequency and nature of test case failures, build failures, installation failures, and relates these to code churn and kernel modifications.

Result: The test suite has grown to cover over ten thousand test cases. The frequency and numbers of failed test cases, build failures, installation failures, and test suite completion issues are generally stable, with some shorter periods of increased failures. Code churn and kernel modifications are not consistent predictors of failures, though spikes are observed at times.

Conclusion: On average, kernel and code changes do not have a substantial long-term impact on test suite failures. The empirical findings enhance the understanding of evolving, large-scale test suites, though the analysis is mainly exploratory.

Abstract: The paper presents a longitudinal empirical analysis of the automated,
continuous, and virtualization-based software test suite of the NetBSD
operating system. The longitudinal period observed spans from the initial roll
out of the test suite in the early 2010s to late 2025. According to the
results, the test suite has grown continuously, currently covering over ten
thousand individual test cases. Failed test cases exhibit overall stability,
although there have been shorter periods marked with more frequent failures. A
similar observation applies to build failures, failures of the test suite to
complete, and installation failures, all of which are also captured by the
NetBSD's testing framework. Finally, code churn and kernel modifications do not
provide longitudinally consistent statistical explanations for the failures.
Although some periods exhibit larger effects, including particularly with
respect to the kernel modifications, the effects are small on average. Even
though only in an exploratory manner, these empirical observations contribute
to efforts to draw conclusions from large-scale and evolving software test
suites.

</details>


### [28] [DPO-F+: Aligning Code Repair Feedback with Developers' Preferences](https://arxiv.org/abs/2511.01043)
*Zihan Fang,Yifan Zhang,Yueke Zhang,Kevin Leach,Yu Huang*

Main category: cs.SE

TL;DR: DPO-f+ framework makes code-repair feedback from LLMs more understandable and helpful for developers, leading to improved accuracy and collaboration compared to previous methods.


<details>
  <summary>Details</summary>
Motivation: Current LLM-based code repair tools do not adequately support developers in interpreting model outputs, particularly in terms of natural-language feedback needed for iterative improvement and comprehension.

Method: The paper introduces DPO-f+, which formalizes developer-profiled, domain-specific metrics for feedback; auto-generates preference datasets from code-repair tasks; fine-tunes LLMs using Direct Preference Optimization with a margin signal; and includes an automated feedback evaluation protocol.

Result: Empirical evaluation shows DPO-f+ boosts top-1 pass rates and feedback alignment, outperforming baseline and standard DPO approaches on both novice and complex software engineering tasks.

Conclusion: DPO-f+ significantly improves code-repair accuracy and the alignment of model feedback with developer needs, resulting in better code comprehension and enhanced human-AI collaboration.

Abstract: Large Language Models (LLMs) are increasingly applied to software engineering
tasks, especially code repair. However, developers often struggle to interpret
model outputs, limiting effective human-AI teaming. Prior work largely
optimizes repaired code while under-addressing the natural-language feedback
that enables comprehension and iterative improvement. We present DPO-f+, a
novel framework that aligns code-repair feedback with developer needs and
profiles. It (1) formalizes developer-profiled, domain-specific metrics for
feedback alignment; (2) automatically constructs pairwise preference datasets
from code-repair tasks; (3) fine-tunes using Direct Preference Optimization
(DPO) augmented with a lightweight margin signal; and (4) provides an automated
feedback evaluation protocol. Empirically, DPO-f+ outperforms both the baseline
and standard DPO on generated-code accuracy and overall feedback alignment. On
novice programming tasks, DPO-f+ raises the top-1 pass rate by 5.71 percentage
points (pp) over the baseline and by 3.30 pp over DPO. On the more challenging
SWE-bench Lite benchmark, it increases the issue-resolution rate by 1.67 pp
over DPO and by 4.67 pp over the baseline. It also achieves the largest
improvement in feedback alignment, outperforming DPO and the baseline. By
aligning feedback more closely with developer needs, DPO-f+ turns LLM-assisted
repair from one-shot outputs into a collaborative sensemaking workflow,
providing a practical approach to enhancing code comprehension and fostering
more effective human-AI teaming in software engineering.

</details>


### [29] [HAFixAgent: History-Aware Automated Program Repair Agent](https://arxiv.org/abs/2511.01047)
*Yu Shi,Hao Li,Bram Adams,Ahmed E. Hassan*

Main category: cs.SE

TL;DR: HAFixAgent, a history-aware automated repair agent, uses repository history to fix bugs more effectively and efficiently than current methods, with especially strong results on complex bugs by integrating blame-derived heuristics.


<details>
  <summary>Details</summary>
Motivation: Most current automated program repair systems using large language models and agents ignore repository history, even though prior work shows it is useful for fixing single-line bugs.

Method: The authors design HAFixAgent, a history-aware bug-fixing agent that incorporates repository 'blame' information and heuristics derived from version control history into its agentic repair loop. They analyze 854 bugs from Defects4J to justify their approach and empirically compare their agent with two state-of-the-art baselines.

Result: HAFixAgent outperforms agent-based and multi-hunk baselines, improving repair effectiveness by 212.3% and 29.9%, respectively. It achieves these gains without significant increases in agent repair steps or token costs, and even lowers costs for complex bug cases. Combining different historical heuristics repairs more bugs.

Conclusion: Integrating repository history, specifically blame-derived heuristics, into agent-based APR systems significantly improves both effectiveness and practicality, particularly for complex bugs. The approach is efficient and cost-effective, providing clear guidance on leveraging version control history in automated repairs.

Abstract: Automated program repair (APR) has recently shifted toward large language
models and agent-based systems, yet most systems rely on local snapshot
context, overlooking repository history. Prior work shows that repository
history helps repair single-line bugs, since the last commit touching the buggy
line is often the bug-introducing one. In this paper, we investigate whether
repository history can also improve agentic APR systems at scale, especially
for complex multi-hunk bugs. We present HAFixAgent, a History-Aware Bug-Fixing
Agent that injects blame-derived repository heuristics into its repair loop. A
preliminary study of all 854 real-world bugs from Defects4J motivates our
design, showing that bug-relevant history is both widely available and highly
concentrated. Empirical comparison of HAFixAgent with two state-of-the-art
baselines shows: (1) Effectiveness: HAFixAgent significantly improves over the
agent-based baseline (by 212.3%) and the multi-hunk baseline (by 29.9%). (2)
Efficiency: history does not significantly increase agent steps and keeps token
costs comparable, with notably lower median costs for complex
multi-file-multi-hunk bugs. (3) Practicality: combining different historical
heuristics repairs more bugs, offering a clear cost-benefit trade-off.
HAFixAgent offers a practical recipe for history-aware agentic APR: ground the
agent in version control history, prioritize diff-based historical context, and
integrate complementary heuristics when needed.

</details>


### [30] [HarnessLLM: Automatic Testing Harness Generation via Reinforcement Learning](https://arxiv.org/abs/2511.01104)
*Yujian Liu,Jiabao Ji,Yang Zhang,Wenbo Guo,Tommi Jaakkola,Shiyu Chang*

Main category: cs.SE

TL;DR: HarnessLLM overcomes limitations in existing LLM-based test generation by training LLMs to create harness code for more diverse and effective testing, leading to better bug finding and code generation.


<details>
  <summary>Details</summary>
Motivation: Existing LLM-based automatic test generation primarily focuses on generating input-output pairs, which limits test diversity and debugging capabilities.

Method: HarnessLLM introduces a two-stage training pipeline for LLMs: first using supervised fine-tuning (SFT), then Reinforcement Learning with Validation Rewards (RLVR) and customized reward design. This enables LLMs to generate harness code that synthesizes inputs and validates outputs, supporting complex test cases and flexible validation methods like invariant checking.

Result: HarnessLLM produces more diverse and effective test cases, finds more bugs, and improves code generation performance by using generated test cases for inference-phase validation. It outperforms traditional input-output-based testing methods in both bug finding and testing strategy diversity.

Conclusion: HarnessLLM advances LLM-based automatic test generation by enabling harness code generation, improving debugging support, test diversity, and code generation accuracy.

Abstract: Existing LLM-based automatic test generation methods mainly produce input and
expected output pairs to categorize the intended behavior of correct programs.
Although straightforward, these methods have limited diversity in generated
tests and cannot provide enough debugging information. We propose HarnessLLM, a
two-stage training pipeline that enables LLMs to write harness code for
testing. Particularly, LLMs generate code that synthesizes inputs and validates
the observed outputs, allowing complex test cases and flexible output
validation such as invariant checking. To achieve this, we train LLMs with SFT
followed by RLVR with a customized reward design. Experiments show that
HarnessLLM outperforms input-output-based testing in bug finding and testing
strategy diversity. HarnessLLM further benefits the code generation performance
through test-time scaling with our generated test cases as inference-phase
validation. Our code is available at
https://github.com/UCSB-NLP-Chang/HarnessLLM.git.

</details>


### [31] [An Empirical Study of LLM-Based Code Clone Detection](https://arxiv.org/abs/2511.01176)
*Wenqing Zhu,Norihiro Yoshida,Eunjong Choi,Yutaka Matsubara,Hiroaki Takada*

Main category: cs.SE

TL;DR: LLMs are reliable and consistent for code clone detection in some datasets, but their effectiveness varies with dataset differences, particularly struggling on BigCloneBench compared to CodeNet.


<details>
  <summary>Details</summary>
Motivation: Despite the effectiveness of large language models (LLMs) in code clone detection, their performance consistency across different datasets and the reliability of their responses remain unexplored.

Method: The authors constructed seven code clone datasets by sampling code pairs using the Levenshtein ratio from two code collections, CodeNet and BigCloneBench, and evaluated five LLMs using four established prompts.

Result: LLMs performed well on CodeNet datasets (with o3-mini reaching 0.943 F1 score) but saw significant performance drops on BigCloneBench datasets. Most models exhibited high response consistency (over 90%), with minor F1 score variation (< 0.03) due to inconsistency.

Conclusion: LLMs show strong code clone detection performance and consistent responses on certain datasets (like CodeNet), but performance does not generalize across all datasets, specifically declining on BigCloneBench.

Abstract: Large language models (LLMs) have demonstrated remarkable capabilities in
various software engineering tasks, such as code generation and debugging,
because of their ability to translate between programming languages and natural
languages. Existing studies have demonstrated the effectiveness of LLMs in code
clone detection. However, two crucial issues remain unaddressed: the ability of
LLMs to achieve comparable performance across different datasets and the
consistency of LLMs' responses in code clone detection. To address these
issues, we constructed seven code clone datasets and then evaluated five LLMs
in four existing prompts with these datasets. The datasets were created by
sampling code pairs using their Levenshtein ratio from two different code
collections, CodeNet and BigCloneBench. Our evaluation revealed that although
LLMs perform well in CodeNet-related datasets, with o3-mini achieving a 0.943
F1 score, their performance significantly decreased in BigCloneBench-related
datasets. Most models achieved a high response consistency, with over 90\% of
judgments remaining consistent across all five submissions. The fluctuations of
the F1 score affected by inconsistency are also tiny; their variations are less
than 0.03.

</details>


### [32] [Lares: LLM-driven Code Slice Semantic Search for Patch Presence Testing](https://arxiv.org/abs/2511.01252)
*Siyuan Li,Yaowen Zheng,Hong Li,Jingdong Guo,Chaopeng Dong,Chunpeng Yan,Weijie Wang,Yimo Ren,Limin Sun,Hongsong Zhu*

Main category: cs.SE

TL;DR: Lares introduces an LLM- and SMT-driven method to accurately and scalably detect patch presence in binaries, outperforming previous approaches and bypassing the need for compilation-derived features.


<details>
  <summary>Details</summary>
Motivation: 1-day vulnerabilities remain a significant risk due to widespread code reuse. Simply detecting vulnerable functions in binaries isn't sufficient; it's essential to know if these vulnerabilities are patched. Existing solutions are inaccurate, labor-intensive, and often depend on the compilation process, which isn't always feasible or reliable.

Method: Lares is proposed: a method that extracts features directly from patch source code and finds semantically equivalent code in the pseudocode of the target binary, skipping the compilation dependency. It utilizes large language models (LLMs) for code analysis and SMT solvers for logical reasoning.

Result: Lares demonstrates higher precision, recall, and usability compared to prior methods, and is the first to validate its effectiveness across different architectures, optimization levels, and compilers.

Conclusion: Lares offers a scalable, accurate, and practical solution for patch presence testing in binaries without relying on the compilation process, significantly improving upon previous techniques.

Abstract: In modern software ecosystems, 1-day vulnerabilities pose significant
security risks due to extensive code reuse. Identifying vulnerable functions in
target binaries alone is insufficient; it is also crucial to determine whether
these functions have been patched. Existing methods, however, suffer from
limited usability and accuracy. They often depend on the compilation process to
extract features, requiring substantial manual effort and failing for certain
software. Moreover, they cannot reliably differentiate between code changes
caused by patches or compilation variations. To overcome these limitations, we
propose Lares, a scalable and accurate method for patch presence testing. Lares
introduces Code Slice Semantic Search, which directly extracts features from
the patch source code and identifies semantically equivalent code slices in the
pseudocode of the target binary. By eliminating the need for the compilation
process, Lares improves usability, while leveraging large language models
(LLMs) for code analysis and SMT solvers for logical reasoning to enhance
accuracy. Experimental results show that Lares achieves superior precision,
recall, and usability. Furthermore, it is the first work to evaluate patch
presence testing across optimization levels, architectures, and compilers. The
datasets and source code used in this article are available at
https://github.com/Siyuan-Li201/Lares.

</details>


### [33] [Exploringand Unleashing the Power of Large Language Models in CI/CD Configuration Translation](https://arxiv.org/abs/2511.01316)
*Chong Wang,Chen Zhang,Jiajun Wu,Wunan Guo,Jianfeng Qu,Yewen Tian,Yang Liu*

Main category: cs.SE

TL;DR: Migrating CI configurations between platforms like Travis CI and GitHub Actions is common but complex. LLMs can help but make many mistakes. Combining guidelines and iterative refinement boosts success rates significantly, demonstrating a practical way to automate and improve CI migration.


<details>
  <summary>Details</summary>
Motivation: Migrating CI configurations between different platforms (e.g., Travis CI to GitHub Actions) is a complex and frequent necessity due to platform differences. This process is challenging because of semantic differences, configuration complexity, and the need to minimize developer effort.

Method: The study analyzes actual migration records (811 cases) to quantify effort, then systematically evaluates translations produced by four different large language models (LLMs). They categorize 1,121 issues found in these translations, and test three enhancement strategies to improve translation quality.

Result: Typical migrations require reading 38 lines and writing 58 lines of configuration, half involve multiple commits. LLM-generated translations show substantial issues: logic inconsistencies (38%), platform discrepancies (32%), environment errors (25%), syntax errors (5%). Combining guideline-based prompting with iterative refinement significantly improves results, achieving a 75.5% Build Success Rate, almost three times higher than GPT-4o with a basic prompt.

Conclusion: LLMs can be leveraged for CI configuration translation, but naive application yields many errors. Guided, iterative approaches greatly enhance accuracy and reliability, making LLM-assisted migration a promising direction for reducing developer effort.

Abstract: Continuous Integration (CI) is a cornerstone of modern collaborative software
development, and numerous CI platforms are available. Differences in
maintenance overhead, reliability, and integration depth with code-hosting
platforms make migration between CI platforms a common practice. A central step
in migration is translating CI configurations, which is challenging due to the
intrinsic complexity of CI configurations and the need to understand semantic
differences and relationships across CI platforms.
  With the advent of large language models (LLMs), recent advances in software
engineering highlight their potential for CI configuration translation. In this
paper, we present a study on LLM-based CI configuration translation, focusing
on the migration from Travis CI to GitHub Actions. First, using 811 migration
records, we quantify the effort involved and find that developers read an
average of 38 lines of Travis configuration and write 58 lines of GitHub
Actions configuration, with nearly half of the migrations requiring multiple
commits. We further analyze translations produced by each of the four LLMs and
identify 1,121 issues grouped into four categories: logic inconsistencies
(38%), platform discrepancies (32%), environment errors (25%), and syntax
errors (5%). Finally, we evaluate three enhancement strategies and show that
combining guideline-based prompting with iterative refinement achieves the best
performance, reaching a Build Success Rate of 75.5%-nearly a threefold
improvement over GPT-4o with a basic prompt.

</details>


### [34] [AI for Requirements Engineering: Industry adoption and Practitioner perspectives](https://arxiv.org/abs/2511.01324)
*Lekshmi Murali Rani,Richard Berntsson Svensson,Robert Feldt*

Main category: cs.SE

TL;DR: AI adoption in requirements engineering is already significant and well-perceived, with practitioners favoring collaborative (HAIC) models over full automation or passive AI support. This underscores the importance of developing collaborative frameworks and responsible governance for AI in RE.


<details>
  <summary>Details</summary>
Motivation: Despite the fundamental role of Requirements Engineering (RE) in software engineering, there is limited research on how AI is adopted in RE practices. Understanding this integration is crucial as AI presents both opportunities and challenges for improving RE processes.

Method: The authors conducted a survey with 55 software practitioners to investigate AI usage across four RE phases (Elicitation, Analysis, Specification, and Validation) and four decision-making approaches (human only, AI validation, Human-AI Collaboration - HAIC, and full AI automation). They also collected perceptions, challenges, and opportunities regarding AI in RE.

Result: 58.2% of respondents already use AI in RE, and 69.1% perceive its impact as positive or very positive. Human-AI Collaboration (HAIC) is the predominant approach, making up 54.4% of RE techniques. Full AI automation and passive AI validation are used minimally, indicating practitioners' preference for AI as an active collaborative tool rather than a passive observer or full replacement for humans.

Conclusion: AI is most effective in RE when used as a collaborative partner alongside human expertise, rather than a complete replacement or solely as passive validation. There is a clear need for RE-specific HAIC frameworks and strong AI governance as adoption expands.

Abstract: The integration of AI for Requirements Engineering (RE) presents significant
benefits but also poses real challenges.Although RE is fundamental to software
engineering, limited research has examined AI adoption in RE.We surveyed 55
software practitioners to map AI usage across four RE phases:Elicitation,
Analysis, Specification, and Validation, and four approaches for decision
making: human only decisions, AI validation, Human AI Collaboration (HAIC), and
full AI automation.Participants also shared their perceptions, challenges, and
opportunities when applying AI for RE tasks.Our data show that 58.2% of
respondents already use AI in RE, and 69.1% view its impact as positive or very
positive.HAIC dominates practice, accounting for 54.4% of all RE techniques,
while full AI automation remains minimal at 5.4%.Passive AI validation (4.4 to
6.2%) lags even further behind, indicating that practitioners value AI's active
support over passive oversight.These findings suggest that AI is most effective
when positioned as a collaborative partner rather than a replacement for human
expertise.It also highlights the need for RE specific HAIC frameworks along
with robust and responsible AI governance as AI adoption in RE grows.

</details>


### [35] [The Future of Generative AI in Software Engineering: A Vision from Industry and Academia in the European GENIUS Project](https://arxiv.org/abs/2511.01348)
*Robin Gröpler,Steffen Klepke,Jack Johns,Andreas Dreschinski,Klaus Schmid,Benedikt Dornauer,Eray Tüzün,Joost Noppen,Mohammad Reza Mousavi,Yongjian Tang,Johannes Viehmann,Selin Şirin Aslangül,Beum Seuk Lee,Adam Ziolkowski,Eric Zie*

Main category: cs.SE

TL;DR: This vision paper provides a roadmap for integrating Generative AI throughout the Software Development Life Cycle, identifying current challenges and future opportunities, and advancing both research and industrial practice through the GENIUS consortium's initiatives.


<details>
  <summary>Details</summary>
Motivation: Generative AI holds significant promise for software engineering, especially in coding tasks. However, its application throughout the entire Software Development Life Cycle (SDLC) remains underexplored, particularly in terms of reliability, accountability, security, and data privacy.

Method: The authors present a vision paper that integrates cross-sector dialogue, experiences from the multinational GENIUS consortium, and an exploratory literature review. They examine current challenges, forecast future advances, analyze shifts in professional roles, and outline GENIUS's contributions through tools and industrial validation.

Result: The paper delivers a structured overview of GenAI's adoption challenges, offers a forward-looking vision for technological and methodological advances, anticipates the evolution of software professionals' roles, and details how GENIUS's efforts can drive this comprehensive transformation.

Conclusion: Aligning technical innovation with business needs, the paper argues that a collaborative, holistic approach is critical for developing scalable, reliable, and industry-ready GenAI solutions for software engineering teams.

Abstract: Generative AI (GenAI) has recently emerged as a groundbreaking force in
Software Engineering, capable of generating code, suggesting fixes, and
supporting quality assurance. While its use in coding tasks shows considerable
promise, applying GenAI across the entire Software Development Life Cycle
(SDLC) has not yet been fully explored. Critical uncertainties in areas such as
reliability, accountability, security, and data privacy demand deeper
investigation and coordinated action. The GENIUS project, comprising over 30
European industrial and academic partners, aims to address these challenges by
advancing AI integration across all SDLC phases. It focuses on GenAI's
potential, the development of innovative tools, and emerging research
challenges, actively shaping the future of software engineering. This vision
paper presents a shared perspective on the future of GenAI-based software
engineering, grounded in cross-sector dialogue and experience within the GENIUS
consortium, supported by an exploratory literature review. The paper explores
four central elements: (1) a structured overview of current challenges in GenAI
adoption across the SDLC; (2) a forward-looking vision outlining key
technological and methodological advances expected over the next five years;
(3) anticipated shifts in the roles and required skill sets of software
professionals; and (4) the contribution of GENIUS in realizing this
transformation through practical tools and industrial validation. By aligning
technical innovation with business relevance, this paper aims to inform both
research agendas and industrial strategies, providing a foundation for
reliable, scalable, and industry-ready GenAI solutions for software engineering
teams.

</details>


### [36] [Characterizing Build Compromises Through Vulnerability Disclosure Analysis](https://arxiv.org/abs/2511.01395)
*Maimouna Tamah Diao,Moustapha Awwalou Diouf,Iyiola Emmanuel Olatunji,Abdoul Kader Kaboré,Gervais Mendy,Jacques Klein,Tegawendé F. Bissyandé*

Main category: cs.SE

TL;DR: This paper analyzes vulnerabilities in the software build process, creating an attack taxonomy using large-scale CVE mining and supply chain attack analysis. Nearly a quarter of supply chain attacks exploit build vulnerabilities, mainly via dependency confusion and build script injection. The results point to urgent needs for security improvements in build infrastructure.


<details>
  <summary>Details</summary>
Motivation: The build process is essential in software development but is vulnerable to unique security threats, which are not systematically understood by the security community.

Method: The authors mined 621 CVEs from the NVD database to empirically derive a taxonomy of build process attack vectors. They further validated this taxonomy by analyzing 168 documented software supply chain attacks.

Result: The study found that 23.8% of supply chain attacks target build vulnerabilities, with dependency confusion and build script injection being the most common attack vectors.

Conclusion: The systematic taxonomy and empirical evidence reveal significant gaps in build infrastructure security, highlighting the need for targeted defenses and better understanding of build-specific attacks.

Abstract: The software build process transforms source code into deployable artifacts,
representing a critical yet vulnerable stage in software development. Build
infrastructure security poses unique challenges: the complexity of
multi-component systems (source code, dependencies, build tools), the
difficulty of detecting intrusions during compilation, and prevalent build
non-determinism that masks malicious modifications. Despite these risks, the
security community lacks a systematic understanding of build-specific attack
vectors, hindering effective defense design.
  This paper presents an empirically-derived taxonomy of attack vectors
targeting the build process, constructed through a large-scale CVE mining (of
621 vulnerability disclosures from the NVD database). We categorize attack
vectors by their injection points across the build pipeline, from source code
manipulation to compiler compromise. To validate our taxonomy, we analyzed 168
documented software supply chain attacks, identifying 40 incidents specifically
targeting build phases. Our analysis reveals that 23.8\% of supply chain
attacks exploit build vulnerabilities, with dependency confusion and build
script injection representing the most prevalent vectors.
  Dataset available at:
https://anonymous.4open.science/r/Taxonomizing-Build-Attacks-8BB0.

</details>


### [37] [VeriODD: From YAML to SMT-LIB - Automating Verification of Operational Design Domains](https://arxiv.org/abs/2511.01417)
*Bassel Rafie,Christian Schindler,Andreas Rausch*

Main category: cs.SE

TL;DR: Manual translation of human-friendly ODD/COD safety specs for autonomous vehicles into formal logic is slow and error-prone. VeriODD automates this process, generating both readable logic and solver-ready formats for efficient, scalable safety verification, complete with a GUI for easy stakeholder use.


<details>
  <summary>Details</summary>
Motivation: Ensuring the safety of automated driving systems requires verifying that the runtime situation (COD) remains within the predetermined safe boundaries (ODD). Current descriptions are often done in human-friendly (YAML) form, which is not suitable for automated, formal verification, leading to manual, error-prone, and inefficient processes.

Method: The authors developed VeriODD, a tool that automatically translates YAML-based ODD/COD specifications into human-readable propositional logic and solver-ready SMT-LIB formats, using ANTLR-based compiler technology. The tool also integrates with SMT solvers (like Z3) for automated consistency and conformance checks, and provides a graphical user interface for specifications editing and verification.

Result: VeriODD successfully streamlines the process of translating stakeholder-friendly, YAML-form ODD/COD descriptions into formal representations suitable for automated verification. This enables scalable, automated assurance of operational boundaries for autonomous driving systems, bridging the gap between readable specifications and robust, solver-based safety checks.

Conclusion: VeriODD facilitates reliable, automated verification of ODD/COD boundaries in autonomous driving by converting accessible YAML specifications into formal logic and enabling integrated, user-friendly consistency and conformance checks.

Abstract: Operational Design Domains (ODDs) define the conditions under which an
Automated Driving System (ADS) is allowed to operate, while Current Operational
Domains (CODs) capture the actual runtime situation. Ensuring that a COD
instance lies within the ODD is a crucial step in safety assurance. Today, ODD
and COD specifications are frequently expressed in YAML to remain accessible
for stakeholders, but such descriptions are not directly suitable for
solver-based verification. Manual translation into formal languages such as
SMT-LIB is slow and error-prone. We present VeriODD, a tool that automates this
translation. VeriODD uses ANTLR-based compiler technology to transform
YAML-based ODD/COD specifications into both human-readable propositional logic,
for lightweight review on a simple basis, and solver-ready SMT-LIB. The tool
integrates with SMT solvers such as Z3 to provide automated consistency checks
of ODD specifications and verification of COD conformance. A graphical user
interface supports editing specifications, inspecting generated formulas, and
performing verification with a single click. VeriODD thereby closes the gap
between stakeholder-friendly ODD/COD notations and formal verification,
enabling scalable and automated assurance of operational boundaries in
autonomous driving. Video demonstration: https://youtu.be/odRacNoL_Pk Tool
available at: https://github.com/BasselRafie/VeriODD

</details>


### [38] [LLM-Assisted Tool for Joint Generation of Formulas and Functions in Rule-Based Verification of Map Transformations](https://arxiv.org/abs/2511.01423)
*Ruidi He,Yu Zhang,Meng Zhang,Andreas Rausch*

Main category: cs.SE

TL;DR: The paper demonstrates a scalable, LLM-assisted method for generating logic formulas and predicates to verify high-definition map transformations in autonomous driving, reducing manual work while maintaining correctness.


<details>
  <summary>Details</summary>
Motivation: Existing rule-based frameworks for high-definition map transformations in autonomous driving rely heavily on manually written formulas, limiting their scalability and making semantic correctness difficult to ensure.

Method: The paper introduces an LLM-assisted pipeline that jointly generates logical formulas and corresponding executable predicates within a computational first-order logic (FOL) framework. This extends the existing map verifier in the CommonRoad scenario designer with support for elevation features, leveraging prompt-based LLMs to generate grammar-compliant rules integrated into the system.

Result: The proposed system was prototyped and evaluated on synthetic bridge and slope scenarios. The evaluation showed that it reduces the need for manual engineering while preserving the semantic correctness of map transformations.

Conclusion: The LLM-assisted pipeline makes map-transformation verification more scalable and feasible through a semi-automated, human-in-the-loop approach, decreasing manual effort and maintaining correctness.

Abstract: High-definition map transformations are essential in autonomous driving
systems, enabling interoperability across tools. Ensuring their semantic
correctness is challenging, since existing rule-based frameworks rely on
manually written formulas and domain-specific functions, limiting scalability.
  In this paper, We present an LLM-assisted pipeline that jointly generates
logical formulas and corresponding executable predicates within a computational
FOL framework, extending the map verifier in CommonRoad scenario designer with
elevation support. The pipeline leverages prompt-based LLM generation to
produce grammar-compliant rules and predicates that integrate directly into the
existing system.
  We implemented a prototype and evaluated it on synthetic bridge and slope
scenarios. The results indicate reduced manual engineering effort while
preserving correctness, demonstrating the feasibility of a scalable,
semi-automated human-in-the-loop approach to map-transformation verification.

</details>


### [39] [From Pre-labeling to Production: Engineering Lessons from a Machine Learning Pipeline in the Public Sector](https://arxiv.org/abs/2511.01545)
*Ronivaldo Ferreira,Guilherme da Silva,Carla Rocha,Gustavo Pinto*

Main category: cs.SE

TL;DR: Building ML for government is not just a technical challenge. Study of Brazil's BP platform shows that quick engineering solutions (like using LLMs, routed classifiers, and synthetic data) can save time but bring new risks if not supported by strong data governance and human checks. ML in the public sector needs good institutional practices and robust civic data infrastructure to be trustworthy and sustainable.


<details>
  <summary>Details</summary>
Motivation: The paper is motivated by the challenges of implementing machine learning (ML) systems in the public sector, where there are unique operational, technical, and organizational constraints. These include issues like extreme data imbalance, data drift, bureaucratic obstacles, lack of versioned datasets, and gaps in governance and monitoring.

Method: The study analyzes the Brasil Participativo (BP) platform, examining the engineering choices made when implementing ML, such as using large language models (LLMs) for pre-labeling, splitting models into routed classifiers, and generating synthetic data. The paper considers both technical and organizational factors that influence ML system reliability and sustainability.

Result: The study finds that while common engineering choices can speed up the development of ML systems, they also introduce risks related to traceability, reliability, and cost if not accompanied by strong data governance and human involvement. It highlights that responsible ML in the public sector requires treating ML systems as civic infrastructure and emphasizes institutional practices over technical advancement alone.

Conclusion: The paper concludes that success in public-sector ML depends not on model accuracy but on the institution's ability to build transparent, reproducible, and accountable data infrastructures. Responsible ML is primarily an institutional engineering challenge rather than just a technical one.

Abstract: Machine learning is increasingly being embedded into government digital
platforms, but public-sector constraints make it difficult to build ML systems
that are accurate, auditable, and operationally sustainable. In practice, teams
face not only technical issues like extreme class imbalance and data drift, but
also organizational barriers such as bureaucratic data access, lack of
versioned datasets, and incomplete governance over provenance and monitoring.
Our study of the Brasil Participativo (BP) platform shows that common
engineering choices -- like using LLMs for pre-labeling, splitting models into
routed classifiers, and generating synthetic data -- can speed development but
also introduce new traceability, reliability, and cost risks if not paired with
disciplined data governance and human validation. This means that, in the
public sector, responsible ML is not just a modeling problem but an
institutional engineering problem, and ML pipelines must be treated as civic
infrastructure. Ultimately, this study shows that the success of machine
learning in the public sector will depend less on breakthroughs in model
accuracy and more on the ability of institutions to engineer transparent,
reproducible, and accountable data infrastructures that citizens can trust.

</details>


### [40] [Towards LLM-Powered Task-Aware Retrieval of Scientific Workflows for Galaxy](https://arxiv.org/abs/2511.01757)
*Shamse Tasnim Cynthia,Banani Roy*

Main category: cs.SE

TL;DR: This paper presents a novel workflow search framework for Galaxy. By combining dense vector retrieval and LLM-based reranking, their approach surpasses traditional keyword search in both relevance and accuracy, particularly for complex or underspecified queries. The solution is validated through benchmark testing and integrated as a prototype, promising improved usability for a wide user base.


<details>
  <summary>Details</summary>
Motivation: Galaxy’s workflow search is limited: traditional keyword matching fails when queries don’t correspond exactly to workflow terms, making it difficult for users to find relevant workflows in complex or unfamiliar domains.

Method: The authors propose a two-stage retrieval framework: (1) workflows are initially retrieved using dense embedding models; (2) top candidates are reranked with instruction-tuned large language models (GPT-4o, Mistral-7B) based on semantic task alignment. The system is evaluated using a benchmark set of workflows annotated via BERTopic and realistic queries generated by LLMs.

Result: Their system outperforms traditional keyword search and other baselines, offering improved accuracy and relevance for top-k results, especially with long or vaguely-worded queries. It is deployed as a prototype in Galaxy.

Conclusion: Integrating dense retrieval with LLM-based reranking significantly enhances workflow search in Galaxy, broadening accessibility for less experienced users and multidisciplinary researchers.

Abstract: Scientific Workflow Management Systems (SWfMSs) such as Galaxy have become
essential infrastructure in bioinformatics, supporting the design, execution,
and sharing of complex multi-step analyses. Despite hosting hundreds of
reusable workflows across domains, Galaxy's current keyword-based retrieval
system offers limited support for semantic query interpretation and often fails
to surface relevant workflows when exact term matches are absent. To address
this gap, we propose a task-aware, two-stage retrieval framework that
integrates dense vector search with large language model (LLM)-based reranking.
Our system first retrieves candidate workflows using state-of-the-art embedding
models and then reranks them using instruction-tuned generative LLMs (GPT-4o,
Mistral-7B) based on semantic task alignment. To support robust evaluation, we
construct a benchmark dataset of Galaxy workflows annotated with semantic
topics via BERTopic and synthesize realistic task-oriented queries using LLMs.
We conduct a comprehensive comparison of lexical, dense, and reranking models
using standard IR metrics, presenting the first systematic evaluation of
retrieval performance in the Galaxy ecosystem. Results show that our approach
significantly improves top-k accuracy and relevance, particularly for long or
under-specified queries. We further integrate our system as a prototype tool
within Galaxy, providing a proof-of-concept for LLM-enhanced workflow search.
This work advances the usability and accessibility of scientific workflows,
especially for novice users and interdisciplinary researchers.

</details>


### [41] [Context-Guided Decompilation: A Step Towards Re-executability](https://arxiv.org/abs/2511.01763)
*Xiaohan Wang,Yuxin Hu,Kevin Leach*

Main category: cs.SE

TL;DR: ICL4Decomp uses in-context learning to help LLMs produce source code from binaries that can actually be recompiled and run, improving re-executability by about 40% over current methods.


<details>
  <summary>Details</summary>
Motivation: Existing binary decompilation techniques struggle to generate source code that can be recompilable and executable, especially for optimized binaries; using LLMs often produces code that is only semantically plausible, not reliably executable. This limitation is due to compiler optimizations and the loss of semantic information, which LLMs cannot recover effectively without more guidance.

Method: The authors propose ICL4Decomp, a hybrid decompilation framework that utilizes in-context learning (ICL) to better guide large language models (LLMs) towards generating source code that can be successfully re-executed. The method is evaluated across various datasets, optimization levels, and compilers.

Result: ICL4Decomp demonstrates around 40% improvement in re-executability compared to state-of-the-art decompilation methods, while maintaining robustness.

Conclusion: ICL4Decomp significantly enhances the reliability and practicality of neural binary decompilation by guiding LLMs via in-context learning, which results in higher rates of generating re-executable source code, overcoming challenges posed by compiler optimizations.

Abstract: Binary decompilation plays an important role in software security analysis,
reverse engineering, and malware understanding when source code is unavailable.
However, existing decompilation techniques often fail to produce source code
that can be successfully recompiled and re-executed, particularly for optimized
binaries. Recent advances in large language models (LLMs) have enabled neural
approaches to decompilation, but the generated code is typically only
semantically plausible rather than truly executable, limiting their practical
reliability. These shortcomings arise from compiler optimizations and the loss
of semantic cues in compiled code, which LLMs struggle to recover without
contextual guidance. To address this challenge, we propose ICL4Decomp, a hybrid
decompilation framework that leverages in-context learning (ICL) to guide LLMs
toward generating re-executable source code. We evaluate our method across
multiple datasets, optimization levels, and compilers, demonstrating around
40\% improvement in re-executability over state-of-the-art decompilation
methods while maintaining robustness.

</details>


### [42] [SmartMLOps Studio: Design of an LLM-Integrated IDE with Automated MLOps Pipelines for Model Development and Monitoring](https://arxiv.org/abs/2511.01850)
*Jiawei Jin,Yingxin Su,Xiaotong Zhu*

Main category: cs.SE

TL;DR: A new LLM-powered IDE, SmartMLOps Studio, streamlines ML model development and monitoring by combining intelligent code assistance and automated MLOps pipelines. It significantly improves workflow efficiency and experiment reproducibility compared to traditional methods.


<details>
  <summary>Details</summary>
Motivation: AI and ML applications are growing rapidly, creating a need for environments that unify model development, deployment, and monitoring. Existing IDEs focus mainly on coding, while MLOps platforms are separated from development workflows, leaving a gap in supporting the complete ML lifecycle.

Method: The study designed and implemented an LLM-Integrated IDE called SmartMLOps Studio. This IDE includes a Large Language Model assistant for code generation, debugging, and automated MLOps pipeline configuration. The backend provides features such as automated data validation, feature storage, drift detection, retraining triggers, and CI/CD deployment orchestration. The prototype was evaluated using classification and forecasting tasks on standard datasets.

Result: SmartMLOps Studio reduces pipeline configuration time by 61%, improves experiment reproducibility by 45%, and increases drift detection accuracy by 14% compared to traditional workflows.

Conclusion: Integrating LLM-powered intelligent code assistance and automated MLOps pipelines within an IDE establishes a new paradigm for AI engineering, making model development more scalable, efficient, and lifecycle-aware.

Abstract: The rapid expansion of artificial intelligence and machine learning (ML)
applications has intensified the demand for integrated environments that unify
model development, deployment, and monitoring. Traditional Integrated
Development Environments (IDEs) focus primarily on code authoring, lacking
intelligent support for the full ML lifecycle, while existing MLOps platforms
remain detached from the coding workflow. To address this gap, this study
proposes the design of an LLM-Integrated IDE with automated MLOps pipelines
that enables continuous model development and monitoring within a single
environment. The proposed system embeds a Large Language Model (LLM) assistant
capable of code generation, debugging recommendation, and automatic pipeline
configuration. The backend incorporates automated data validation, feature
storage, drift detection, retraining triggers, and CI/CD deployment
orchestration. This framework was implemented in a prototype named SmartMLOps
Studio and evaluated using classification and forecasting tasks on the UCI
Adult and M5 datasets. Experimental results demonstrate that SmartMLOps Studio
reduces pipeline configuration time by 61%, improves experiment reproducibility
by 45%, and increases drift detection accuracy by 14% compared to traditional
workflows. By bridging intelligent code assistance and automated operational
pipelines, this research establishes a novel paradigm for AI engineering -
transforming the IDE from a static coding tool into a dynamic, lifecycle-aware
intelligent platform for scalable and efficient model development.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [43] [Equality Saturation Guided by Large Language Models](https://arxiv.org/abs/2511.00403)
*Wentao Peng,Ruyi Ji,Yingfei Xiong*

Main category: cs.PL

TL;DR: LGuess (LLM-guided equality saturation) combines e-graphs with LLMs to address correctness issues in rewrite chain generation. It achieves better results in polynomial factorization tasks than current alternatives by strategically querying LLMs and using a learned model for checkpoints.


<details>
  <summary>Details</summary>
Motivation: Current LLMs struggle to guarantee correctness in generating rewrite chains for formal systems. Improving their reliability and soundness is crucial, especially for mathematical transformations like factorization.

Method: The authors introduce LGuess, a framework that inserts e-graphs between LLMs and formal rewrite systems. LGuess queries LLMs for high-level rewrite checkpoints and employs e-graphs to generate low-level rewrite chains. A learned probabilistic model aids in extracting optimal checkpoints from the e-graph.

Result: The prototype of LGuess, evaluated on multivariable polynomial factorization, shows a significant performance advantage over straightforward equality saturation and direct LLM query approaches.

Conclusion: LGuess significantly outperforms both traditional equality saturation and direct LLM-based rewrite chain generation in multivariable polynomial factorization, providing better correctness guarantees.

Abstract: One critical issue with large language models (LLMs) is their inability to
guarantee correctness. Although this problem can be addressed by applying LLMs
to formal rewrite systems, current LLMs are still far from adequate to generate
sound rewrite chains. To bridge this gap, this paper proposes LLM-guided
equality saturation, dubbed LGuess, by incorporating e-graphs as an
intermediate layer between LLMs and rewrite systems. LGuess queries LLMs only
for high-level rewrite checkpoints and uses e-graphs to supply low-level
rewrite chains between these checkpoints. The key technical challenge in this
procedure lies in effectively extracting a suitable checkpoint from a saturated
e-graph, which LGuess addresses by learning a probabilistic model from the LLM.
The model predicts probable checkpoints while remaining simple enough for
effective extraction. We implement a prototype of LGuess and evaluate it on the
problem of factorizing multivariable polynomials. The results demonstrate a
significant advantage of LGuess compared to both straightforward equality
saturation and the approach that queries the LLM directly for the rewrite
chain.

</details>


### [44] [\texttt{ReMind}: Understanding Deductive Code Reasoning in LLMs](https://arxiv.org/abs/2511.00488)
*Jun Gao,Yun Peng,Xiaoxue Ren*

Main category: cs.PL

TL;DR: LLMs have difficulty with deductive code reasoning due to intrinsic limitations. The proposed ReMind framework uses a collaborative multi-agent approach to diagnose and address these problems, leading to improved, generalizable performance over existing methods.


<details>
  <summary>Details</summary>
Motivation: LLMs are good at code-related tasks but struggle with deductive code reasoning, which involves understanding and reasoning about program execution. The reasons for this limitation are not well understood, and current solutions are inadequate.

Method: The authors conduct a comprehensive empirical study to identify key challenges in deductive code reasoning for LLMs. Based on these insights, they introduce ReMind, a multi-agent framework with three components: Mutator (generates code variants to reduce source code bias), Executor (traces variable states to reveal inconsistencies), and Inspector (detects and refines flawed reasoning steps).

Result: ReMind systematically identifies and improves reasoning errors, resulting in robust zero-shot generalization and outstanding performance on deductive code reasoning tasks. It outperforms baseline methods across two benchmarks and five LLMs.

Conclusion: ReMind significantly enhances deductive code reasoning in LLMs by addressing intrinsic capability gaps, source bias, and generalization issues through a collaborative multi-agent approach.

Abstract: Large Language Models (LLMs) have achieved remarkable progress in
code-related tasks. Despite their advancement, empirical evidence reveals that
they still struggle with \emph{deductive code reasoning}, the ability to reason
about the program execution process. While prior studies have recognized this
limitation, the underlying causes remain largely underexplored. In this paper,
we begin by presenting a comprehensive empirical study that reveals three key
challenges undermining deductive code reasoning: (1) an intrinsic gap between
generation and reasoning abilities, (2) a consistent bias towards code sources,
and (3) weak zero-shot generalization on complex benchmarks. In light of these
challenges, we propose \texttt{ReMind}, a multi-agent framework composed of
\texttt{Mutator}, \texttt{Executor}, and \texttt{Inspector}. The
\texttt{Mutator} generates code variants to mitigate bias towards code sources,
the \texttt{Executor} traces variable states step-by-step to expose
inconsistency, and the \texttt{Inspector} identifies problematic reasoning
steps and provides control-flow refinement to bridge the intrinsic reasoning
gap. Through their coordinated collaboration, \texttt{ReMind} systematically
identifies and refines reasoning flaws, achieving outstanding performance and
enabling robust zero-shot generalization. Extensive experiments on two
benchmarks with five LLMs demonstrate the superior advantages of
\texttt{ReMind} compared to baseline approaches in deductive code reasoning.

</details>


### [45] [Agentic Auto-Scheduling: An Experimental Study of LLM-Guided Loop Optimization](https://arxiv.org/abs/2511.00592)
*Massinissa Merouani,Islem Kara Bernou,Riyadh Baghdadi*

Main category: cs.PL

TL;DR: ComPilot uses standard LLMs and compiler feedback in a feedback loop to propose and refine code optimizations, achieving significant speedups and competitive results versus traditional optimizers, with no task-specific fine-tuning required.


<details>
  <summary>Details</summary>
Motivation: Optimizing complex loop nests on modern hardware is challenging, and existing tools often require task-specific configuration or tuning. The motivation here is to explore whether large language models (LLMs) can be leveraged in a generalized, flexible manner to guide automatic code optimization without the need for specialized fine-tuning.

Method: The authors introduce ComPilot, a framework using off-the-shelf LLMs (without specific fine-tuning) as agents that interact with a compiler. In a closed-loop system, the LLM suggests code transformations, which the compiler attempts. The compiler feeds back legality and performance data (speedup/slowdown), which the LLM uses to further refine its suggestions iteratively.

Result: Extensive testing on the PolyBench benchmark suite shows ComPilot achieves significant geometric mean speedups: 2.66x for a single run and 3.54x for the best of five runs. ComPilot performs competitively and even outperforms the Pluto polyhedral optimizer in several cases.

Conclusion: General-purpose LLMs, when integrated with compiler feedback, can effectively guide code optimization, matching or exceeding traditional state-of-the-art methods. This approach suggests new directions for AI agents in program optimization.

Abstract: Automatic code optimization remains a difficult challenge, particularly for
complex loop nests on modern hardware. This paper investigates a novel approach
to code optimization where Large Language Models (LLMs) guide the process
through a closed-loop interaction with a compiler. We present ComPilot, an
experimental framework that leverages off-the-shelf LLMs, without any
task-specific fine-tuning, as interactive optimization agents. ComPilot
establishes a feedback loop where an LLM proposes transformations for a given
loop nest to a compiler. The compiler attempts the transformations, reporting
back legality status and measured speedup or slowdown. The LLM utilizes this
concrete feedback to iteratively refine its optimization strategy. Our
extensive evaluation across the PolyBench benchmark suite demonstrates the
effectiveness of this zero-shot approach. ComPilot achieves geometric mean
speedups of 2.66x (single run) and 3.54x (best-of-5 runs) over the original
code. Furthermore, ComPilot demonstrates competitive performance against the
state-of-the-art Pluto polyhedral optimizer, outperforming it in many cases.
This experimental study demonstrates that general-purpose LLMs can effectively
guide the code optimization process when grounded by compiler feedback, opening
promising research directions for agentic AI in code optimization.

</details>


### [46] [Typed Embedding of miniKanren for Functional Conversion](https://arxiv.org/abs/2511.00740)
*Igor Engel,Ekaterina Verbitskaia*

Main category: cs.PL

TL;DR: This paper refines relational programming in Haskell by integrating miniKanren via a typed tagless-final approach, removing much of the manual overhead and retaining or improving performance.


<details>
  <summary>Details</summary>
Motivation: Previous relational programming approaches suffered from performance issues and inelegant abstractions, requiring manual determinism annotations and implicit generator threading.

Method: The authors present a typed tagless-final embedding of miniKanren into Haskell, restructuring the implementation to be more type-aware and reducing boilerplate.

Result: The new embedding not only reduces programming boilerplate but also retains or improves performance gains achieved in earlier work.

Conclusion: The proposed approach streamlines relational programming in Haskell, making it more efficient and convenient without sacrificing speed.

Abstract: Relational programming enables program synthesis through a verifier-to-solver
approach. An earlier paper introduced a functional conversion that mitigated
some of the inherent performance overhead. However, the conversion was
inelegant: it was oblivious to types, demanded determinism annotations, and
implicit generator threading. In this paper, we address these issues by
providing a typed tagless-final embedding of miniKanren into Haskell. This
improvement significantly reduces boilerplate while preserving, and sometimes
enhancing, earlier speedups.

</details>


### [47] [Cobble: Compiling Block Encodings for Quantum Computational Linear Algebra](https://arxiv.org/abs/2511.01736)
*Charles Yuan*

Main category: cs.PL

TL;DR: Cobble is a new high-level language for quantum linear algebra programming that automatically compiles concise matrix operations into optimized quantum circuits. It provides resource analysis and state-of-the-art optimizations, demonstrating significant speedups over existing circuit optimizers in common quantum algorithm benchmarks.


<details>
  <summary>Details</summary>
Motivation: Quantum linear algebra algorithms can offer exponential speedups for tasks like simulation and regression, but developing these algorithms for quantum hardware is challenging. Classical memory and optimization strategies can't be easily transferred to quantum systems, requiring complex and specialized quantum programming techniques.

Method: The authors introduce Cobble, a high-level programming language for quantum computational linear algebra. Cobble lets developers express quantum matrix operations (block encodings) in concise notation, which is automatically compiled into efficient quantum circuits. It includes tools for resource analysis and leading-edge circuit optimizations, like quantum singular value transformation.

Result: Cobble was tested on benchmark applications such as simulation, regression, and search. It produced quantum circuits with speedups ranging from 2.6x to 25.4x over existing quantum circuit optimization tools on these benchmarks.

Conclusion: Cobble substantially simplifies the development of quantum linear algebra programs, allowing for more efficient circuit generation and resource analysis. It leads to better performance compared to current tools, and can accelerate practical applications of quantum computational linear algebra.

Abstract: Quantum algorithms for computational linear algebra promise up to exponential
speedups for applications such as simulation and regression, making them prime
candidates for hardware realization. But these algorithms execute in a model
that cannot efficiently store matrices in memory like a classical algorithm
does, instead requiring developers to implement complex expressions for matrix
arithmetic in terms of correct and efficient quantum circuits. Among the
challenges for the developer is navigating a cost model in which conventional
optimizations for linear algebra, such as subexpression reuse, can be
inapplicable or unprofitable.
  In this work, we present Cobble, a language for programming with quantum
computational linear algebra. Cobble enables developers to express and
manipulate the quantum representations of matrices, known as block encodings,
using high-level notation that automatically compiles to correct quantum
circuits. Cobble features analyses that estimate leading factors in time and
space usage of programs, as well as optimizations that reduce overhead and
generate efficient circuits using leading techniques such as the quantum
singular value transformation. We evaluate Cobble on benchmark kernels for
simulation, regression, search, and other applications, showing 2.6x-25.4x
speedups not achieved by existing circuit optimizers on these benchmarks.

</details>
